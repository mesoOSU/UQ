C *******************************************************************
C   ROUTINES USED BY CODE VPSC7.FOR (INCLUDED DURING COMPILATION)
C *******************************************************************
C
C     SUBROUTINES:
C
C     SUBROUTINE CHECK_VOCE      --->      VERSION 12/JUN/2001
C     SUBROUTINE CHG_BASIS    --->   VERSION 19/JUL/01
C     SUBROUTINE CRYSTAL_SYMMETRY   --->   VERSION 09/JAN/2009
C     SUBROUTINE CUBCOMP      --->      VERSION 19/SET/00
C     SUBROUTINE DATA_CRYSTAL        --->      VERSION 14/FEB/2011
C     SUBROUTINE DATA_GRAIN        --->      VERSION 10/sep/2004
C     SUBROUTINE ELSC      --->      VERSION OF 01/JAN/09
C     SUBROUTINE ESHELBY      --->      VERSION 15/NOV/07
C     SUBROUTINE ESH_INV3_VOIGT   --->   VERSION 23/JUL/01
C     SUBROUTINE ESH_INV4_VOIGT   --->   VERSION 20/JUL/01
C     SUBROUTINE ESH_MULT_VOIGT(B,C,A)
C     SUBROUTINE EULER (iopt,ph,th,tm,a)
C     SUBROUTINE GRAIN_INFO (ex GRINFO)   --->   VERSION 28/may/2002
C     SUBROUTINE GRAIN_RATE_AND_MODULI (ex MICRO) -->  VERSION 17/DEC/02
C     SUBROUTINE GRAIN_STRESS (ex VISC)   --->   version of 19/MAR/2003
C     SUBROUTINE INITIAL_STATE_GUESS     --->     VERSION 07/DEC/05
C     SUBROUTINE LANKFORD     --->      VERSION OF 05/APR/07
C     SUBROUTINE LOAD_CONDITIONS      -->      VERSION 07/DEC/2005
C     SUBROUTINE LU_INVERSE(A,N)
C     SUBROUTINE LU_EQSYSTEM(A,B,N,ISINGULAR)
C     SUBROUTINE N_EFFECTIVE  --->   VERSION 27/JAN/99
C     SUBROUTINE STATISTICS      --->      VERSION 02/APR/2004
C     SUBROUTINE NEIGHBOURS      --->      VERSION 25/JUL/2002
C     SUBROUTINE NEWTON_RAPHSON (ex SNLNR)   --->   VERSION APR/2003
C     SUBROUTINE NORMALIZE   ---->   VERSION 26/MAY/2000
C     SUBROUTINE PCYS      --->      VERSION 07/SET/06
C     SUBROUTINE PCYS_IT      --->      VERSION 04/OCT/2011
C     SUBROUTINE POSTMORTEM     --->      VERSION 09/OCT/2006
C     SUBROUTINE POSTMORTEM_FE     --->      VERSION 19/MAR/07
C     SUBROUTINE RODRIGUES (ex-REORIENT_GRAIN)   --->   VERSION 03/NOV/09
C     SUBROUTINE SCALE_3   ---->   VERSION 26/MAY/2000
C     SUBROUTINE STATE_5x5      --->      VERSION 26/jan/2000
C     SUBROUTINE STATE_6x6      --->      VERSION 16/NOV/97
C     SUBROUTINE STAT_GRAIN_SHAPE
C     SUBROUTINE STAT_SHEAR_ACTIVITY
C     SUBROUTINE STAT_STRESS_STRAIN
C     SUBROUTINE TEXTURE_ROTATION     --->      VERSION 14/OCT/2006
C     SUBROUTINE TWIN_ORIENTATION     --->      VERSION OF 08/DEC/2011
C     SUBROUTINE UPDATE_CRSS_DD     -->    VERSION 29/JUNE/2011
C     SUBROUTINE UPDATE_CRSS_DD_CE2      -->      VERSION 30/Nov/2011
C     SUBROUTINE UPDATE_CRSS_MTS      --->      VERSION OF 16/NOV/2010
C     SUBROUTINE UPDATE_CRSS_VOCE     --->      VERSION OF 21/NOV/2010
C     SUBROUTINE UPDATE_FIJ         --->      VERSION OF 11/JAN/2009
C     SUBROUTINE UPDATE_SHAPE         --->      VERSION 11/JAN/2009
C     SUBROUTINE UPDATE_ORIENTATION   --->      VERSION 11/JAN/2009
C     SUBROUTINE UPDATE_SCHMID
C     SUBROUTINE UPDATE_TWINNING      --->      VERSION 23/NOV/2010
C     SUBROUTINE VAR_VEL_GRAD         --->      VERSION 03/JAN/2009
C     SUBROUTINE VOIGT   ---->   VERSION OF 09/02/98
C     SUBROUTINE VPSC     --->      VERSION 12/DEC/2011
C     SUBROUTINE VPSC_INPUT      --->      VERSION 01/DEC/2011
C     SUBROUTINE WRITE_ACTIV       --->      VERSION 24/jul/02
C     SUBROUTINE WRITE_STAT      --->      VERSION 05/OCT/99
C     SUBROUTINE WRITE_STRESS_STRAIN (ISTEP)
C     SUBROUTINE WRITE_TEXTURE      --->     VERSION 10/JAN/2009
C     SUBROUTINE WRITE_TEXTURE_FE      --->     VERSION 23/MAR/07
C
C     FUNCTIONS:
C
C     FUNCTION DET(A)
C     FUNCTION VNORM       ---->   VERSION 23/NOV/2011
C     FUNCTION TNORM5x5    ---->   VERSION 23/NOV/2011
C     FUNCTION TNORM6x6    ---->   VERSION 23/NOV/2011
C     FUNCTION VMISMATCH   ---->   VERSION 23/NOV/2011
C     FUNCTION TMISMATCH5x5   ---->   VERSION 23/NOV/2011
C     FUNCTION TMISMATCH6x6   ---->   VERSION 23/NOV/2011
C
C     FLUCTUATIONS AND SECOND-ORDER SUBROUTINES:
C
C     SUBROUTINE FLUCTUATIONS
C     SUBROUTINE LINSOLVER25
C     SUBROUTINE GET_THEFLU
C     SUBROUTINE SOP
C     SUBROUTINE SOMOD
C     SUBROUTINE SDPX
C     SUBROUTINE GRAIN_STRESS_ALT
C     SUBROUTINE EXTRAPOLSO
C     SUBROUTINE VOIGT10
C     SUBROUTINE GET_GAMDOT
C
C *******************************************************************

C
C *********************************************************************
C     SUBROUTINE CHECK_VOCE      --->      VERSION 12/JUN/2001
C *********************************************************************
C
C     CHECKS WHETHER VOCE PARAMETERS ARE KOSHER:
C        TAU0>0 , TAU1 >= 0 , THET0 >= THET1 >= 0
C        TAU1=0   CORRESPONDS TO LINEAR HARDENING.
C        THETA0=0 FORCES NO-HARDENING.
C     IF VOCE PARAMETERS ARE NON-KOSHER CHECKS FOR ILL-POSED HARDENING.
C *********************************************************************

      SUBROUTINE CHECK_VOCE (KOUNT,IPH,TAU0X,TAU1X,THET0X,THET1X)

   70 FORMAT(' *** MODE',I3,'   IN PHASE',I3)
   71 FORMAT('     TAU0.LE.0 --> ILL-POSED HARDENING  !!!')
   72 FORMAT('     THETA1<0 --> NON-KOSHER HARDENING MAY GIVE TAU<0')
   73 FORMAT('     TAU1<0  --> NON-KOSHER HARDENING MAY GIVE TAU<0')
   75 FORMAT('     THETA0=0 --> WILL RESET TAU1=THETA1=0')
   76 FORMAT('     |THETA1|.GE.|THETA0| --> NON-KOSHER HARDENING')
   77 FORMAT('     THETA0<0 --> HARDENING DEPENDS ON |THETA0| ANYWAY')

      TINY=1.E-4*TAU0X
      IF(TAU0X.LE.0.0) THEN
        WRITE(*,70) KOUNT,IPH
        WRITE(*,71)
        STOP
      ENDIF
      IF(ABS(THET1X).LE.TINY) THEN
        THET1X=0.
      ELSE IF(THET1X.LT.0.0) THEN
        WRITE(*,70) KOUNT,IPH
        WRITE(*,72)
        write(*,'("1")') 
        read(*,*)
      ENDIF
      IF(TAU1X.LT.0) THEN
        WRITE(*,70) KOUNT,IPH
        WRITE(*,73)
        write(*,'("1")') 
        read(*,*)
      ENDIF
      IF(ABS(THET0X).LE.TINY) THEN
        IF(ABS(TAU1X).LE.TINY) THEN
          TAU1X =0.
          THET0X=THET1X
        ENDIF
        IF(ABS(TAU1X).GT.TINY) THEN
          WRITE(*,70) KOUNT,IPH
          WRITE(*,75)
          write(*,'("1")') 
          read(*,*)
          TAU1X =0.
          THET0X=0.
          THET1X=0.
        ENDIF
      ENDIF
      IF(ABS(TAU1X).LE.TINY) THEN
        TAU1X =0.0
        THET0X=THET1X
      ENDIF
      IF(THET0X.LT.0.0) THEN
        WRITE(*,70) KOUNT,IPH
        WRITE(*,77)
        write(*,'("1")') 
        read(*,*)
        THET0X=ABS(THET0X)
      ENDIF
      IF(TAU1X.NE.0.) THEN
        IF(ABS(THET1X).GE.ABS(THET0X)) THEN
          WRITE(*,70) KOUNT,IPH
          WRITE(*,76)
          write(*,'("1")') 
          read(*,*)
        ENDIF
      ENDIF

      RETURN
      END
C
C ************************************************************************
C     SUBROUTINE CHG_BASIS    --->   VERSION 19/JUL/01
C
C     (modif. 06/FEB/98 - same convention as SELFPOLY - C.N.T.)
C     (modif. 16/JUN/99 - same convention as Maudlin  - C.N.T.)
C     (modif. 10/MAY/01 - KDIM version - R.L.)
C
C     KDIM=5 or 6, FOR DEVIATORIC or DEV+HYDROST TENSORS, RESPECTIVELY.
C     IOPT=0: DEFINES A BASIS OF 6 SECOND ORDER TENSORS B(N).
C     IOPT=1: CALCULATES SECOND ORDER TENSOR 'C2' AS AN EXPANSION IN TERMS
C             OF VECTOR COMPONENTS CE2(KDIM) AND THE BASIS TENSORS B(KDIM).
C     IOPT=2: CALCULATES COMPONENTS OF C2 AS A VECTOR CE2(KDIM).
C     IOPT=3: CALCULATES FOURTH ORDER TENSOR 'C4' AS AN EXPANSION IN TERMS
C             OF MATRIX COMPONENTS CE4(K,K) AND THE BASIS TENSORS B(KDIM).
C     IOPT=4: CALCULATES MATRIX COMPONENTS CE4(K,K) OF TENSOR 'C4'.
C **************************************************************************

      SUBROUTINE CHG_BASIS(CE2,C2,CE4,C4,IOPT,KDIM)

      PARAMETER (SQR2=1.41421356237309)
      PARAMETER (RSQ2=0.70710678118654744)
      PARAMETER (RSQ3=0.57735026918962584)
      PARAMETER (RSQ6=0.40824829046386304)

      DIMENSION CE2(KDIM),C2(3,3),CE4(KDIM,KDIM),C4(3,3,3,3)

C     DIMENSION B(3,3,6)
C     DATA B /RSQ6,0,   0,   0,   RSQ6,0,   0,   0,  -2*RSQ6,
C    #        RSQ2,0,   0,   0,  -RSQ2,0,   0,   0,   0,
C    #        0,   0,   0,   0,   0,   RSQ2,0,   RSQ2,0,
C    #        0,   0,   RSQ2,0,   0,   0,   RSQ2,0,   0,
C    #        0,   RSQ2,0,   RSQ2,0,   0,   0,   0,   0,
C    #        RSQ3,0,   0,   0,   RSQ3,0,   0,   0,   RSQ3/

      COMMON/BASIS/ B(3,3,6)

      IF(IOPT.EQ.0) THEN
C *** CALCULATES BASIS TENSORS B(N)

        DO I=1,3
          DO J=1,3
            DO N=1,6
              B(I,J,N)=0.0
            ENDDO
          ENDDO
        ENDDO

        B(1,1,2)=-RSQ6
        B(2,2,2)=-RSQ6
        B(3,3,2)= 2.D0*RSQ6

        B(1,1,1)=-RSQ2
        B(2,2,1)= RSQ2

        B(2,3,3)=RSQ2
        B(3,2,3)=RSQ2

        B(1,3,4)=RSQ2
        B(3,1,4)=RSQ2

        B(1,2,5)=RSQ2
        B(2,1,5)=RSQ2

        B(1,1,6)=RSQ3
        B(2,2,6)=RSQ3
        B(3,3,6)=RSQ3

      ENDIF

C *** CALCULATES CARTESIAN SECOND ORDER TENSOR FROM b-COMPONENTS VECTOR.
      IF(IOPT.EQ.1) THEN
        DO 40 I=1,3
        DO 40 J=1,3
        C2(I,J)=0.0
        DO 40 N=1,KDIM
   40   C2(I,J)=C2(I,J)+CE2(N)*B(I,J,N)
      ENDIF

C *** CALCULATES KDIMx1 b-COMPONENTS VECTOR FROM SECOND ORDER TENSOR.
      IF(IOPT.EQ.2) THEN
        DO 50 N=1,KDIM
        CE2(N)=0.0
        DO 50 I=1,3
        DO 50 J=1,3
   50   CE2(N)=CE2(N)+C2(I,J)*B(I,J,N)
      ENDIF

C *** CALCULATES FOURTH ORDER TENSOR FROM b-COMPONENTS MATRIX.
      IF(IOPT.EQ.3) THEN
        DO 20 I=1,3
        DO 20 J=1,3
        DO 20 K=1,3
        DO 20 L=1,3
        C4(I,J,K,L)=0.0
        DO 20 N=1,KDIM
        DO 20 M=1,KDIM
   20   C4(I,J,K,L)=C4(I,J,K,L)+CE4(N,M)*B(I,J,N)*B(K,L,M)
      ENDIF

C *** CALCULATES KDIMxKDIM b-COMPONENTS MATRIX FROM FOURTH ORDER TENSOR.
      IF(IOPT.EQ.4) THEN
        DO 30 N=1,KDIM
        DO 30 M=1,KDIM
        CE4(N,M)=0.0
        DO 30 I=1,3
        DO 30 J=1,3
        DO 30 K=1,3
        DO 30 L=1,3
   30   CE4(N,M)=CE4(N,M)+C4(I,J,K,L)*B(I,J,N)*B(K,L,M)
      ENDIF

      RETURN
      END
c
c ***********************************************************************
C     SUBROUTINE CRYSTAL_SYMMETRY   --->   version 09/JAN/2009
c
c *** If IOPTION=1:
c     Reads crystal symmetry 'icrysym' and unit cell parameters.
c     Generates vectors 'cvec(i,n)' of the unit cell.
c     Generates symmetry operators 'h(i,j,nsymop)' for all crystal symmetries.
c *** If IOPTION=2:
c     Reads Miller indices of systems in 3 or 4-index notation 'isn(i)'
c     & 'isb(i)'. Calculates normal & burgers vectors 'sn(i)' & 'sb(i)'
c *** If IOPTION=3:
c     Generates 'nequiv' crystallographically equivalent orientations sneq(i,n)
c     of normal vector sn(i) by applying all the symmetry operations to it.
c     Discards repeated orientations and defines 'nequiv'.
c *** Simmetry parameter ICRYSYM:
c        1: CUBIC
c        2: HEXAGONAL
c        3: TRIGONAL
c        4: TETRAGONAL
c        5: ORTHORHOMBIC
c        6: MONOCLINIC
c        7: TRICLINIC
c ***********************************************************************

      SUBROUTINE CRYSTAL_SYMMETRY (ioption,ur1,icrysym,
     #                             isn,sn,sneq,isb,sb,nequiv)

      dimension h(3,3,24),hx(3,3,6),itag(24)
      dimension isn(4),sn(3),sneq(3,24),isb(4),sb(3)
      dimension cdim(3),cang(3),cvec(3,3)
      integer ur1
      character crysym*5
      save h,nsymop,cvec
      data pi /3.1415926535898/

c ****************************************************************************

      if(ioption.eq.1) then

        read(ur1,*)
        read(ur1,'(a)') crysym
        icrysym=0
        if(crysym.eq.'cubic' .or. crysym.eq.'CUBIC') icrysym=1
        if(crysym.eq.'hexag' .or. crysym.eq.'HEXAG') icrysym=2
        if(crysym.eq.'trigo' .or. crysym.eq.'TRIGO') icrysym=3
        if(crysym.eq.'tetra' .or. crysym.eq.'TETRA') icrysym=4
        if(crysym.eq.'ortho' .or. crysym.eq.'ORTHO') icrysym=5
        if(crysym.eq.'monoc' .or. crysym.eq.'MONOC') icrysym=6
        if(crysym.eq.'tricl' .or. crysym.eq.'TRICL') icrysym=7
        if(icrysym.eq.0) then
          write(*,*) ' *** CANNOT RECOGNIZE THE CRYSTAL SYMMETRY'
          stop
        endif

        READ(UR1,*) (CDIM(i),i=1,3),(CANG(i),i=1,3)
        DO I=1,3
          CANG(I)=CANG(I)*PI/180.
        ENDDO

c *** assumes 'c' coincident with 'z' and 'a' in the plane 'xz'
        CVEC(1,1)=SIN(CANG(2))
        CVEC(2,1)=0.
        CVEC(3,1)=COS(CANG(2))
        CVEC(1,2)=(COS(CANG(3))-COS(CANG(1))*COS(CANG(2)))/SIN(CANG(2))
        CVEC(3,2)=COS(CANG(1))
        CVEC(2,2)=SQRT(1.-CVEC(1,2)**2-CVEC(3,2)**2)
        CVEC(1,3)=0.
        CVEC(2,3)=0.
        CVEC(3,3)=1.

        DO J=1,3
        DO I=1,3
          CVEC(I,J)=CDIM(J)*CVEC(I,J)
        ENDDO
        ENDDO

        DO I=1,3
        DO J=1,3
          DO M=1,6
            HX(I,J,M)=0.d0
          ENDDO
          DO N=1,24
            H(I,J,N)=0.d0
          ENDDO
        ENDDO
        ENDDO

c *** identity operation ---> triclinic & all symmetries
      do i=1,3
        h(i,i,1)=1.d0
      enddo
      nsymop=1

c *** 180 deg rotation around (001) ---> orthorhombic, monoclinic
      if(icrysym.eq.5 .or. icrysym.eq.6) then
        h(1,1,2)= cos(pi)
        h(2,2,2)= cos(pi)
        h(3,3,2)= 1.d0
        h(1,2,2)=-sin(pi)
        h(2,1,2)= sin(pi)
        nsymop=2
      endif

c *** x-mirror & y-mirror ---> orthorhombic
      if(icrysym.eq.5) then
        h(1,1,3)=-1.d0
        h(2,2,3)= 1.d0
        h(3,3,3)= 1.d0

        h(1,1,4)= 1.d0
        h(2,2,4)=-1.d0
        h(3,3,4)= 1.d0
        nsymop=4
      endif

c *** cubic symmetry
      if(icrysym.eq.1) then

c *** rotations of (pi/3) & (2*pi/3) around <111>
        hx(1,3,1)= 1.d0
        hx(2,1,1)= 1.d0
        hx(3,2,1)= 1.d0

        hx(1,2,2)= 1.d0
        hx(2,3,2)= 1.d0
        hx(3,1,2)= 1.d0

        do m=1,2
          do n=1,nsymop
            mn=m*nsymop+n
            do i=1,3
            do j=1,3
            do k=1,3
              h(i,j,mn)=h(i,j,mn)+hx(i,k,m)*h(k,j,n)
            enddo
            enddo
            enddo
          enddo
        enddo
        nsymop=mn

c *** mirror across the plane (110)
        hx(1,2,3)= 1.d0
        hx(2,1,3)= 1.d0
        hx(3,3,3)= 1.d0

        do n=1,nsymop
          mn=nsymop+n
            do i=1,3
            do j=1,3
            do k=1,3
              h(i,j,mn)=h(i,j,mn)+hx(i,k,3)*h(k,j,n)
            enddo
            enddo
            enddo
        enddo
        nsymop=mn

c *** rotations of 90, 180, 270 around x3

        do m=1,3
          ang=pi/2.*float(m)
          hx(1,1,m)= cos(ang)
          hx(2,2,m)= cos(ang)
          hx(3,3,m)= 1.0
          hx(1,2,m)=-sin(ang)
          hx(2,1,m)= sin(ang)
          hx(1,3,m)= 0.0
          hx(3,1,m)= 0.0
          hx(2,3,m)= 0.0
          hx(3,2,m)= 0.0
        enddo

        do m=1,3
          do n=1,nsymop
            mn=m*nsymop+n
              do i=1,3
              do j=1,3
              do k=1,3
                h(i,j,mn)=h(i,j,mn)+hx(i,k,m)*h(k,j,n)
              enddo
              enddo
              enddo
          enddo
        enddo
        nsymop=mn

      endif                    !end of condition for icrysym=1

c *** hexagonal, trigonal and tetragonal symmetry

      if(icrysym.ge.2 .and. icrysym.le.4) then
        if(icrysym.eq.2) nrot=6
        if(icrysym.eq.3) nrot=3
        if(icrysym.eq.4) nrot=4

c *** mirror plane at 30 deg or 60 deg or 45 deg with respect to x1
        ang=pi/float(nrot)
        h(1,1,2)= cos(ang)**2-sin(ang)**2
        h(2,2,2)=-h(1,1,2)
        h(3,3,2)= 1.d0
        h(1,2,2)= 2.*cos(ang)*sin(ang)
        h(2,1,2)= h(1,2,2)
        nsymop=2

c *** rotations of 2*pi/6 around axis <001> for hexagonals.
c *** rotations of 2*pi/3 around axis <001> for trigonals.
c *** rotations of 2*pi/4 around axis <001> for tetragonals.
        do nr=1,nrot-1
          ang=nr*2.*pi/nrot
          hx(1,1,nr)= cos(ang)
          hx(2,2,nr)= cos(ang)
          hx(3,3,nr)= 1.d0
          hx(1,2,nr)=-sin(ang)
          hx(2,1,nr)= sin(ang)
        enddo

        do m=1,nrot-1
          do n=1,nsymop
            mn=m*nsymop+n
            do i=1,3
            do j=1,3
            do k=1,3
              h(i,j,mn)=h(i,j,mn)+hx(i,k,m)*h(k,j,n)
            enddo
            enddo
            enddo
          enddo
        enddo
        nsymop=mn

      endif               !end of condition for icrysym= 2,3,4

c     write(10,*)
c     write(10,'(''  # of symmetry operations='',i4)') nsymop
c     write(10,'(''  symmetry matrices'')')
c     write(10,'(i3,9f7.3)') (n,((h(i,j,n),j=1,3),i=1,3),n=1,nsymop)

      endif               !end of condition for ioption=1

c **************************************************************************
c   Converts Miller-Bravais indices of plane normal and slip direction
c   into normalized vectors sn(i) and sb(i), respectively.
c   Indices for cubic (1), tetragonal (4), orthorhombic (5), monoclinic (6)
c   & triclinic (7) systems are in 3-index notation.
c   For hexagonal (2) & trigonal (3) systems uses 4-index notation.
c **************************************************************************

      if (ioption.eq.2) then

        if(icrysym.eq.2 .or. icrysym.eq.3) then
          isn(3)=isn(4)
          isb(1)=isb(1)-isb(3)
          isb(2)=isb(2)-isb(3)
          isb(3)=isb(4)
        endif

c *** assumes 'c' coincident with 'z' and 'a' in the plane 'xz'
        sn(3)= isn(3)/cvec(3,3)
        sn(1)=(isn(1)-cvec(3,1)*sn(3))/cvec(1,1)
        sn(2)=(isn(2)-cvec(1,2)*sn(1)-cvec(3,2)*sn(3))/cvec(2,2)

        snnor=sqrt(sn(1)**2+sn(2)**2+sn(3)**2)
        do j=1,3
          sn(j)=sn(j)/snnor
          if(abs(sn(j)).lt.1.e-03) sn(j)=0.
        enddo

c *** this block specific for EPSC & VPSC

        do i=1,3
          sb(i)=isb(1)*cvec(i,1)+isb(2)*cvec(i,2)+isb(3)*cvec(i,3)
        enddo
        sbnor=sqrt(sb(1)**2+sb(2)**2+sb(3)**2)
        do j=1,3
          sb(j)=sb(j)/sbnor
          if(abs(sb(j)).lt.1.e-03) sb(j)=0.
        enddo

      endif      ! end of if(ioption.eq.2)

c **************************************************************************
c *** generates all symmetry related vectors sneq(i,n) with z>0.
c *** eliminates redundant poles: coincidents and opposites
c **************************************************************************

      if(ioption.eq.3) then

        do n=1,nsymop
          itag(n)=0
          do i=1,3
          sneq(i,n)=0.d0
            do j=1,3
              sneq(i,n)=sneq(i,n)+h(i,j,n)*sn(j)
            enddo
          enddo
        enddo

        if(icrysym.ne.7) then      ! nsymop=1 for trigonal
          do m=1,nsymop-1
            if(itag(m).eq.0) then
              do n=m+1,nsymop
                sndif=abs(sneq(1,m)-sneq(1,n))+abs(sneq(2,m)-sneq(2,n))
     #               +abs(sneq(3,m)-sneq(3,n))
                if(sndif .le. 0.0001) itag(n)=1
                sndif=abs(sneq(1,m)+sneq(1,n))+abs(sneq(2,m)+sneq(2,n))
     #               +abs(sneq(3,m)+sneq(3,n))
                if(sndif .le. 0.0001) itag(n)=1
              enddo
            endif
          enddo
        endif

        nequiv=0
        do n=1,nsymop
          if(itag(n).eq.0) then
            nequiv=nequiv+1
            isign=1
            if(sneq(3,n).lt.0.) isign=-1
            sneq(1,nequiv)=isign*sneq(1,n)
            sneq(2,nequiv)=isign*sneq(2,n)
            sneq(3,nequiv)=isign*sneq(3,n)
          endif
        enddo

      endif            !end of if(ioption=3)
c **************************************************************************

      return
      end

CFEB
C ***************************************************************************
C     SUBROUTINE CUBCOMP      --->      VERSION 19/SET/00
C
C     ASSIGNS ORIENTATIONS TO ONE OF THE IDEAL FCC ROLLING COMPONENTS:
C     (CUBE/rotated CUBE/GOSS/BRASS/COPPER/S/other).
C     WORKS FOR MULTIPHASE BUT ALL PHASES HAVE TO BE FCC FOR THE RESULTS
C     TO MAKE SENSE.
C ***************************************************************************

      SUBROUTINE CUBCOMP (ISTEP,IOPTION)

      INCLUDE 'vpsc7.dim'

      CHARACTER*3 IDLABEL
      COMMON/CUCO/widmod(0:6),igrtype(NGRMX),idlabel(0:6)

      PARAMETER (NIDORMX=300)
      PARAMETER (NIDMODMX=6)

      dimension dmin(NGRMX)
      dimension aa(3,3),amis(3,3)
      dimension pidmod(0:NIDMODMX)

      COMMON/cub/aidort(3,3,NIDORMX),itype(NIDORMX),nidmod,
     #           normod(NIDMODMX),nor

C **********************************************************************
C     READS ORIENTATION MATRICES OF IDEAL COMPONENTS ALREADY TRANSPOSED
C **********************************************************************

      IF(IOPTION.EQ.0) THEN

        read(UR5,*) nidmod
        idlabel(0)='OTH'
        nor=0
        do im=1,nidmod
          read(UR5,*) normod(im)
          read(UR5,'(a3)') idlabel(im)
          do j=1,normod(im)
            nor=nor+1
            do j1=1,3
              read(UR5,*) (aidort(i1,j1,nor),i1=1,3)
            enddo
            itype(nor)=im
          enddo
        enddo

        RETURN
      ENDIF

C **********************************************************************
C     IDENTIFIES ORIENTATIONS IN EACH PHASE WITH ONE OF THE IDEAL
C     COMPONENTS AND ACCUMULATES
C **********************************************************************

      DO IPH=IPHBOT,IPHTOP

      totwgt=0.
      dminav=0.
      do im=0,nidmod
        widmod(im)=0.
      enddo

      DO KKK=ngr(iph-1)+1,ngr(iph)
      totwgt=totwgt+wgt(kkk)

       do i=1,3
       do j=1,3
         aa(i,j)=ag(i,j,kkk)
       enddo
       enddo

      if(aa(3,3).lt.0.) then
        do i=2,3
        do j=1,3
          aa(i,j)=-aa(i,j)
        enddo
        enddo
      endif

      dmin(kkk)=500.
      do ior=1,nor

        do i=1,3
        do j=1,3
          amis(i,j)=0.
          do k=1,3
            amis(i,j)=amis(i,j)+aidort(i,k,ior)*aa(k,j)
          enddo
        enddo
        enddo

        trace=(amis(1,1)+amis(2,2)+amis(3,3))
        arg=(trace-1)/2.
        if(arg.gt.1) arg=1.
        if(arg.lt.-1) arg=-1.
        angmis=acos(arg)

        if(abs(angmis).lt.dmin(kkk)) then
          dmin(kkk)=abs(angmis)
          igrtype(kkk)=itype(ior)
        endif

      enddo

      if(dmin(kkk).gt.(15.*pi/180.)) igrtype(kkk)=0
      dminav=dminav+dmin(kkk)*wgt(kkk)
      widmod(igrtype(kkk))=widmod(igrtype(kkk))+wgt(kkk)

      enddo    ! end of loop over grains in the phase

      dminav=(dminav/totwgt)*(180./pi)

      do im=0,nidmod
        pidmod(im)=widmod(im)*100./totwgt
      enddo

      IUNIT=60+IPH
      IF(ISTEP.EQ.0) WRITE(IUNIT,'(13a7)')
     #               '    EPS',(idlabel(im),im=0,nidmod),' AVMISO'
      WRITE(IUNIT,'(f7.4,12(2x,f5.1))')
     #               EPSACU,(PIDMOD(IM),IM=0,NIDMOD),DMINAV

      enddo      ! end of loop over all the phases

      end
CFEE

C *****************************************************************************
C     SUBROUTINE DATA_CRYSTAL       --->     VERSION 14/FEB/2011
C *****************************************************************************

      SUBROUTINE DATA_CRYSTAL (IPH)

      INCLUDE 'vpsc7.dim'

      DIMENSION MODE(50)
      DATA MODE/50*0/
      DIMENSION ISN(4),SN(3),SNEQ(3,24),ISB(4),SB(3)
      DIMENSION AUX5(5),AUX33(3,3),AUX55(5,5),AUX3333(3,3,3,3)

CFEB
C -----------------------------------------------------------------
C     WRITES CRYSTAL DATA FILE INTO 'RUN_LOG.OUT' FILE
      WRITE(10,*)
      WRITE(10,'('' **** CRYSTAL DATA FILE ****'')')
      DO IDUM=1,200
        READ(UNIT=UR1,END=99,FMT='(A)') PROSA
        WRITE(10,'(A)') PROSA
      ENDDO
   99 REWIND UR1
      WRITE(10,'(''**** END OF CRYSTAL DATA FILE ****'')')
      WRITE(10,*)
C -----------------------------------------------------------------
CFEE

C *** READS CRYSTAL SYMMETRY & UNIT CELL PARAMETERS. CALCULATES CELL VECTORS.
C *** GENERATES ALL SYMMETRY OPERATIONS ASSOCIATED WITH 'CRYSYM'.

      CALL CRYSTAL_SYMMETRY (1,UR1,ICRYSYM,ISN,SN,SNEQ,ISB,SB,NPOLES)
      NIND=3
      IF(ICRYSYM.EQ.2 .OR. ICRYSYM.EQ.3) NIND=4

C *** READS SINGLE CRYSTAL ELASTIC STIFFNESS
      READ(UR1,'(A)') PROSA
      READ(UR1,*)     ((C2CA(I,J,IPH),J=1,6),I=1,6)
C *** READS SINGLE CRYSTAL THERMAL EXPANSION COEFFICIENTS
      READ(UR1,'(A)') PROSA
      READ(UR1,'(A)') PROSA

C *** ESTIMATES ELASTIC BULK AND COMPRESSIBILITY MODULI (PROVISORY)
C     ALF=(C2CA(1,1,IPH)+C2CA(2,2,IPH)+C2CA(3,3,IPH))/3.
C     BET=(C2CA(1,2,IPH)+C2CA(1,3,IPH)+C2CA(2,3,IPH))/3.
C     BULK=(3.*ALF+6.*BET)/9.

C *** READS INFORMATION ABOUT SLIP AND TWINNING SYSTEMS
      READ(UR1,'(A)') PROSA
      READ(UR1,*)     NMODESX
      READ(UR1,*)     NMODES(IPH)
      READ(UR1,*)     (MODE(I),I=1,NMODES(IPH))

      IF(NMODES(IPH).GT.NMODMX) THEN
        WRITE(*,'('' NMODES IN PHASE'',I3,'' IS'',I3)') IPH,NMODES(IPH)
        WRITE(*,'('' CHANGE PARAMETER NMODMX IN VPSC.DIM'')')
        STOP
      ENDIF

      ICS=1       ! ICS=1 --> centro_symmetric SCYS
      NSLMOD(iph)=0
      NTWMOD(iph)=0
      NSYST(iph) =0
      NSLSYS(iph)=0
      NTWSYS(iph)=0
      MCOUNT=1    ! counter for the number of modes

C *** READS DEFORMATION MODES AND ASSOCIATED PARAMETERS FROM FILECRYS

      DO 100 MLOOP=1,NMODESX

        READ(UR1,'(a)') PROSA
        READ(UR1,*)     MODEX,NSMX,ISENSEX,ITWTYPEX
        IF(MODEX.NE.MLOOP) THEN
          WRITE(*,*) ' WARNING !!!'
          WRITE(*,*) ' MODE NUMBERS MUST BE SEQUENTIAL IN CRYSTAL FILE'
          STOP
        ENDIF
        IF(ITWTYPEX.NE.0) THEN
          IF(ISENSEX.EQ.1) THEN
            WRITE(*,*) ' WARNING: ISENSEX HAS TO BE 0 FOR TWIN SYSTEMS'
            STOP
          ENDIF
          READ(UR1,*) TWSHX
        ENDIF

c       write(10,'(''mloop,mcount,mode(mcount)'',3i5)')
c    #                     mloop,mcount,mode(mcount)

C *** SKIPS MODE IF IT IS NOT IN THE LIST
        IF(MLOOP.NE.MODE(MCOUNT)) THEN
          DO IS=1,NSMX
            READ(UR1,*)
          ENDDO
          GO TO 100
        ENDIF

        IF(ISENSEX.EQ.0) ICS=0      ! ICS=0 --> non-centro-sym SCYS

        NSM(MCOUNT,IPH)=NSMX

C *** VERIFICATION OF TWINNING DATA TO BE SURE PROGRAM WILL RUN PROPERLY

        IF(ITWTYPEX.EQ.0. .AND. NTWMOD(IPH).NE.0) THEN
          WRITE(*,'(''  SLIP MODE'',I4,''  IN PHASE'',I4)') MLOOP,IPH
          WRITE(*,*) '  SLIP MODES MUST PRECEDE TWIN MODES'
          WRITE(*,*) '  -->   REORDER CRYSTAL FILE'
          STOP
        ENDIF

        NSYST(IPH)=NSYST(IPH)+NSMX
        IF(ITWTYPEX.EQ.0) THEN
          NSLMOD(IPH)=NSLMOD(IPH)+1
          NSLSYS(IPH)=NSLSYS(IPH)+NSMX
        ELSE IF(ITWTYPEX.NE.0) THEN
          NTWMOD(IPH)=NTWMOD(IPH)+1
          NTWSYS(IPH)=NTWSYS(IPH)+NSMX
          TWSH(NTWMOD(IPH),IPH) =TWSHX
        ENDIF

c     write(10,'(''nsyst(iph),nslsys(iph),ntwsys(iph)'',3i5)')
c    #             nsyst(iph),nslsys(iph),ntwsys(iph)

        IF(NSYST(IPH).GT.NSYSMX) THEN
          WRITE(*,'('' NSYST IN PHASE'',I3,'' IS'',I3)') IPH,NSYST(IPH)
          WRITE(*,'('' --> CHANGE PARAMETER NSYSMX IN VPSC.DIM'')')
          STOP
        ENDIF

        IF(NTWMOD(IPH).GT.NTWMMX) THEN
          WRITE(*,'('' NTWMOD IN PHASE'',I3,'' IS'',I3)')
     #                 IPH,NTWMOD(IPH)
          WRITE(*,'('' --> CHANGE PARAMETER NTWMMX IN VPSC.DIM'')')
          STOP
        ENDIF

        IF(NTWSYS(IPH).GT.NTWSMX) THEN
          WRITE(*,'('' NTWSYS IN PHASE'',I3,'' IS'',I3)') IPH,
     #                 NTWSYS(IPH)
          WRITE(*,'('' --> CHANGE PARAMETER NTWSMX IN VPSC.DIM'')')
          STOP
        ENDIF

      ISBOT=NSYST(IPH)-NSMX+1
      ISTOP=NSYST(IPH)
      DO 200 ISYS=ISBOT,ISTOP

        ISENSE (ISYS,IPH)=ISENSEX
        ITWTYPE(ISYS,IPH)=ITWTYPEX

C *** READS MILLER INDICES AND CALCULATES CARTESIAN COMPONENTS OF NORMAL
C *** (SN) AND SHEAR (SB) VECTORS OF SLIP OR TWIN SYSTEMS.
C *** CALCULATES SCHMID TENSORS IN CRYSTAL AXES 'SCHCA' FOR EACH SYSTEM.

        READ(UR1,*) (ISN(I),I=1,NIND),(ISB(I),I=1,NIND)

        CALL CRYSTAL_SYMMETRY (2,UR1,ICRYSYM,ISN,SN,SNEQ,ISB,SB,NPOLES)

        PROD=SN(1)*SB(1)+SN(2)*SB(2)+SN(3)*SB(3)
        IF(PROD.GE.1.E-4) THEN
          WRITE(*,'('' SYSTEM IS NOT ORTHOGONAL !!'')')
          WRITE(*,'('' ISN='',4I7)') (ISN(J),J=1,NIND)
          WRITE(*,'('' ISB='',4I7)') (ISB(J),J=1,NIND)
          WRITE(*,'(''   N='',3F7.3)') (SN(J),J=1,3)
          WRITE(*,'(''   B='',3F7.3)') (SB(J),J=1,3)
          STOP
        ENDIF

        DO I=1,3
          DNCA(I,ISYS,IPH)=SN(I)
          DBCA(I,ISYS,IPH)=SB(I)
          DO J=1,3
            AUX33(I,J)=0.5*(SB(I)*SN(J)+SB(J)*SN(I))
          ENDDO
        ENDDO
        CALL CHG_BASIS(AUX5,AUX33,AUX55,AUX3333,2,5)
        DO I=1,5
          SCHCA(I,ISYS,IPH)=AUX5(I)
        ENDDO

  200 CONTINUE    ! END OF LOOP OVER DEFORMATION MODES

      MCOUNT=MCOUNT+1

  100 CONTINUE    ! END OF LOOP OVER ALL MODES IN PHASE 'IPH'

C *** CHECKS WHETHER THE SINGLE CRYSTAL YIELD SURFACE IS OPEN

      DO ICOMP=1,5
        ICLOSEPOS=0
        ICLOSENEG=0
        DO NS=1,NSLSYS(IPH)
          IF(ABS(SCHCA(ICOMP,NS,IPH)).GT.1.E-3) THEN
            ICLOSEPOS=1
            ICLOSENEG=1
          ENDIF
        ENDDO
        IF(NTWSYS(IPH).NE.0) THEN
          DO NS=NSLSYS(IPH)+1,NSYST(IPH)
            IF(SCHCA(ICOMP,NS,IPH).GT. 1.E-3) ICLOSEPOS=1
            IF(SCHCA(ICOMP,NS,IPH).LT.-1.E-3) ICLOSENEG=1
          ENDDO
        ENDIF
        IF(ICLOSEPOS.NE.1 .OR. ICLOSENEG.NE.1) THEN
          WRITE(*,'('' WARNING ! THE SCYS IS OPEN FOR PHASE'',I5,
     #              '' ALONG DIRECTION'',I5)') IPH,ICOMP
          write(*,'("1")') 
        read(*,*)
        ENDIF
      ENDDO

CFEB
      WRITE(10,*)
      I=0
      DO IM=1,NMODES(IPH)
        WRITE(10,'(''  N & B FOR MODE'',I3,'' IN PHASE'',I3)') IM,IPH
        DO IS=1,NSM(IM,IPH)
          I=I+1
          WRITE(10,'(3F10.3,3X,3F10.3)') (DNCA(J,I,IPH),J=1,3),
     #                                   (DBCA(J,I,IPH),J=1,3)
        ENDDO
      ENDDO

C     WRITE(10,*)
C     WRITE(10,'(''  HARDENING MATRIX FOR PHASE'',I3)') IPH
C     DO IS=1,NSYST(IPH)
C       WRITE(10,'(24F5.1)') (HARD(IS,JS,IPH),JS=1,NSYST(IPH))
C     ENDDO
CFEE

      RETURN
      END
C
C *****************************************************************************
C     SUBROUTINE DATA_GRAIN        --->      VERSION 10/sep/2004
C *****************************************************************************

      SUBROUTINE DATA_GRAIN (IPH)

      INCLUDE 'vpsc7.dim'

      DIMENSION AA(3,3),FIJX(3,3),FNEW(3,3),EULANG(3)
      CHARACTER NOMEN*1
CFEB
      DIMENSION AX(3)
CFEE
      READ(UR2,'(a)') PROSA
      READ(UR2,'(a)') PROSA
      READ(UR2,'(a)') PROSA
      READ(UR2,  *  ) NOMEN,NGRAIN

      NGR(IPH)=NGR(IPH-1)+NGRAIN
      if(ngr(iph).gt.ngrmx) then
        write(*,'('' number of grains exceeds dimension !!'')')
        write(*,'('' --> increase parameter NGRMX to'',i7)') ngr(iph)
        stop
      endif

C ***************************************************************************
C     READS EULER ANGLES, CONVERTS TO BUNGE NOTATION, CALCULATES ROT MATRIX

      TOTWGT=0.
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        READ(UR2,*) (EULANG(I),I=1,3),WGT(KKK)
        TOTWGT=TOTWGT+WGT(KKK)
        if(nomen.eq.'B' .or. nomen.eq.'b') then
          eul1=  eulang(1)
          eul2=  eulang(2)
          eul3=  eulang(3)
        else if(nomen.eq.'K' .or. nomen.eq.'k') then
          eul1= (eulang(1)-90.)
          eul2= -eulang(2)
          eul3=(-eulang(3)-90.)
        else if(nomen.eq.'R' .or. nomen.eq.'r') then
          eul1= (eulang(1)+90.)
          eul2=  eulang(2)           ! fixed 29/apr/02
          eul3= (eulang(3)-90.)
        else
          write(*,'(/,'' CANNOT IDENTIFY EULER ANGLE CONVENTION  !!'')')
          stop
        endif

C ***********************************************************************
C *** OPTIONAL: RANDOM PERTURBATION OF EULER ANGLES BY +/- 'randrange'
c       if(KKK.EQ.NGR(IPH-1)+1)
c     #          print *, ' RANDOM SHIFT OF EULER ANGLES ACTIVATED  !!'
c        randrange= 2.
c       eul1= eul1+ (2.*ran2(jran)-1.)*randrange
c       eul2= eul2+ (2.*ran2(jran)-1.)*randrange
c       eul3= eul3+ (2.*ran2(jran)-1.)*randrange
C ***********************************************************************

C     CALCULATES THE TRANSFORMATION MATRIX AA WHICH TRANSFORMS FROM
C     SAMPLE TO CRYSTAL. STORES AG, WHICH TRANSFORMS FROM CRYSTAL TO SAMPLE.

        CALL EULER(2,EUL1,EUL2,EUL3,AA)
        DO J=1,3
        DO K=1,3
          AG(J,K,KKK)=AA(K,J)
        ENDDO
        ENDDO

      ENDDO     ! END OF LOOP OVER GRAINS IN EACH PHASE

C     DOUBLE RENORMALIZATION OF WEIGHTS: FIRST NORMALIZE THE WEIGHTS WITHIN
C     EACH PHASE, NEXT RENORMALIZE TO THE VOLUME FRACTION OF THE PHASE.

      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        WGT(KKK)=WGT(KKK)/TOTWGT*WPH(IPH)
      ENDDO

C ***************************************************************************
C     INITIAL F TENSOR AND EIGENVECTORS:

C     * IF ISHAPE=0 ASSUMES SAME INITIAL SHAPE (axisph) AND ORIENTATION
C       (eulerph) FOR ALL THE GRAINS IN THE PHASE.
C       CALCULATES ESHELBY TENSOR WITH THE AVERAGE GRAIN SHAPE AND DOES
C       NOT KEEP TRACK OF LOCAL GRAIN SHAPE.
C
C     * IF ISHAPE=1 ASSUMES SAME INITIAL SHAPE (axisph) AND ORIENTATION
C       (eulerph) FOR ALL THE GRAINS IN THE PHASE.
C       CALCULATES ESHELBY TENSOR WITH THE AVERAGE GRAIN SHAPE AND KEEPS
C       TRACK OF LOCAL GRAIN SHAPE.
c
C     * IF ISHAPE=2 ASSUMES SAME INITIAL SHAPE (axisph) AND ORIENTATION
C       (eulerph) FOR ALL THE GRAINS IN THE PHASE.
C       CALCULATES ESHELBY TENSOR WITH THE INDIVIDUAL GRAIN SHAPE AND
C       KEEPS TRACK OF LOCAL GRAIN SHAPE.
C
C     * IF ISHAPE=3 READS INDIVIDUAL INITIAL GRAIN AXES ORIENTATION
c       FROM fileaxes (da,db,dc), ASSUMES SAME SHAPE (axisph) FOR ALL
c       THE GRAINS IN THE PHASE.
C       CALCULATES ESHELBY TENSOR WITH THE INDIVIDUAL GRAIN SHAPE AND
C       KEEPS TRACK OF LOCAL GRAIN SHAPE.
C
C     * IF ISHAPE=4 READS INDIVIDUAL INITIAL GRAIN AXES ORIENTATION
C       AND SHAPE FROM fileaxes (da,db,dc,ax(1),ax(2),ax(3)).
C       CALCULATES ESHELBY TENSOR WITH INDIVIDUAL GRAIN SHAPES AND
C       KEEPS TRACK OF LOCAL GRAIN SHAPE

C       'eulerph' ANGLES OF (G) WRT (S).
C       'aa'    TRANSFORMS FROM (S) TO (G)
C       'fijx'  COLUMNS ARE GRAIN AXES EXPRESSED IN GRAIN SYSTEM
C       'fnew'  COLUMNS ARE GRAIN AXES EXPRESSED IN SAMPLE SYSTEM

      da=eulerph(1,iph)
      db=eulerph(2,iph)
      dc=eulerph(3,iph)

      call euler(2,da,db,dc,aa)

      do i=1,3
      do j=1,3
        fijx(i,j)=(i/j)*(j/i)*AXISPH(0,I,IPH)
      enddo
      enddo

      do j=1,3
      do i=1,3
        fnew(i,j)=0.
        do m=1,3
          fnew(i,j)=fnew(i,j)+aa(m,i)*fijx(m,j)
        enddo
      enddo
      enddo

      do i=1,3
      do j=1,3
        fijph(i,j,iph)=fnew(i,j)
      enddo
      enddo
CFEB
      if(ishape(iph).eq.1 .or. ishape(iph).eq.2) then
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          DO I=1,3
          DO J=1,3
            FIJGR(I,J,KKK)=FNEW(I,J)
          ENDDO
          ENDDO
        ENDDO
      endif


      IF(ISHAPE(IPH).GE.3) THEN

C     ISHAPE=3 -> READ EULER ANGLES OF THE ELLIPSOID WITH RESPECT TO SAMPLE
C                 AND ASSUME SAME ASPECT RATIOS 'AXISPH' FOR EVERY ELLIPSOID.
C     ISHAPE=4 -> READ EULER ANGLES & ASPECT RATIOS OF EACH ELLIPSOID.
C     DA,DB,DC -> EULER ANGLES OF ELLIPSOID AXES WRT SAMPLE.

        READ(UR3,'(A)') PROSA
        READ(UR3,'(A)') PROSA
        READ(UR3,'(A)') PROSA
        READ(UR3,'(A)') PROSA

        DO KKK=ngr(iph-1)+1,ngr(iph)

          if(ishape(iph).eq.3) then
            READ(UR3,*) da,db,dc
            do i=1,3
            do j=1,3
              fijgr(i,j,KKK)=(i/j)*(j/i)*AXISPH(0,I,IPH)
            enddo
            enddo
          else if (ishape(iph).eq.4) then
            READ(UR3,*) da,db,dc,ax(1),ax(2),ax(3)
            do i=1,3
            do j=1,3
              fijgr(i,j,KKK)=(i/j)*(j/i)*ax(i)
            enddo
            enddo
          endif

          call euler(2,da,db,dc,aa)

C     AA TRANSFORMS FROM SAMPLE TO GRAIN AXES. AAt FROM GRAIN TO SAMPLE.

          do j=1,3
          do i=1,3
            fnew(i,j)=0.
            do m=1,3
              fnew(i,j)=fnew(i,j)+aa(m,i)*fijgr(m,j,kkk)
            enddo
          enddo
          enddo

          do i=1,3
          do j=1,3
            fijgr(i,j,KKK)=fnew(i,j)
          enddo
          enddo

        ENDDO      ! END OF LOOP OVER GRAINS

      ENDIF      ! END OF CONDITION FOR ISHAPE = 3,4
CFEE
      RETURN
      END
c
c *****************************************************************************
      function det(a)

      dimension a(3,3)

      det=a(1,1)*a(2,2)*a(3,3)
     #   +a(1,2)*a(2,3)*a(3,1)
     #   +a(1,3)*a(2,1)*a(3,2)
     #   -a(1,3)*a(2,2)*a(3,1)
     #   -a(2,3)*a(3,2)*a(1,1)
     #   -a(1,2)*a(2,1)*a(3,3)
      return
      end

C *****************************************************************************
C     SUBROUTINE ELSC      --->      VERSION OF 01/JAN/09
C
C     CALCULATES ITERATIVELY SELF-CONSISTENT ELASTIC MODULI OF POLYCRYSTAL
C         Csc=<Cg:(Cg+C~)^(-1)>:(Csc+C~)  with  C~=Csc:(Esh^(-1)-I)
C     ITERATIVE PROCEDURE USES b-BASIS REPRESENTATION OF TENSORS.
C       IOPTION=0 : USES UPPER BOUND 'CUB' (VOIGT) AS INITIAL GUESS
C       IOPTION=1 : USES PREVIOUS CONVERGED MODULI 'COLD' AS INITIAL GUESS
C *****************************************************************************

      SUBROUTINE ELSC (IOPTION)

      INCLUDE 'vpsc7.dim'

      DIMENSION AUX6(6),AUX33(3,3),AUX66(6,6),AUX3333(3,3,3,3)
      DIMENSION COLD(6,6),CNEW(6,6),CUB(6,6),C2(6,6)
      DIMENSION C4SA(3,3,3,3),C4GAB(3,3,3,3),E4SA(3,3,3,3),E4GA(3,3,3,3)
      DIMENSION AXB(3),EIGB(3,3)
      DIMENSION CTILDE(6,6),AC1(6,6),AC2(6,6),AC(6,6),XID6(6,6)
      SAVE      COLD

      DO I=1,6
      DO J=1,6
        XID6(I,J)=(I/J)*(J/I)
        CUB(I,J) =0.
      ENDDO
      ENDDO

C *** TRANSFORMS SINGLE CRYSTAL STIFFNESS TO SAMPLE AXES.
C *** CALCULATES UPPER BOUND (VOIGT) STIFFNESS 'CUB' FOR THE POLYCRYSTAL.
      KGX=1
      DO IPH=IPHBOT,IPHTOP
        DO I=1,6
        DO J=1,6
          AUX66(I,J)=C2CA(I,J,IPH)
        ENDDO
        ENDDO
        CALL VOIGT(AUX6,AUX33,AUX66,AUX3333,3)

        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          DO I=1,3
          DO J=1,3
          DO K=1,3
          DO L=1,3
            DUMMY=0.
            DO I1=1,3
            DO J1=1,3
            DO K1=1,3
            DO L1=1,3
              DUMMY=DUMMY+AG(I,I1,KKK)*AG(J,J1,KKK)*
     #              AG(K,K1,KKK)*AG(L,L1,KKK)*AUX3333(I1,J1,K1,L1)
            ENDDO
            ENDDO
            ENDDO
            ENDDO
            C4SA(I,J,K,L)=DUMMY
          ENDDO
          ENDDO
          ENDDO
          ENDDO

          CALL CHG_BASIS(AUX6,AUX33,AUX66,C4SA,4,6)

          DO I=1,6
          DO J=1,6
           CGR(I,J,KGX)=AUX66(I,J)
           CUB(I,J)=CUB(I,J)+AUX66(I,J)*WGT(KKK)
          ENDDO
          ENDDO

          KGX=KGX+1
        ENDDO        ! END OF DO KKK
      ENDDO          ! END OF DO IPH

      CALL CHG_BASIS(AUX6,AUX33,CUB,C4SA,3,6)
      CALL VOIGT(AUX6,AUX33,C2,C4SA,4)

CFEB
      WRITE(10,*)
      WRITE(10,'('' UB ELASTIC STIFFNESS (VOIGT NOTATION)'')')
      WRITE(10,'(6F10.2)') ((C2(I,J),J=1,6),I=1,6)
      WRITE(10,*)
CFEE

      IF(IOPTION.EQ.0) THEN
        DO I=1,6
        DO J=1,6
          CSC(I,J)=CUB(I,J)
        ENDDO
        ENDDO
      ELSE IF(IOPTION.EQ.1) THEN
        DO I=1,6
        DO J=1,6
          CSC(I,J)=COLD(I,J)
        ENDDO
        ENDDO
      ENDIF

C *** SELF-CONSISTENT CALCULATION OF THE ELASTIC STIFFNESS
      WRITE(*,*)
      IT=0
      RER=2*1.E-05
      DO WHILE(RER.GT.1.E-05 .AND. IT.LT.ITMAXEXT)

        IT=IT+1
        DO I=1,6
        DO J=1,6
          CNEW(I,J)=0.
        ENDDO
        ENDDO

        CALL CHG_BASIS(AUX6,AUX33,CSC,C4SA,3,6)

        KGX=1
        DO IPH=IPHBOT,IPHTOP

          DO J=1,3
            AXB(J)=AXISPH(0,J,IPH)
            DO I=1,3
              EIGB(I,J)=AXISPH(I,J,IPH)
            ENDDO
          ENDDO

C *** ROTATION OF STIFFNESS 'C4' FROM SAMPLE TO ELLIPSOID AXES
          DO 95 I=1,3
          DO 95 J=1,3
          DO 95 M=1,3
          DO 95 N=1,3
            DUMMY=0.
            DO 90 I1=1,3
            DO 90 J1=1,3
            DO 90 M1=1,3
            DO 90 N1=1,3
              DUMMY=DUMMY+EIGB(I1,I)*EIGB(J1,J)*EIGB(M1,M)
     #             *EIGB(N1,N)*C4SA(I1,J1,M1,N1)
   90       CONTINUE
            C4GAB(I,J,M,N)=DUMMY
   95     CONTINUE

          CALL ESHELBY (AXB,C4GAB,0.,E4GA,AUX3333,AUX33,AUX33,
     #                 PDIL,AUX3333,AUX3333,1)

C *** ROTATES THE ESHELBY TENSOR FOR THE PHASE BACK INTO SAMPLE AXES.
          DO 130 I=1,3
          DO 130 J=1,3
          DO 130 M=1,3
          DO 130 N=1,3
            DUMMYE=0.
            DO 120 I1=1,3
            DO 120 J1=1,3
            DO 120 M1=1,3
            DO 120 N1=1,3
              DUMMYE=DUMMYE+EIGB(I,I1)*EIGB(J,J1)*EIGB(M,M1)
     #              *EIGB(N,N1)*E4GA(I1,J1,M1,N1)
  120       CONTINUE
            E4SA(I,J,M,N)=DUMMYE
  130     CONTINUE

          CALL CHG_BASIS(AUX6,AUX33,AUX66,E4SA,4,6)
          CALL LU_INVERSE(AUX66,6)

          DO I=1,6
          DO J=1,6
            CTILDE(I,J)=0.
            DO K=1,6
              CTILDE(I,J)=CTILDE(I,J)+CSC(I,K)*(AUX66(K,J)-XID6(K,J))
            ENDDO
            AC2(I,J)=CSC(I,J)+CTILDE(I,J)
          ENDDO
          ENDDO

          DO KKK=NGR(IPH-1)+1,NGR(IPH)

            DO I=1,6
            DO J=1,6
              AC1(I,J)=CGR(I,J,KGX)+CTILDE(I,J)
            ENDDO
            ENDDO
            CALL LU_INVERSE(AC1,6)
            DO I=1,6
            DO J=1,6
              AC(I,J)=0.
              DO K=1,6
                AC(I,J)=AC(I,J)+AC1(I,K)*AC2(K,J)
              ENDDO
            ENDDO
            ENDDO

            DO I=1,6
            DO J=1,6
              AUX66(I,J)=0.
              DO K=1,6
                AUX66(I,J)=AUX66(I,J)+CGR(I,K,KGX)*AC(K,J)
              ENDDO
              CNEW(I,J)=CNEW(I,J)+AUX66(I,J)*WGT(KKK)
            ENDDO
            ENDDO

            KGX=KGX+1
          ENDDO
        ENDDO      ! END OF LOOP OVER ALL GRAINS IN ALL PHASES

        RER=TMISMATCH6x6(CSC,CNEW)

C *** SAVES THE SYMMETRIC TENSOR AS THE NEW GUESS
        DO I=1,6
          DO J=I,6
            CSC(I,J)=0.5*(CNEW(I,J)+CNEW(J,I))
            CSC(J,I)=CSC(I,J)
          ENDDO
        ENDDO

        WRITE( *,'(1H+,''  EL ITER'',I4,''    REL ERR'',E11.3)') IT,RER
cq        WRITE(12,'(    ''  EL ITER'',I4,''    REL ERR'',E11.3)') IT,RER

      ENDDO      ! END OF (DO..WHILE)

      DO I=1,6
      DO J=1,6
        COLD(I,J)=CSC(I,J)
        SSC(I,J) =CSC(I,J)
      ENDDO
      ENDDO

CFEB
C --> WRITE MATRIX REPRESENTATION OF ESHELBY TENSOR
      CALL VOIGT(AUX6,AUX33,AUX66,E4SA,4)
      WRITE(10,*)
      WRITE(10,*) ' ELASTIC ESHELBY TENSOR (VOIGT NOTATION)'
      WRITE(10,'(6F12.5)') ((AUX66(I,J),J=1,6),I=1,6)

C --> WRITE MATRIX REPRESENTATION OF STIFFNESS TENSOR
      CALL CHG_BASIS(AUX6,AUX33,CSC,AUX3333,3,6)
      CALL VOIGT    (AUX6,AUX33,CSC,AUX3333,4)
      WRITE(10,*)
      WRITE(10,'(''SC ELASTIC STIFFNESS (VOIGT NOTATION)'')')
      WRITE(10,'(6E12.4)') ((CSC(I,J),J=1,6),I=1,6)

C --> CALCULATE & WRITE MATRIX REPRESENTATION OF COMPLIANCE TENSOR
      CALL LU_INVERSE(SSC,6)
      CALL CHG_BASIS(AUX6,AUX33,SSC,AUX3333,3,6)
      CALL VOIGT    (AUX6,AUX33,SSC,AUX3333,4)
      WRITE(10,*)
      WRITE(10,'(''SC ELASTIC COMPLIANCE (VOIGT NOTATION)'')')
      WRITE(10,'(6E12.4)') ((SSC(I,J),J=1,6),I=1,6)
CFEE

      RETURN
      END
C
C ***********************************************************************
C     SUBROUTINE ESHELBY      --->      VERSION 15/NOV/07
C
C     IOPTION=0: Initialize arrays assoc. with Gauss integration points.
C     IOPTION=1: Calculate elastic Eshelby tensor for elastic inclusion.
C     IOPTION=2: Calculate incompressible Eshelby tensors ESIM (strain-
C                rate) & ESCR (spin-rate) associated with the visco-
C                plastic inclusion.
C     IOPTION=3: Calculate incompressible and hydrostatic Eshelby tensors
C                PESH (deviatoric pressure), PDIL (spherical pressure) &
C                DESH (dilatation) for visco-plastic inclusion.
C     IOPTION=4: Calculates 1st term in d(S)/d(M)=d(T)/d(M)*L+T*d(L)/d(M)
C     IOPTION=5: Calculates 2nd term in d(S)/d(M)=d(T)/d(M)*L+T*d(L)/d(M)
C
C     Options 2-3-4-5 admit a non-zero visco-plastic bulk modulus KEFF.
C
C     Algorithms are based in Lebensohn et al, MSMSE 6 (1998) p.447.
C
C     Uses explicit matrix inversion and explicit Voigt notation (when
C     possible) to optimize computing time.
C
C     Modified oct/2005 to adapt number of integration points to the shape
C     of the ellipsoid in order to keep Eshelby tensor within a certain
C     tolerance (based on analysis done by Gwenaelle Proust).
C     Aspect ratio criterion was adopted for the case AXIS(2)>AXIS(1)>AXIS(3)
C
C     Modified oct/2007 to use a Gauss-Lobatto integration with fix (ten)
C     integration points and weights, chosen to optimize the integration
C     within (eleven) different domains of the ellipsoid aspect ratios.
C     (based on analysis made by Laurent Capolungo).
C        if IGAUSSLEG=0 uses Gauss Lobatto  (cases 1 to 11) (hardwired)
C        if IGAUSSLEG=1 uses Gauss Legendre (case 12) (kept as an option)
C ***********************************************************************

      SUBROUTINE ESHELBY (axis,c4,keff,esim,escr,
     #                    desh,pesh,pdil,dldm,dsddm,ioption)

      DIMENSION c4(3,3,3,3),esim(3,3,3,3),escr(3,3,3,3)
      DIMENSION p(3,3),pesh(3,3),desh(3,3)
      DIMENSION c2(6,6),gamma2(6,6),gamma4(3,3,3,3)
      DIMENSION axis(3),x1(10),a1(10),a1inv(10)
      DIMENSION aa1x(6),aa2x(3,3),aaww1x(6),aaww2x(3,3)

      dimension dldm(3,3,3,3),dsddm(3,3,3,3),dldm2(6,6)
CFEB
      dimension da1(6),da(4,4),dainv(4,4),ainv(4,4)
      dimension aux33(3,3),aux66(6,6),aux3333(3,3,3,3),aux44(4,4)
CFEE
      PARAMETER (ngaumx=16,ngaumx2=256)
      DIMENSION xph(ngaumx),xth(ngaumx),wph(ngaumx),wth(ngaumx)
      COMMON/ESHELBY1/ngaussph(12),ngaussth(12)
      COMMON/ESHELBY2/alpha(12,3,ngaumx2),aa1(12,6,ngaumx2),
     # aww(12,3,ngaumx2),aaww1(12,6,ngaumx2),ww(12,ngaumx2)
C *** Integration points and weights, and limits of aspect ratios
      COMMON/ESHELBY3/punti(10,11),pesi(10,11),dte(0:10),
     #                puntigl(16),pesigl(16)

      REAL      keff
      INTEGER   case

      pi=4.*atan(1.0)

      IGAUSSLEG=0     ! hardwires the Gauss-Lobatto option
ccc   IGAUSSLEG=1     ! hardwires the Gauss-Legendre option

C ***********************************************************************c
C     INITIALIZATION RUN
C     Calculates Gauss-Legendre integration points and weights in the
c     interval [0,pi]. Initializes Gauss-Lobatto points and weights.
C     Initializes arrays associated with each point to avoid repeating
C     its calculation at every call. All values of the points and
C     weights were calculated to optimize the error.
C ***********************************************************************

      if(ioption.eq.0) then

        do i=1,11
          ngaussph(i)=10      ! Gauss-Lobatto
          ngaussth(i)=10
        end do
        ngaussph(12)=16       ! Gauss-Legendre
        ngaussth(12)=16

c****************************
c  CASE 1
c****************************
        punti(1,1)=4.71236594E-02
        punti(2,1)=0.241774723
        punti(3,1)=0.565131843
        punti(4,1)=0.968887568
        punti(5,1)=1.37937832
        punti(6,1)=1.76221442
        punti(7,1)=2.17270517
        punti(8,1)=2.57646084
        punti(9,1)=2.89981818
        punti(10,1)=3.09446883

        pesi(1,1)=0.120191820
        pesi(2,1)=0.264987558
        pesi(3,1)=0.373805553
        pesi(4,1)=0.420841277
        pesi(5,1)=0.390970200
        pesi(6,1)=0.390970260
        pesi(7,1)=0.420841366
        pesi(8,1)=0.373805553
        pesi(9,1)=0.264987499
        pesi(10,1)=0.120192111

c****************************
c  CASE 2
c****************************
        punti(1,2)=1.57080423E-02
        punti(2,2)=0.144995824
        punti(3,2)=0.425559640
        punti(4,2)=0.829968274
        punti(5,2)=1.31460333
        punti(6,2)=1.82698941
        punti(7,2)=2.31162453
        punti(8,2)=2.71603298
        punti(9,2)=2.99659705
        punti(10,2)=3.12588477

        pesi(1,2)=5.41692823E-02
        pesi(2,2)=0.207461149
        pesi(3,2)=0.348739326
        pesi(4,2)=0.452716887
        pesi(5,2)=0.507709801
        pesi(6,2)=0.507709682
        pesi(7,2)=0.452716798
        pesi(8,2)=0.348738998
        pesi(9,2)=0.207461327
        pesi(10,2)=5.41692935E-02

c****************************
c  CASE 3
c****************************
        punti(1,3)=3.76990959E-02
        punti(2,3)=0.198626831
        punti(3,3)=0.483041346
        punti(4,3)=0.871647120
        punti(5,3)=1.32964790
        punti(6,3)=1.81194484
        punti(7,3)=2.26994562
        punti(8,3)=2.65855122
        punti(9,3)=2.94296598
        punti(10,3)=3.10389376

        pesi(1,3)=9.68142375E-02
        pesi(2,3)=0.224478707
        pesi(3,3)=0.341134071
        pesi(4,3)=0.430180043
        pesi(5,3)=0.478189558
        pesi(6,3)=0.478189170
        pesi(7,3)=0.430180043
        pesi(8,3)=0.341134191
        pesi(9,3)=0.224478647
        pesi(10,3)=9.68143344E-02

c****************************
c  CASE 4
c****************************
        punti(1,4)=3.45576368E-02
        punti(2,4)=0.187556863
        punti(3,4)=0.468425453
        punti(4,4)=0.859980166
        punti(5,4)=1.32527423
        punti(6,4)=1.81631863
        punti(7,4)=2.28161263
        punti(8,4)=2.67316723
        punti(9,4)=2.95403576
        punti(10,4)=3.10703516

        pesi(1,4)=8.95763785E-02
        pesi(2,4)=0.217725381
        pesi(3,4)=0.341026783
        pesi(4,4)=0.435772508
        pesi(5,4)=0.486694932
        pesi(6,4)=0.486695170
        pesi(7,4)=0.435772508
        pesi(8,4)=0.341026902
        pesi(9,4)=0.217725128
        pesi(10,4)=8.95764604E-02

c****************************
c  CASE 5
c****************************
        punti(1,5)= 3.14158052E-02
        punti(2,5)=0.177928671
        punti(3,5)= 0.457155794
        punti(4,5)= 0.851592362
        punti(5,5)= 1.32222414
        punti(6,5)= 1.81936860
        punti(7,5)=2.29000044
        punti(8,5)=2.68443704
        punti(9,5)=2.96366405
        punti(10,5)=3.11017680

        pesi(1,5)=8.26927349E-02
        pesi(2,5)=0.213228315
        pesi(3,5)=0.342008322
        pesi(4,5)=0.440196186
        pesi(5,5)=0.492670894
        pesi(6,5)=0.492670983
        pesi(7,5)=0.440195888
        pesi(8,5)=0.342008322
        pesi(9,5)=0.213227972
        pesi(10,5)=8.26930404E-02

c****************************
c  CASE 6
c****************************
        punti(1,6)= 2.98452154E-02
        punti(2,6)=0.173592165
        punti(3,6)=0.452448040
        punti(4,6)=0.848216832
        punti(5,6)=1.32101476
        punti(6,6)=1.82057810
        punti(7,6)= 2.29337597
        punti(8,6)=2.68914461
        punti(9,6)=2.96800065
        punti(10,6)=3.11174774

        pesi(1,6)=7.93928578E-02
        pesi(2,6)=0.211627841
        pesi(3,6)=0.342669785
        pesi(4,6)=0.442057431
        pesi(5,6)=0.495048553
        pesi(6,6)=0.495048642
        pesi(7,6)=0.442057490
        pesi(8,6)=0.342670023
        pesi(9,6)=0.211627468
        pesi(10,6)=7.93929026E-02

c****************************
c  CASE 7
c****************************
        punti(1,7)=2.67036632E-02
        punti(2,7)=0.165752888
        punti(3,7)=0.444431901
        punti(4,7)=0.842614472
        punti(5,7)=1.31902647
        punti(6,7)= 1.82256627
        punti(7,7)=2.29897833
        punti(8,7)=2.69716072
        punti(9,7)=2.97583985
        punti(10,7)=3.11488938

        pesi(1,7)=7.30879456E-02
        pesi(2,7)=0.209402516
        pesi(3,7)=0.344104946
        pesi(4,7)=0.445234656
        pesi(5,7)=0.498966068
        pesi(6,7)= 0.498966306
        pesi(7,7)=0.445234746
        pesi(8,7)= 0.344104946
        pesi(9,7)=0.209402665
        pesi(10,7)=7.30878562E-02

c****************************
c  CASE 8
c****************************
        punti(1,8)=2.67036632E-02
        punti(2,8)=0.165752888
        punti(3,8)=0.444431901
        punti(4,8)=0.842614472
        punti(5,8)=1.31902647
        punti(6,8)=1.82256627
        punti(7,8)=2.29897833
        punti(8,8)=2.69716072
        punti(9,8)=2.97583985
        punti(10,8)=3.11488938

        pesi(1,8)=7.30879456E-02
        pesi(2,8)=0.209402516
        pesi(3,8)=0.344104946
        pesi(4,8)=0.445234656
        pesi(5,8)=0.498966068
        pesi(6,8)=0.498966306
        pesi(7,8)=0.445234746
        pesi(8,8)=0.344104946
        pesi(9,8)=0.209402665
        pesi(10,8)= 7.30878562E-02

c****************************
c  CASE 9
c****************************
        punti(1,9)=2.43473575E-02
        punti(2,9)=0.160516247
        punti(3,9)=0.439386278
        punti(4,9)=0.839168847
        punti(5,9)=1.31781363
        punti(6,9)=1.82377899
        punti(7,9)=2.30242372
        punti(8,9)=2.70220637
        punti(9,9)=2.98107672
        punti(10,9)=3.11724544

        pesi(1,9)=6.86219111E-02
        pesi(2,9)=0.208388865
        pesi(3,9)=0.345189095
        pesi(4,9)=0.447236270
        pesi(5,9)=0.501360059
        pesi(6,9)=0.501359940
        pesi(7,9)=0.447236151
        pesi(8,9)=0.345189214
        pesi(9,9)=0.208388969
        pesi(10,9)=6.86219335E-02

c****************************
c  CASE 10
c****************************
        punti(1,10)=2.19910536E-02
        punti(2,10)=0.155757755
        punti(3,10)=0.434985727
        punti(4,10)=0.836206555
        punti(5,10)=1.31677616
        punti(6,10)= 1.82481658
        punti(7,10)=2.30538607
        punti(8,10)=2.70660710
        punti(9,10)=2.98583508
        punti(10,10)=3.11960149

        pesi(1,10)=6.43825606E-02
        pesi(2,10)=0.207786217
        pesi(3,10)=0.346235514
        pesi(4,10)=0.448981822
        pesi(5,10)=0.503410578
        pesi(6,10)= 0.503410578
        pesi(7,10)=0.448981792
        pesi(8,10)=0.346235693
        pesi(9,10)=0.207785636
        pesi(10,10)= 6.43827692E-02

c****************************
c  CASE 11
c****************************
        punti(1,11)=2.04204638E-02
        punti(2,11)=0.152822554
        punti(3,11)=0.432348520
        punti(4,11)=0.834448099
        punti(5,11)=1.31616223
        punti(6,11)=1.82543063
        punti(7,11)=2.30714464
        punti(8,11)=2.70924401
        punti(9,11)=2.98877001
        punti(10,11)=3.12117243

        pesi(1,11)=6.16818815E-02
        pesi(2,11)=0.207559645
        pesi(3,11)=0.346902698
        pesi(4,11)=0.450027168
        pesi(5,11)=0.504624724
        pesi(6,11)= 0.504624426
        pesi(7,11)=0.450027317
        pesi(8,11)=0.346902847
        pesi(9,11)=0.207559645
        pesi(10,11)=6.16819337E-02

c**************************************
c  CASE 12: GAULEG generates the points
c**************************************
        call gauleg(0.0,pi,puntigl,pesigl,ngaussph(12))

C *****************************************************************
C *** Calculates and saves arrays that depend on integration points

       do case=1,12

         if (case.eq.12) then
           do i=1,16
             xph(i)=puntigl(i)
             xth(i)=puntigl(i)
             wph(i)= pesigl(i)
             wth(i)= pesigl(i)
           end do
         else
           do i=1,10
             xph(i)=punti(i,case)
             xth(i)=punti(i,case)
             wph(i)= pesi(i,case)
             wth(i)= pesi(i,case)
           end do
         end if
c--------------------------------------------------------------
c *** integration [0,pi][0,pi] adds a factor 2 in Eqs. B11 & B14.

         do ith=1,ngaussth(case)
           sinth=sin(xth(ith))
           costh=cos(xth(ith))
           simbtet=wth(ith)*sinth/(2.0*pi)

           do iph=1,ngaussph(case)
             ny=iph+(ith-1)*ngaussph(case)
             ww(case,ny)=simbtet*wph(iph)
             alpha(case,1,ny)=sinth*cos(xph(iph))
             alpha(case,2,ny)=sinth*sin(xph(iph))
             alpha(case,3,ny)=costh

             do i=1,3
             do j=1,3
               aa2x(i,j)  =alpha(case,i,ny)*alpha(case,j,ny)
               aaww2x(i,j)=aa2x(i,j)*ww(case,ny)
             enddo
             enddo
             call voigt(aa1x  ,aa2x  ,c2,c4,2)
             call voigt(aaww1x,aaww2x,c2,c4,2)
             do i=1,6
               aa1(case,i,ny)  =aa1x(i)
               aaww1(case,i,ny)=aaww1x(i)
             enddo

c *** Array AWW is used only if ICAUCHY=1.
             do i=1,3
               aww(case,i,ny)=alpha(case,i,ny)*ww(case,ny)
             enddo
           enddo
         enddo

        enddo      ! end of do case=1,12

      endif      ! ENDIF FOR IOPTION=0

C************************************************************************
C     End of initialization
C************************************************************************

C ***********************************************************************
C     CALCULATION OF ESHELBY TENSORS FOR STIFFNESS 'C4' AND ELLIPSOID
C     AXES 'AXIS'
C     ASSUMES: AXIS2 > AXIS1 > AXIS3  --> RATIO1 > RATIO2 > 1
C ***********************************************************************

      if(ioption.ge.1) then

        abc=axis(1)*axis(2)*axis(3)
        ratio1=axis(2)/axis(3)
        ratio2=axis(1)/axis(3)

        if (igaussleg.eq.1) then
          case=12
        else
          dte(0) = 0.0
          dte(1) =-0.7*ratio1+7
          dte(2) =-ratio1+17
          dte(3) =-ratio1+23
          dte(4) =-ratio1+26
          dte(5) =-ratio1+29.3
          dte(6) =-ratio1+32
          dte(7) =-ratio1+34.85
          dte(8) =-ratio1+37
          dte(9) =-ratio1+41.9
          dte(10)=-ratio1+44.5
          case=11
          do i=1,10
            if(ratio2.ge.dte(i-1) .and. ratio2.lt.dte(i)) case=i
          enddo
        endif

c--------------------------------------------------------

        npoints=ngaussph(case)*ngaussth(case)

        pdil=0.
        do j=1,3
        do i=1,3
          p(i,j)=0.
        enddo
        enddo
        do j=1,6
        do i=1,6
          gamma2(i,j)=0.
        enddo
        enddo

        call voigt(aa1x,aa2x,c2,c4,4)
        IF(IOPTION.EQ.5) CALL VOIGT(AA1X,AA2X,DLDM2,DLDM,4)

        do ny=1,npoints

c   Compute Voigt components A1(1)-A(6) of tensor A(3,3) defined by Eq.B3:
c   --->  A(i,j)=L(i,j,k,l)*a(j)*a(l)

          do i=1,6
            aa1x(i)=aa1(case,i,ny)
          enddo
          call esh_mult_voigt(c2,aa1x,a1(1:6))   ! c2*aa1x=a1

      IF(IOPTION.EQ.1) THEN

c   If solving an elastic inclusion invert the system
c   --> A(3,3) x X(3,3) = C(3,3)
c   Inverts A(3,3) using explicit Voigt notation.
c   Uses explicit form of C(3,3) to calculate solution in Voigt notation.

            call esh_inv3_voigt(a1,a1inv)
            do i=1,6
              x1(i)=a1inv(i)
            enddo

      ELSE IF(IOPTION.GE.2) THEN

c   If solving a visco-plastic inclusion defines components A1(7) to A1(10).
c   Solves the system given by Eq.B4 --> A(4,4) x X(4,4) = C(4,4)
c   Inverts A(4,4) using explicit Voigt notation.
c   Uses explicit form of C(4,4) to calculate solution in Voigt notation.
c   The solution is symmetric. Numerical deviation from symmetry is averaged.

            a1(7) = alpha(case,1,ny)
            a1(8) = alpha(case,2,ny)
            a1(9) = alpha(case,3,ny)
            a1(10)= 0.
            if(keff.gt.0.) a1(10)=-1./keff

            call esh_inv4_voigt(a1,a1inv)

            do i=1,10
              x1(i)=a1inv(i)
            enddo

      ENDIF
CFEB
      IF(IOPTION.EQ.5) THEN

        CALL VOIGT10(A1INV,AINV,1)

        call esh_mult_voigt(dldm2,aa1x,da1)        ! dldm2*aa1x=da1
        call voigt(da1,aux33,aux66,aux3333,1)

        do i=1,3
        do j=1,3
          da(i,j)=aux33(i,j)
        enddo
        enddo
c
        do i=1,3
        da(i,4)=0.
        da(4,i)=0.
        enddo
        da(4,4)=0.
c
c           dAinv/dp = - Ainv  : dA/dp : Ainv
c                x1  = - a1inv :  da1  : a1inv
c
        do i=1,4
        do j=1,4
        dummy=0.
        do k=1,4
        dummy=dummy+da(i,k)*ainv(k,j)
        enddo
        aux44(i,j)=dummy
        enddo
        enddo

        do i=1,4
        do j=1,4
        dummy=0.
        do k=1,4
          dummy=dummy+ainv(i,k)*aux44(k,j)
        enddo
        dainv(i,j)=-dummy
        enddo
        enddo

        CALL VOIGT10(X1,DAINV,2)

      ENDIF
CFEE
          ro3=((alpha(case,1,ny)*axis(1))**2+
     #         (alpha(case,2,ny)*axis(2))**2+
     #         (alpha(case,3,ny)*axis(3))**2)**1.5
          abcoro3=abc/ro3

c   Compute the Eshelby integral Eq.B11 defining:
c         Gamma(m,j,n,i)=T(m,n,i,j)=a(m)*a(j)*G(n,i)
c   with the property:
c         Gamma(m,j,n,i)=Gamma(j,m,n,i)=Gamma(m,j,i,n)

          do i=1,6
          do j=1,6
            gamma2(i,j)=gamma2(i,j)+aaww1(case,i,ny)*x1(j)*abcoro3
          enddo
          enddo

c   Compute the pressure related Eshelby integral Eq.B14
          if(ioption.eq.3) then
            do j=1,3
            do i=1,3
              p(i,j)=p(i,j)+aww(case,j,ny)*x1(i+6)*abcoro3
            enddo
            enddo
            pdil=pdil+ww(case,ny)*x1(10)*abcoro3
          endif

        end do   ! end of loop over double integration

c ********************************************************************
c   Go back to the 3*3*3*3 notation
        call voigt(aa1x,aa2x,gamma2,gamma4,3)

c   Compute symmetric (distortion) Eshelby tensor from Eq.B9.
c       esim(n,m,k,l)=0.5*(gamma(m,j,n,i)+gamma(n,j,m,i))*c4(i,j,k,l)
c   Compute anti-symmetric (rotation) Eshelby tensor from Eq.B9.
c       escr(n,m,k,l)=0.5*(gamma(m,j,n,i)-gamma(n,j,m,i))*c4(i,j,k,l)

        do l=1,3
        do k=1,3
        do m=1,3
        do n=1,3
c
          dumsim=0.
          dumscr=0.
c
        do j=1,3
        do i=1,3
c
        IF(IOPTION.NE.4) THEN
          dumsim=dumsim+(gamma4(m,j,n,i)+gamma4(n,j,m,i))*c4(i,j,k,l)
          dumscr=dumscr+(gamma4(m,j,n,i)-gamma4(n,j,m,i))*c4(i,j,k,l)
        ELSE
          dumsim=dumsim+(gamma4(m,j,n,i)+gamma4(n,j,m,i))*dldm(i,j,k,l)
          dumscr=dumscr+(gamma4(m,j,n,i)-gamma4(n,j,m,i))*dldm(i,j,k,l)
        ENDIF
c
        enddo
        enddo
c
          IF(IOPTION.LT.4) THEN
            esim(n,m,k,l)=0.5*dumsim
            escr(n,m,k,l)=0.5*dumscr
          ELSE
            dsddm(n,m,k,l)=0.5*dumsim
          ENDIF
c
        enddo
        enddo
        enddo
        enddo

c   Compute pressure & dilatation related Eshelby tensors (Eq.B13)

        if(ioption.eq.3) then
          do l=1,3
          do k=1,3
            pesh(k,l)=0.
            do j=1,3
            do i=1,3
              pesh(k,l)=pesh(k,l)+p(i,j)*c4(i,j,k,l)
            end do
            end do
          end do
          end do
          do j=1,3
          do i=1,3
            desh(i,j)=(p(i,j)+p(j,i))/2.
          end do
          end do
        endif

      endif      !  endif for IOPTION.GE.1

      RETURN
      END
C
C *************************************************************************
C     SUBROUTINE ESH_INV3_VOIGT   --->   version 23/jul/01
C
C     Inverts the 3x3 symmetric matrix 'A' using explicit Voigt notation:
C     11->1, 22->2, 33->3, 23=32->4, 31=13->5, 12=21->6
C *************************************************************************

      SUBROUTINE ESH_INV3_VOIGT (A,AINV)

      DIMENSION A(10),AINV(10)

      DET = A(1)*A(2)*A(3) + 2*A(4)*A(5)*A(6) - A(1)*A(4)*A(4)
     #     - A(2)*A(5)*A(5) - A(3)*A(6)*A(6)

      AINV(1) = ( A(2)*A(3) - A(4)*A(4))/DET
      AINV(2) = ( A(1)*A(3) - A(5)*A(5))/DET
      AINV(3) = ( A(1)*A(2) - A(6)*A(6))/DET
      AINV(4) = (-A(1)*A(4) + A(5)*A(6))/DET
      AINV(5) = ( A(4)*A(6) - A(2)*A(5))/DET
      AINV(6) = (-A(3)*A(6) + A(4)*A(5))/DET

      RETURN
      END
C
C **********************************************************************
C     SUBROUTINE ESH_INV4_VOIGT   --->   VERSION 20/JUL/01

C     Inverts the 4*4 symmetric matrix 'A' using explicit Voigt notation:
C     11-->1, 22-->2, 33-->3, 23=32-->4, 31=13-->5, 12=21-->6
C     14-->7, 24-->8, 34-->9, 44-->10.
C **********************************************************************

      SUBROUTINE ESH_INV4_VOIGT (A,AINV)

      DIMENSION A(10),AINV(10)


      ainv(1) = a(2)*a(3)*a(10)+2*a(4)*a(8)*a(9) -
     #          a(2)*a(9)*a(9)-a(3)*a(8)*a(8)-a(4)*a(4)*a(10)

      ainv(2) = a(1)*a(3)*a(10)+2*a(5)*a(7)*a(9) -
     #          a(1)*a(9)*a(9)-a(3)*a(7)*a(7)-a(5)*a(5)*a(10)

      ainv(3) = a(1)*a(2)*a(10)+2*a(6)*a(7)*a(8) -
     #          a(1)*a(8)*a(8)-a(2)*a(7)*a(7)-a(6)*a(6)*a(10)

      ainv(4) = a(1)*a(4)*a(10)+a(5)*a(7)*a(8)+a(6)*a(7)*a(9) -
     #          a(1)*a(8)*a(9)-a(4)*a(7)*a(7)-a(5)*a(6)*a(10)
      ainv(4) =-ainv(4)

      ainv(5) = a(4)*a(6)*a(10)+a(2)*a(7)*a(9)+a(5)*a(8)*a(8) -
     #          a(4)*a(7)*a(8)-a(6)*a(8)*a(9)-a(2)*a(5)*a(10)

      ainv(6) = a(3)*a(6)*a(10)+a(5)*a(8)*a(9)+a(4)*a(7)*a(9) -
     #          a(3)*a(7)*a(8)-a(6)*a(9)*a(9)-a(4)*a(5)*a(10)
      ainv(6) =-ainv(6)

      ainv(7) = a(4)*a(6)*a(9)+a(4)*a(5)*a(8)+a(2)*a(3)*a(7) -
     #          a(4)*a(4)*a(7)-a(2)*a(5)*a(9)-a(3)*a(6)*a(8)
      ainv(7) =-ainv(7)

      ainv(8) = a(1)*a(4)*a(9)+a(5)*a(5)*a(8)+a(3)*a(6)*a(7) -
     #          a(4)*a(5)*a(7)-a(5)*a(6)*a(9)-a(1)*a(3)*a(8)

      ainv(9) = a(1)*a(2)*a(9)+a(5)*a(6)*a(8)+a(4)*a(6)*a(7) -
     #          a(2)*a(5)*a(7)-a(6)*a(6)*a(9)-a(1)*a(4)*a(8)
      ainv(9) =-ainv(9)

      ainv(10)=a(1)*a(2)*a(3)+2*a(4)*a(5)*a(6) -
     #         a(1)*a(4)*a(4)-a(2)*a(5)*a(5)-a(3)*a(6)*a(6)

      det=   a(1)*ainv(1)+   a(2)*ainv(2)+   a(3)*ainv(3)+
     #    2.*a(4)*ainv(4)+2.*a(5)*ainv(5)+2.*a(6)*ainv(6)+
     #    2.*a(7)*ainv(7)+2.*a(8)*ainv(8)+2.*a(9)*ainv(9)+
     #       a(10)*ainv(10)
      det=   det/4.

      do i=1,10
        ainv(i)=ainv(i)/det
      enddo

      return
      end
C
C ***********************************************************
      SUBROUTINE ESH_MULT_VOIGT(B,C,A)

C     Performs the multiplication:
C        A(i,k)=B(i,j,k,l)*C(j,l) using Voigt's notation
C        B is a 6*6 symmetric matrix
C        C is a 3*3 symmetric tensor
C        A will be a 3*3 symmetric tensor

      DIMENSION B(6,6),C(6),A(9)

      A(1)=B(1,1)*C(1)+B(6,6)*C(2)+B(5,5)*C(3)
     #    +2*(B(5,6)*C(4)+B(1,5)*C(5)+B(1,6)*C(6))

      A(2)=B(6,6)*C(1)+B(2,2)*C(2)+B(4,4)*C(3)
     #    +2*(B(2,4)*C(4)+B(4,6)*C(5)+B(2,6)*C(6))

      A(3)=B(5,5)*C(1)+B(4,4)*C(2)+B(3,3)*C(3)
     #    +2*(B(3,4)*C(4)+B(3,5)*C(5)+B(4,5)*C(6))

      A(4)=B(5,6)*C(1)+B(2,4)*C(2)+B(3,4)*C(3)
     #      +(B(2,3)+B(4,4))*C(4)
     #      +(B(3,6)+B(4,5))*C(5)
     #      +(B(4,6)+B(2,5))*C(6)

      A(5)=B(1,5)*C(1)+B(4,6)*C(2)+B(3,5)*C(3)
     #      +(B(3,6)+B(4,5))*C(4)
     #      +(B(1,3)+B(5,5))*C(5)
     #      +(B(1,4)+B(5,6))*C(6)

      A(6)=B(1,6)*C(1)+B(2,6)*C(2)+B(4,5)*C(3)
     #      +(B(4,6)+B(2,5))*C(4)
     #      +(B(1,4)+B(5,6))*C(5)
     #      +(B(1,2)+B(6,6))*C(6)

      RETURN
      END
c
c *****************************************************************************
      subroutine euler (iopt,ph,th,tm,a)
c
c     CALCULATE THE EULER ANGLES ASSOCIATED WITH THE TRANSFORMATION
c     MATRIX A(I,J) IF IOPT=1 AND VICEVERSA IF IOPT=2
c     A(i,j) TRANSFORMS FROM SYSTEM sa TO SYSTEM ca.
c     ph,th,om ARE THE EULER ANGLES (in degrees) OF ca REFERRED TO sa.
c *****************************************************************************

      dimension a(3,3)
      pi=4.*atan(1.d0)

      if(iopt.eq.1) then
        th=acos(a(3,3))
        if(abs(a(3,3)).ge.0.9999) then
          tm=0.
          ph=atan2(a(1,2),a(1,1))
        else
          sth=sin(th)
          tm=atan2(a(1,3)/sth,a(2,3)/sth)
          ph=atan2(a(3,1)/sth,-a(3,2)/sth)
        endif
        th=th*180./pi
        ph=ph*180./pi
        tm=tm*180./pi
      else if(iopt.eq.2) then
        sph=sin(ph*pi/180.)
        cph=cos(ph*pi/180.)
        sth=sin(th*pi/180.)
        cth=cos(th*pi/180.)
        stm=sin(tm*pi/180.)
        ctm=cos(tm*pi/180.)
        a(1,1)=ctm*cph-sph*stm*cth
        a(2,1)=-stm*cph-sph*ctm*cth
        a(3,1)=sph*sth
        a(1,2)=ctm*sph+cph*stm*cth
        a(2,2)=-sph*stm+cph*ctm*cth
        a(3,2)=-sth*cph
        a(1,3)=sth*stm
        a(2,3)=ctm*sth
        a(3,3)=cth
      endif

      return
      end

CFEB
C ***************************************************************************
C     SUBROUTINE GRAIN_INFO (ex GRINFO)   --->   VERSION 28/may/2002
C
C     FOR EACH GRAIN CALCULATES ACCUMULATED VM STRAIN, VM STRESS,
C     ACCUMULATED PLASTIC WORK AND 'TAYLOR' FACTOR, DEFINED AS:
C          Mg=(SG(i).DBAR(i))/tau/|DBAR|*sqrt(3/2)
C ***************************************************************************

      SUBROUTINE GRAIN_INFO

      INCLUDE 'vpsc7.dim'

      DBARNORM=VNORM(DBAR,5)
      VMFACTOR=SQRT(1.5)
      KGX=1
      DO IPH=IPHBOT,IPHTOP
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        DGVMX=0.
        WORKX=0.
        TAYLX=0.
        DO I=1,5
          DGVMX=DGVMX+DG(I,KGX)**2
          WORKX=WORKX+DG(I,KGX)*SG(I,KKK)
          TAYLX=TAYLX+DBAR(I)  *SG(I,KKK)
        ENDDO
        DGVMX=SQRT(DGVMX)/VMFACTOR

        EGVMSTEP(KGX)=DGVMX    *TINCR
        EGVM(KKK)    =EGVM(KKK)+EGVMSTEP(KGX)
        WORK(KKK)    =WORK(KKK)+WORKX *TINCR
        SGVM(KGX)    =0.
        IF(DGVMX.NE.0) SGVM(KGX)=WORKX/DGVMX   ! defined as the conjugate
        TAYLORG(KGX) =TAYLX/CRSS(1,KGX)/DBARNORM *VMFACTOR
        KGX=KGX+1
      ENDDO
      ENDDO

      RETURN
      END
CFEE
C ****************************************************************************
C     SUBROUTINE GRAIN_RATE_AND_MODULI (ex MICRO) -->  VERSION 17/DEC/02
C
C     GIVEN THE STRESS 'X' IN GRAIN 'KKK', CALCULATES STRAIN-RATE AND
C     VISCO-PLASTIC MODULI USING THE RATE SENSITIVITY KINEMATIC LAW.
C ****************************************************************************

      SUBROUTINE GRAIN_RATE_AND_MODULI (JSC,KCALMOD,KGX,KKK,IPHEL,IPH)

      INCLUDE 'vpsc7.dim'

      DIMENSION SX(5),DX(5),RSS(NSYSMX)

      COMMON/NLNR /DB(5),XMASTX(5,5),SCX(5,NSYSMX),TAUX(NSYSMX),
     #             GAMD0X(NSYSMX),NSYSTX,NRSX(NSYSMX),ISENSEX(NSYSMX)

C     COPY MAIN ARRAYS INTO AUXILIAR ARRAYS FOR COMPUTATIONAL EFFICIENCY

      NSYSTX=NSYST(IPHEL)
      DO IS=1,NSYSTX
        ISENSEX(IS)=ISENSE(IS,IPHEL)
        NRSX(IS)   =NRS(IS,IPHEL)
        if(jsc.eq.1.and.irsvar.eq.1) NRSX(IS)=JXRS
cw
        TAUX(IS)  =CRSS(IS,KKK)
        GAMD0X(IS)=GAMD0G(KGX)
        DO J=1,5
          SCX(J,IS)=SCH(J,IS,KGX)
        ENDDO
      ENDDO

c     write(*,*)
c     write(*,*) 'SG inside grain_rate for KKK=',kkk
c     write(*,'(5e12.3)') (sg(i,kkk),i=1,5)
c     pause

      DO I=1,5
        SX(I)=SG(I,KKK)
      ENDDO

C     GETS RESOLVED SHEAR STRESSES 'rssx' AND SHEAR RATES 'gamdot'.
C       SIGN(GAMDOT)=SIGN(RSSX).
C       NRS CAN BE EVEN OR ODD.
C       RSS IS ALWAYS > 0 AND IS USED TO CALCULATE VISCOUS COMPLIANCE.

      DO IS=1,NSYSTX
        RSSX=SX(1)*SCX(1,IS)+SX(2)*SCX(2,IS)+SX(3)*SCX(3,IS)+
     #       SX(4)*SCX(4,IS)+SX(5)*SCX(5,IS)
        IF(.NOT.(RSSX.GT.0 .OR. ISENSEX(IS).EQ.1)) RSSX=0.
        RSSX=RSSX/TAUX(IS)

c     write(*,*)
c     write(*,'('' RSSX and TAUX for sys'',i3,2e12.3)') is,rssx,taux(is)

        RSS(IS)       =GAMD0X(IS)*ABS(RSSX**(NRSX(IS)-1))/TAUX(IS)
        GAMDOT(IS,KGX)=GAMD0X(IS)*ABS(RSSX**NRSX(IS))*SIGN(1.,RSSX)
      ENDDO

C     CALCULATE STRAIN-RATE IN GRAIN 'dg'

      DO I=1,5
        DG(I,KGX)=0.
        DO IS=1,NSYSTX
          DG(I,KGX)=DG(I,KGX)+SCX(I,IS)*GAMDOT(IS,KGX)
        ENDDO
        DX(I)=DG(I,KGX)
      ENDDO

c     write(*,*)
c     write(*,*) 'DG inside grain_rate for KGX=',kgx
c     write(*,'(5e12.3)') (dg(i,kgx),i=1,5)
c     pause

      IF(KCALMOD.EQ.1) THEN

C     CALCULATE CRYSTAL COMPLIANCE --> explain next lines!

      DO I=1,5
      DO J=1,5
        XMCTG (I,J,KGX)=0.
        DO IS=1,NSYSTX
          if(interaction.eq.2.or.interaction.eq.3.or.
     #      interaction.eq.4) then
            XMCTG(I,J,KGX)=XMCTG(I,J,KGX)+SCX(I,IS)*SCX(J,IS)*RSS(IS)
          else
            XMCTG(I,J,KGX)=XMCTG(I,J,KGX)+NRSX(IS)*
     #                    SCX(I,IS)*SCX(J,IS)*RSS(IS)
          endif
        ENDDO
      ENDDO
      ENDDO
CFEB
      if(interaction.eq.5) then
        DO IS=1,NSYSTX
          aso(is,kgx)=nrsx(is)*rss(is)
          eso(is,kgx)=(1-nrsx(is))*gamdot(is,kgx)
        ENDDO
      endif
CFEE
      IF(INTERACTION.EQ.1.OR.INTERACTION.EQ.5) THEN
        do i=1,5
          dczero(i,kgx)=dx(i)
          do j=1,5
            dczero(i,kgx)=dczero(i,kgx)-xmctg(i,j,kgx)*sx(j)
          enddo
        enddo
cc      WRITE (*,'(i5,5F10.3)') KGX,(DCZERO(I,KGX),I=1,5)
cc      pause
      ELSE
        do i=1,5
          dczero(i,kgx)=0.
        enddo
      ENDIF        ! INTERACTION ENDIF

      ENDIF        ! KCALMOD ENDIF

      RETURN
      END
C
C *****************************************************************************
C     SUBROUTINE GRAIN_STRESS (ex VISC)   --->   version of 19/MAR/2003
C
C     GIVEN A GUESS STRESS 'X(I)' AND GRAIN INDEX 'KKK', SOLVES INTERACTION
C     EQUATION TO FIND THE STRESS 'X' COMPATIBLE WITH MACROSCOPIC COMPLIANCE.
C     IF INTERX=-1 SOLVES ONLY THE POWER LAW FOR A RELAXED CONSTRAINTS CASE.
C     IF INTERX= 0 SOLVES ONLY THE POWER LAW FOR A TAYLOR CASE.
C     IF INTERX> 0 SOLVES INTERACTION EQUATION FOR A SELF-CONSISTENT CASE.
C *****************************************************************************

      SUBROUTINE GRAIN_STRESS (INTERX,KGX,KKK,IPHEL,IPH)

      INCLUDE 'vpsc7.dim'

      DIMENSION X(5),XORI(5)
cw      COMMON/ASTER/SASTAV(5),SASTBAR(5),DAST(5)
      COMMON/NLNR /DB(5),XMASTX(5,5),SCX(5,NSYSMX),TAUX(NSYSMX),
     #             GAMD0X(NSYSMX),NSYSTX,NRSX(NSYSMX),ISENSEX(NSYSMX)


C     EMPIRIC ALGORITHM TO GET TAULIM FOR NR SUBROUTINE (RL: 01/FEB/00)

c     taulim=2.*(Vnorm(dbar,5)/gamd0g(1))**(1./nrsmin)
      taulim=2.*(Vnorm(dbar,5)/gamd0g(1))**0.05
      if(taulim.lt.2.) taulim=2.
CFEB
      iprint=0   ! controls diagnostic print-out
      ngg=699
      iprx=iprint*(ngg/kkk)*(kkk/ngg)+
     #     iprint*((ngg+ngr(1))/kkk)*(kkk/(ngg+ngr(1)))

      if(iprx.eq.1) then
        write(10,'('' INSIDE GRAIN_STRESS: GRAIN'',i5 )') KKK
      endif
CFEE

C     COPY MAIN ARRAYS INTO AUXILIAR ARRAYS FOR COMPUTATIONAL EFFICIENCY
C     AND TO MAKE 'NEWTON_RAPHSON' A 'STAND-ALONE' SUBROUTINE

      NSYSTX=NSYST(IPHEL)
      DO IS=1,NSYSTX
        ISENSEX(IS)=ISENSE(IS,IPHEL)
        NRSX(IS)   =NRS(IS,IPHEL)
        if(interx.eq.1.and.irsvar.eq.1) NRSX(IS)=JXRS
cw
        TAUX(IS)  =CRSS(IS,KKK)
        GAMD0X(IS)=GAMD0G(KGX)
        DO J=1,5
          SCX(J,IS)=SCH(J,IS,KGX)
        ENDDO
      ENDDO

      DO I=1,5
        X(I)=STRY(I,KGX)
      ENDDO

      IRC=0

C *** CORRECTS STRESS 'X' IF IT EXCEEDS THE YIELD SURFACE.

      TAUMAX=0.
      DO IS=1,NSYSTX
        RSSX=X(1)*SCX(1,IS)+X(2)*SCX(2,IS)+X(3)*SCX(3,IS)+
     #       X(4)*SCX(4,IS)+X(5)*SCX(5,IS)
        IF(.NOT.(RSSX.GT.0 .OR. ISENSEX(IS).EQ.1)) RSSX=0.D0
        RSSX=RSSX/TAUX(IS)
        IF(ABS(RSSX).GT.TAUMAX) TAUMAX=ABS(RSSX)
      ENDDO

CFEB
      if(iprx.eq.1) then
        write(10,'('' GRAIN'',i5,''  TAUMAX='',F10.3)') KKK,TAUMAX
      endif
CFEE

      IF(TAUMAX. LT. 1.E-10) THEN
        WRITE(*,'('' TAUMAX<1e-10 inside subroutine GRAIN_STRESS'')')
        WRITE(*,'('' GRAIN #'',i5)') KKK
        WRITE(*,'('' STRY  ='',5e12.4)') X
        WRITE(*,'('' CRSS  ='',6E12.4)') (TAUX(IS),IS=1,NSYST(IPHEL))
        STOP
      ENDIF

      IF(TAUMAX.GT.TAULIM .OR. INTERX.LE.0) THEN
        DO I=1,5
          X(I)=X(I)/TAUMAX
        ENDDO
      ENDIF

      IF(INTERX.LE.0) THEN     ! interx=-1 was for RC conditions??
        DO I=1,5
          DB(I)=DBAR(I)
          DO J=1,5
            XMASTX(I,J)=0.
          ENDDO
        ENDDO
      ELSE IF(INTERX.GT.0) THEN
        IF(ISHAPE(IPH).LE.1) THEN
          DO I=1,5
          DO J=1,5
            XMASTX(I,J)=XMASTPH(I,J,IPH)
          ENDDO
          ENDDO
CFEB
        ELSE IF(ISHAPE(IPH).GT.1) THEN
          DO I=1,5
          DO J=1,5
            XMASTX(I,J)=XMASTGR(I,J,KKK)
          ENDDO
          ENDDO
CFEE
        ENDIF

        DO I=1,5
cw          DB(I)=DAST(I)
          DB(I)=DAST(I)+DZERO(I)
          DO J=1,5
            DB(I)=DB(I)+XMASTX(I,J)*SASTAV(J)
          ENDDO
        ENDDO

      ENDIF

C *** CALLS Newton-Raphson SUBROUTINE TO CALCULATE GRAIN STRESS
C *** Internally it does a 5D (IRC=0) or a 3D (IRC=1) convergence.

      DO I=1,5
        XORI(I)=X(I)
      ENDDO
      ITMX=1000
      EPS=5.e-04

c     iprx=0
c     if(kgx.eq.195 .or. kgx.eq.1288) then
c       write(10,'('' stress in #'',i5,'' before entering N-R'',
c    #             5e12.3)') kgx,x
c       write( *,'('' stress in #'',i5,'' before entering N-R'',
c    #             5e12.3)') kgx,x
c       iprx=1
c     endif
c     if(kgx/100*100 .eq. kgx) then
c       write(10,'('' stress in #'',i5,'' before entering N-R'',
c    #             5e12.3)') kgx,x
c     endif

cpp      write(*,*) 'KGX=',kgx
cpp      write(*,*) 'DZERO=',dzero
cpp      write(*,*) 'DB=',db
cpp      write(*,*) 'DAST=',dast
cpp      write(*,*) 'SASTAV=',sastav
cpp      write(*,*) 'XMASTX=',xmastx
cpp      pause
c
      CALL NEWTON_RAPHSON (X,IRC,ITMX,EPS,TAULIM,IERROR ,iprx)

      IF(IERROR.GT.0) THEN
        IF(IERROR.EQ.1) WRITE(*,'('' SINGULAR SYSTEM IN NEWTRAPH -->'',
     #       '' CANNOT SOLVE GRAIN'',I6,'' IN PHASE'',I6)') KKK,IPH
        IF(IERROR.EQ.2) WRITE(*,'('' ITMAX WAS REACH IN NEWTRAPH -->'',
     #       '' CANNOT SOLVE GRAIN'',I6,'' IN PHASE'',I6)') KKK,IPH
        WRITE(*,'('' THE INPUT STRESS IS RETAINED'')')
        DO I=1,5
          X(I)=XORI(I)
        ENDDO
      ENDIF

      DO I=1,5
        SG(I,KKK)=X(I)
      ENDDO

      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE INITIAL_STATE_GUESS     --->     VERSION 07/DEC/05

C     IF STRAIN IS IMPOSED, USES A FIRST STRESS GUESS COLINEAR WITH THE
C     STRAIN RATE AND CALCULATES GRAIN STRESS GIVEN BY TAYLOR.
C     IF STRESS IS IMPOSED, SETS THE GRAIN STRESS EQUAL TO THE MACROSCOPIC.
C     CALCULATES GRAIN STRAIN RATES 'DG' FOR EITHER CASE.
C     CALCULATES AVERAGE STRESS 'SAV' AND STRAIN-RATE 'DAV'.
C     CALCULATES VISCO-PLASTIC MODULI 'XMCTG' FOR EVERY GRAIN.
C     CALCULATES AN INITIAL GUESS FOR THE MACROSCOPIC VISCO-PLASTIC MODULUS.
C **************************************************************************

      SUBROUTINE INITIAL_STATE_GUESS

      INCLUDE 'vpsc7.dim'

      DIMENSION AUXTAN(5,5)

      DBARNORM=VNORM(DBAR,5)
      KGX=1
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          IF(STRAIN_CONTROL.EQ.1) THEN
            DO J=1,5
              STRY(J,KGX)=DBAR(J)/DBARNORM
            ENDDO
            CALL GRAIN_STRESS (0,KGX,KKK,IPHEL,IPH)
          ELSE IF(STRAIN_CONTROL.EQ.0) THEN
            DO J=1,5
              SG(J,KKK)=SBAR(J)
            ENDDO
          ENDIF
          CALL GRAIN_RATE_AND_MODULI (0,1,KGX,KKK,IPHEL,IPH)

      if(kkk.ge.301 .AND. kkk.le.305) then
      write(10,*)
      write(10,'('' xmctg after gr rate for grain'',i5)') kkk
      write(10,'(5e12.4)') xmctg(:,:,kgx)
      endif

          KGX=KGX+1
        ENDDO
      ENDDO

      DO I=1,5
        DAV(I)=0.
        SAV(I)=0.
        DO IPH=IPHBOT,IPHTOP
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          DAV(I)=DAV(I)+DG(I,KKK)*WGT(KKK)
          SAV(I)=SAV(I)+SG(I,KKK)*WGT(KKK)
        ENDDO
        ENDDO
      ENDDO

C     CALCULATE INITIAL GUESS FOR MACROSCOPIC MODULI 'Mtg' AS THE INVERSE
C     OF THE AVERAGE OF THE GRAIN'S STIFFNESSES

      DO I=1,5
        DZERO(I)=0.
        DO J=1,5
          XMTG(I,J)=0.
        ENDDO
      ENDDO

      KGX=1
      DO IPH=IPHBOT,IPHTOP
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        DO I=1,5
        DO J=1,5
          AUXTAN(I,J)=XMCTG(I,J,KGX)
        ENDDO
        ENDDO

c     if(kkk.ge.301 .AND. kkk.le.305) then
c     write(10,*)
c     write(10,'('' xmctg before lu inv for grain'',i5)') kkk
c     write(10,'(5e12.4)') auxtan
c     pause ' calling lu_inverse inside initial_state_guess'
c     endif

        CALL LU_INVERSE(AUXTAN,5)

        DO I=1,5
          DZERO(I)=DZERO(I)+DCZERO(I,KGX)*WGT(KKK)
          DO J=1,5
            XMTG(I,J)=XMTG(I,J)+AUXTAN(I,J)*WGT(KKK)
          ENDDO
        ENDDO

        KGX=KGX+1

      ENDDO
      ENDDO
cw
      xltg=xmtg

      CALL LU_INVERSE(XMTG,5)

c     write(10,*)
c     write(10,'('' leaving initial_state_guess'')')
c     write(10,'('' sav='',5e12.3)') sav
c     write(10,'('' dav='',5e12.3)') dav
c     write(10,'('' xmtg ='',5e12.3)') xmtg
c     write(10,*)

      RETURN
      END

CFEB
C ***************************************************************************
C     SUBROUTINE LANKFORD     --->      VERSION OF 05/APR/07
C
C     ROTATES RELEVANT TENSORS TO A SAMPLE SYSTEM COLINEAR WITH TENSILE STRES
C     CALCULATES LANKFORD COEFFICIENT VERSUS THE ANGLE BETWEEN THE ROLLING
C     DIRECTION AND THE STRESSING DIRECTION
C     CALCULATES DIRECTIONAL ELASTIC YOUNG MODULUS ALONG TENSILE DIRECTION.
C ***************************************************************************

      SUBROUTINE LANKFORD (ISTEP,DELTALANK,IOPTION)

      INCLUDE 'vpsc7.dim'

      DIMENSION ROTALPHA(3,3),AUX55(5,5),AUX3333(3,3,3,3)

      IU=15      ! UNIT FOR WRITING OUTPUT

C ************************************************************************
C    IF IOPTION=0 INITIALIZES RUN AND BOUNDARY CONDITIONS
C ************************************************************************

      IF(IOPTION.EQ.0) THEN

        IF(INTERACTION.LE.0) THEN
          WRITE(*,*)
          WRITE(*,*) 'CANNOT CALCULATE LANKFORD FOR FC OR RC CASE'
          WRITE(*,*) ' --> WILL RESET INTERACTION TO SECANT CASE'
          INTERACTION=2
          write(*,'("1")') 
          read(*,*)
        ENDIF

        WRITE(10,*)
        WRITE(10,'(''*** STARTS LANKFORD CALCULATION PROBING EVERY'',
     #               F10.2,'' DEGREES'')') DELTALANK

        NSTEPS=90./DELTALANK
        TINY=ABS(NSTEPS*DELTALANK-90.)
        IF(TINY .GT. 0.1) THEN
          DELTALANK=90./NSTEPS
          WRITE(*,*)
          WRITE(*,*) 'LANKFORD INTERVALS MUST ADD TO 90 DEGREES'
          WRITE(*,*) ' --> WILL RESET DELTALANK TO', DELTALANK
          write(*,'("1")') 
          read(*,*)
        ENDIF
        NSTEPS=NSTEPS+1

        ICTRL=1                   ! EPS(1,1) IS THE CONTROL COMPONENT
        STRAIN_CONTROL=1
        DO I=1,3
        DO J=1,3
          IUDOT(I,J)  =1
          UDOT(I,J)   =0.
          SCAUCHY(I,J)=0.
        ENDDO
        ENDDO
        IUDOT(2,2)=0
        IUDOT(3,3)=0
        UDOT (1,1)= 1.
        UDOT (2,2)=-0.5
        UDOT (3,3)=-0.5
        DO I=1,3
        DO J=1,3
          DSIM(I,J)=(UDOT(I,J)+UDOT(J,I))/2.
        ENDDO
        ENDDO

        DO I=1,6
          IDSIM(I)=1
          ISCAU(I)=0
        ENDDO
        IDSIM(2)=0
        IDSIM(3)=0
        ISCAU(2)=1
        ISCAU(3)=1

        CALL CHG_BASIS (DBAR,DSIM,AUX55,AUX3333,2,5)
        DBARNORM=VNORM(DBAR,5)
        DO I=1,5
          DBAR(I)=DBAR(I)/DBARNORM
        ENDDO
        CALL CHG_BASIS (DBAR,DSIM,AUX55,AUX3333,1,5)

      ENDIF

C ************************************************************************
C    IF IOPTION=1 EXPRESSES TEXTURE AND GRAIN SHAPE IN TENSILE AXES
C    AT AN ANGLE 'ALPHA' WITH RESPECT TO ROLLING DIRECTION.
C    'ROTALPHA' TRANSFORMS FROM PREVIOUS TO NEW TENSILE AXES.
C ************************************************************************

      IF(IOPTION.EQ.1) THEN

        IF(ISTEP.EQ.1) ALPHA=0.
        IF(ISTEP.GT.1) ALPHA=DELTALANK*PI/180.

        ROTALPHA(1,1)= COS(ALPHA)
        ROTALPHA(1,2)= SIN(ALPHA)
        ROTALPHA(1,3)= 0.
        ROTALPHA(2,1)=-SIN(ALPHA)
        ROTALPHA(2,2)= COS(ALPHA)
        ROTALPHA(2,3)= 0.
        ROTALPHA(3,1)= 0.
        ROTALPHA(3,2)= 0.
        ROTALPHA(3,3)= 1.

        CALL TEXTURE_ROTATION (ROTALPHA)

      ENDIF

C ************************************************************************
C    IF IOPTION=2 WRITES LANKFORD COEFFICIENT, DIAGONAL COMPONENTS OF THE
C    STRAIN RATE, AND TENSILE AND SHEAR STRESS (IN TENSILE SYSTEM).
C    CALCULATES DIRECTIONAL ELASTIC YOUNG MODULUS (OCT/9/03).
C    FOR THE LAST STEP RESETS TEXTURE AND GRAIN SHAPE BACK TO THE ORIGINAL
C    ROLLING AXES
C ************************************************************************

      IF(IOPTION.EQ.2) THEN

        CALL ELSC(0)      ! SC ELASTIC COMPLIANCE AND STIFFNESS TENSOR

        IF(ISTEP.EQ.1)
     #  WRITE(IU,'('' ANGLE     YOUNG     LANKF       D(1,1)    D(2,2)''
     #           ,''    D(3,3)    SCAU(1,1) SCAU(1,2)'')')
        ANGLE=DELTALANK*(ISTEP-1)
        IF(ABS(DSIM(3,3)/DSIM(1,1)).LE.1.E-06) THEN
          RLANK=999999.
        ELSE
          RLANK =DSIM(2,2)/DSIM(3,3)
        ENDIF
        WRITE(IU,'(F6.1,F10.1,F10.2,3X,3F10.4,3x,3F10.3,3X,3F10.3)')
     #      ANGLE,1./SSC(1,1),RLANK
     #     ,DSIM(1,1),DSIM(2,2),DSIM(3,3),SCAUCHY(1,1),SCAUCHY(1,2)
C     #      ,EULERPH(1,1),EULERPH(2,1),EULERPH(3,1)
C     #      ,AXISPH(0,1,1),AXISPH(0,2,1),AXISPH(0,3,1)

        IF(ISTEP .EQ. NSTEPS) THEN
          ALPHA=-PI/2.
          ROTALPHA(1,1)= COS(ALPHA)
          ROTALPHA(1,2)= SIN(ALPHA)
          ROTALPHA(1,3)= 0.
          ROTALPHA(2,1)=-SIN(ALPHA)
          ROTALPHA(2,2)= COS(ALPHA)
          ROTALPHA(2,3)= 0.
          ROTALPHA(3,1)= 0.
          ROTALPHA(3,2)= 0.
          ROTALPHA(3,3)= 1.
          CALL TEXTURE_ROTATION (ROTALPHA)
C         ERR=ERROLD
        ENDIF

      ENDIF
C ************************************************************************

      RETURN
      END

C ****************************************************************************
C     SUBROUTINE LOAD_CONDITIONS      -->      VERSION 07/DEC/2005
C
C     READS BOUNDARY CONDITIONS ON STRAIN RATE AND STRESS:
C        * NUMBER OF DEF STEPS, CONTROL VARIABLE, INCREMENT, TEMPERATURE
C        * IMPOSED AND RELAXED COMPONENTS OF VELOCITY GRADIENT AND STRESS
C     CALCULATES SYMMETRIC STRAIN RATE 'DSIM'
C     CALCULATES 5-DIM (TENTATIVE) VECTORS 'DBAR' AND 'SBAR'.
C     CHECKS WHETHER THE BOUNDARY CONDITIONS ARE CONSISTENT.
C ****************************************************************************

      SUBROUTINE LOAD_CONDITIONS (UNIT)

      INCLUDE 'vpsc7.dim'

      DIMENSION AUX55(5,5),AUX3333(3,3,3,3)
      DIMENSION IJV(6,2)
      DATA ((IJV(N,M),M=1,2),N=1,6)/1,1,2,2,3,3,2,3,1,3,1,2/
      INTEGER UNIT

C *** WRITES LOAD CONDITIONS FILE INTO 'RUN_LOG.OUT' FILE
      WRITE(10,*)
      WRITE(10,'(''*** LOAD CONDITIONS FOR THIS RUN'')')
      DO IDUM=1,100
        READ(UNIT=UNIT,END=100,FMT='(A)') PROSA
        WRITE(10,'(A)') PROSA
      ENDDO
  100 REWIND UNIT

      READ(UNIT,*) NSTEPS,ICTRL,CTRLINCR,TEMPERAT
      IF(CTRLINCR.LE.0) THEN
      WRITE(*,'('' STRAIN OR TIME INCREMENT (CTRLINCR) HAS TO BE'')')
      WRITE(*,'('' POSITIVE  --> THE SIGN OF THE DEFORMATION IS'')')
      WRITE(*,'('' CONTROLLED BY THE SIGN OF THE COMPONENT IMPOSED'')')
      STOP
      ENDIF

      READ(UNIT,*)
      DO I=1,3
        READ(UNIT,*) (IUDOT(I,J),J=1,3)
      ENDDO
      READ(UNIT,*)
      DO I=1,3
        READ(UNIT,*) (UDOT(I,J),J=1,3)
      ENDDO
      READ(UNIT,*)
      READ(UNIT,*) ISCAU(1),ISCAU(6),ISCAU(5)
      READ(UNIT,*)          ISCAU(2),ISCAU(4)
      READ(UNIT,*)                   ISCAU(3)
      READ(UNIT,*)
      READ(UNIT,*) SCAUCHY(1,1),SCAUCHY(1,2),SCAUCHY(1,3)
      READ(UNIT,*)              SCAUCHY(2,2),SCAUCHY(2,3)
      READ(UNIT,*)                           SCAUCHY(3,3)

      SCAUCHY(3,2)=SCAUCHY(2,3)
      SCAUCHY(3,1)=SCAUCHY(1,3)
      SCAUCHY(2,1)=SCAUCHY(1,2)

C *** CALC SYM STRAIN-RATE TENSOR AND IDENTIFY INDICES OF IMPOSED COMPONENTS
      DO I=1,3
        DO J=1,3
          DSIM(I,J)=(UDOT(I,J)+UDOT(J,I))/2.
        ENDDO
      ENDDO
      IDSIM(1)=IUDOT(1,1)
      IDSIM(2)=IUDOT(2,2)
      IDSIM(3)=IUDOT(3,3)
      IDSIM(4)=IUDOT(2,3)*IUDOT(3,2)
      IDSIM(5)=IUDOT(1,3)*IUDOT(3,1)
      IDSIM(6)=IUDOT(1,2)*IUDOT(2,1)

C *** WRITES 5-DIM REPRESENT OF MACRO STRAIN RATE 'DSIM' AND STRESS 'SCAUCHY'.
C     BOTH VECTORS ARE NOT REQUIRED SIMULTANEOUSLY. THEY ARE USED TO MAKE
C     AN INITIAL GUESS FOR THE FIRST STEP OF THE SC PROCEDURE.

      CALL CHG_BASIS(DBAR,DSIM,AUX55,AUX3333,2,5)
      CALL CHG_BASIS(SBAR,SCAUCHY,AUX55,AUX3333,2,5)
      DBARNORM=VNORM(DBAR,5)
      SBARNORM=VNORM(SBAR,5)

      IF(ICTRL.EQ.0) THEN
        IF(DBARNORM.NE.0.) STRAIN_CONTROL=1
        IF(DBARNORM.EQ.0.) THEN
          WRITE(*,*) 'CAN CONTROL VON MISES ONLY IF STRAIN IS IMPOSED !'
          STOP
        ENDIF
      ELSE IF(ICTRL.GE.1 .AND. ICTRL.LE.6) THEN
        IF(IDSIM(ICTRL).EQ.1 .AND. DBARNORM.NE.0.) STRAIN_CONTROL=1
        IF(ISCAU(ICTRL).EQ.1 .AND. SBARNORM.NE.0.) STRAIN_CONTROL=0
      ELSE IF(ICTRL.EQ.7) THEN
        IF(DBARNORM.NE.0.) STRAIN_CONTROL=1
      ENDIF

C *** CHECKS WHETHER THE BOUNDARY CONDITIONS ARE CONSISTENT.

      if(iudot(1,1)+iudot(2,2)+iudot(3,3).eq.2) then
        write(*,*) 'WARNING: CHECK DIAGONAL BOUNDARY CONDITIONS IUDOT'
        write(*,*) '         ENFORCING TWO DEVIATORIC COMPONENTS FIXES'
        write(*,*) '         THE OTHER BECAUSE OF INCOMPRESSIBILITY'
        write(*,'("1")') 
        read(*,*)
      endif

      do i=1,2
      do j=i+1,3
        if(iudot(i,j)+iudot(j,i).eq.0) then
          write(*,*) 'CHECK OFF-DIAGONAL BOUNDARY CONDITIONS IUDOT'
          write(*,*) 'CANNOT RELAX BOTH OFF-DIAGONAL COMPONENTS'
          stop
        endif
      enddo
      enddo

      DILAT=UDOT(1,1)+UDOT(2,2)+UDOT(3,3)
      IF(DILAT.GT.1.E-6) THEN
        WRITE(*,*) 'CHECK DIAGONAL STRAIN RATE COMPONENTS UDOT'
        WRITE(*,*) 'THE IMPOSED RATE IS NOT INCOMPRESSIBLE'
        STOP
      ENDIF

      DO I=1,6
        IF(ISCAU(I)*IDSIM(I).NE.0 .OR. ISCAU(I)+IDSIM(I).NE.1) THEN
          WRITE(*,*) ' CHECK BOUNDARY CONDITS ON STRAIN-RATE AND STRESS'
          WRITE(*,'('' IDSIM = '',6I3)') IDSIM
          WRITE(*,'('' ISCAU = '',6I3)') ISCAU
          STOP
        ENDIF
      ENDDO

C *** DEFINES CONTROLLING INCREMENT AND ESTIMATES TIME INCREMENT.
C *** ULTIMATE 'TINCR' WILL BE CALCULATED AT THE END OF EACH STEP.

      IF(ICTRL.EQ.0 .AND. STRAIN_CONTROL.EQ.1) THEN
        EVMINCR=CTRLINCR
        TINCR  =EVMINCR/VNORM(DBAR,5)
      ELSE IF(ICTRL.GE.1.AND.ICTRL.LE.6.AND.STRAIN_CONTROL.EQ.1) THEN
        EIJINCR=CTRLINCR
        DSIMCTRL=DSIM(IJV(ictrl,1),IJV(ictrl,2))
        TINCR  =EIJINCR/ABS(DSIMCTRL)
        IF(.NOT.(IDSIM(ICTRL).EQ.1. AND. DSIMCTRL.NE.0.)) THEN
          WRITE(*,*) 'ICTRL        =',ICTRL
          WRITE(*,*) 'IDSIM(ICTRL) =',IDSIM(ICTRL)
          WRITE(*,*) 'DSIM (ICRTL) =',DSIMCTRL
          WRITE(*,*) 'ICTRL MUST BE 0 TO CONTROL VON MISES INCREMENT'
          WRITE(*,*) 'OR IT MUST IDENTIFY A NON-ZERO STRAIN COMPONENT'
          WRITE(*,*) 'OR IT MUST BE 7 TO IMPOSE DSIM*TINCR'
          STOP
        ENDIF
      ELSE IF(ICTRL.EQ.7 .OR. STRAIN_CONTROL.EQ.0) THEN
        TINCR=CTRLINCR
      ENDIF

      ISCAUSUM=ISCAU(1)+ISCAU(2)+ISCAU(3)+ISCAU(4)+ISCAU(5)+ISCAU(6)
      IF(INTERACTION.LE.0 .AND. ISCAUSUM.NE.0) THEN
        WRITE(*,*) ' CANNOT IMPOSE STRESS COMPONENTS FOR FC or RC CASE'
        STOP
      ENDIF

      IF(IDSIM(1)*IDSIM(2)*IDSIM(3).EQ.1 .AND. ICAUCHY.EQ.1) THEN
        WRITE(*,'('' CANNOT CALCULATE CAUCHY STRESSES FOR FULLY'',
     #      '' IMPOSED DIAGONAL COMPONENTS'',/,
     #      ''  --> WILL ASSUME ZERO OVERALL PRESSURE (PREMAC)'')')
        write(*,'("1")') 
        read(*,*)
      ENDIF

      RETURN
      END

CFEE

C *************************************************************************

      SUBROUTINE LU_INVERSE (A,N)

C *** INVERTS A MATRIX USING LU DECOMPOSITION

      DIMENSION A(N,N),Y(N,N),INDX(N)      ! MAY CHOKE SOME COMPILERS
C     DIMENSION A(5,5),Y(5,5),INDX(5)


c     write(*,*) 'A(i,j) matrix inside lu_inverse'
c     write(*,'(5e12.3)') ((a(i,j),j=1,n),i=1,n)
c     pause

C **************************************************************
C *** BLOCK ADDED 03/DEC/05 TO AVOID NUMERICALLY SINGULAR MATRIX
      AMAX=0.D0
      DO I=1,N
      DO J=1,N
        DUM=ABS(A(I,J))
        IF(DUM .GT. AMAX) AMAX=DUM
      ENDDO
      ENDDO
      DO I=1,N
      DO J=1,N
        A(I,J)=A(I,J)/AMAX      ! normalize the matrix
      ENDDO
      ENDDO
C **************************************************************

      DO I=1,N
        DO J=1,N
          Y(I,J)=0.
        ENDDO
        Y(I,I)=1.
      ENDDO

      CALL LUDCMP(A,N,N,INDX,D,ISINGULAR)
      IF(ISINGULAR.EQ.1) THEN
        WRITE(*,*) ' *** SINGULAR MATRIX IN LU_INVERSE !!'
        STOP
      ENDIF

      DO J=1,N
        CALL LUBKSB(A,N,N,INDX,Y(1,J))
      ENDDO

      DO I=1,N
      DO J=1,N
        A(I,J)=Y(I,J) /AMAX      ! renormalize the inverse
      ENDDO
      ENDDO

      RETURN
      END

C *************************************************************************

      SUBROUTINE LU_EQSYSTEM(A,B,N,ISINGULAR)

C *** SOLVES A*X=B USING LU DECOMPOSITION

      DIMENSION A(N,N),B(N),INDX(N)      ! MAY CHOKE SOME COMPILERS
C     DIMENSION A(5,5),B(5),INDX(5)

      CALL LUDCMP(A,N,N,INDX,D,ISINGULAR)

      IF(ISINGULAR.EQ.1) RETURN

      CALL LUBKSB(A,N,N,INDX,B)

      RETURN
      END
C
C ***********************************************************
      SUBROUTINE LU_EQSYS25(A,B,N,ISINGULAR)

C *** SOLVES A*X=B USING LU DECOMPOSITION

c      DIMENSION A(N,N),B(N),INDX(N)      ! MAY CHOKE SOME COMPILERS
      DIMENSION A(25,25),B(25),INDX(25)

      CALL LUDCMP(A,N,N,INDX,D,ISINGULAR)
c
      do j=1,25
      d=d*a(j,j)
      enddo

c      write(*,*) 'DET25=',d
c      pause

      IF(ISINGULAR.EQ.1) RETURN

      CALL LUBKSB(A,N,N,INDX,B)

      RETURN
      END
C
C ***************************************************************************
C     SUBROUTINE NEIGHBOURS      --->      VERSION 25/JUL/2002
C
C *** IDENTIFIES 'NNEIGH' NEIGHBORS FOR EVERY GRAIN AND ASSIGNS WEIGHTS
C     'WNEIGH' WHICH ARE GOING TO BE USED EXCLUSIVELY FOR CO-ROTATION
C     PURPOSES INSIDE SUBROUTINE UPDATE_ORIENTATION.
C *** IF IOPTION=0 DEFINES NEIGHBORS FOR EACH GRAIN PICKED AT RANDOM FROM
C     ORIENTATION FILE (REORIENTATION WORKS ALSO FOR MULTIELEMENT RUN)
C *** IF IOPTION=1 DEFINES NEIGHBORS FOR A TWO PHASE MATERIAL WHERE THE
C     SECOND PHASE IS CRYSTALLOGRAPHICALLY ASSOCIATED TO THE FIRST PHASE
C     (i.e.: MATRIX/TWIN or PARENT/CHILD IN RECRYSTALLIZATION)
C ***************************************************************************

      SUBROUTINE NEIGHBOURS (IOPTION)

      INCLUDE 'vpsc7.dim'

      DIMENSION WAUX(0:NNEIMX)


      DO I=0,NNEIGH
        WAUX(I)=1./(NNEIGH+1)       ! DEFINES EQUAL CO-ROTATION WGT's
      ENDDO

      DO KGX=1,NGR(NPH)             ! SCANS ALL GRAINS IN ALL PHASES

        NEIGH(0,KGX)=KGX            ! NEIGHBOR ZERO IS THE GRAIN ITSELF
        WTOT=WGT(KGX)*WAUX(0)

        IF(NNEIGH.GT.0) THEN

          IF(IOPTION.EQ.0) THEN             ! PICK NEIGHBOURS AT RANDOM
            DO I=1,NNEIGH
              RAND=RAN2(JRAN)
              NEIGH(I,KGX)=INT(RAND*NGR(NPH)+1)
              WTOT=WTOT+WGT(NEIGH(I,KGX))*WAUX(I)
            ENDDO
          ELSE IF(IOPTION.EQ.1) THEN        ! PICK NEIGHBOURS IN ORDER
            IF (KGX.LE.NGR(1)) NEIGH(1,KGX)=KGX+NGR(1)
            IF (KGX.GT.NGR(1)) NEIGH(1,KGX)=KGX-NGR(1)
            WTOT=WTOT+WGT(NEIGH(1,KGX))*WAUX(1)
          ENDIF

        ENDIF

C *** NORMALIZATION OF CO-ROTATION WGT's

        IF(WTOT.LT.1.E-10) THEN
          DO I=0,NNEIGH
            WNEIGH(I,KGX)=0.
          ENDDO
        ELSE
          DO I=0,NNEIGH
            WNEIGH(I,KGX)=WAUX(I)*WGT(NEIGH(I,KGX))/WTOT
          ENDDO
        ENDIF

      ENDDO       !  END LOOP OVER ORIENTATIONS

      END
C
C ***************************************************************************
C
C     SUBROUTINE NEWTON_RAPHSON (ex SNLNR)   --->   VERSION APR/2003
C
C     GIVEN AN INPUT GRAIN STRESS 'X' SOLVES THE VISCOPLASTIC EQUATION
C     USING NEWTON-RAPHSON LINEARIZATION AND ITERATING UNTIL CONVERGENCE.
C     - Fi(X)   : ARE THE FUNCTIONS TO MINIMIZE.
C     - FGRADij : ARE THE DERIVATIVES OF Fi WITH RESPECT TO Xj.
C     CORRECTIONS TO 'X' AND RELAXATION OF TOLERANCE ELIMINATED (FEB/2000).
C     PASSING ALL RELEVANT CRYSTAL ARRAYS THROUGH COMMON (13/DEC/02).
C     ADDED RELAXED CONSTRAINTS OPTION (IRC=1) (APR/03)
C
C ***************************************************************************

      SUBROUTINE NEWTON_RAPHSON (X,IRC,KMAX,EPS,TAULIM,IERROR ,iprx)

      INCLUDE 'vpsc7.dim'

      DIMENSION FGRAD(5,5),F(5),FGRADX(3,3),FX(3),X(5),XOLD(5)
      DIMENSION RSS(NSYSMX),GD(NSYSMX)
      COMMON/NLNR /DB(5),XMASTX(5,5),SCX(5,NSYSMX),TAUX(NSYSMX),
     #             GAMD0X(NSYSMX),NSYSTX,NRSX(NSYSMX),ISENSEX(NSYSMX)

      COEF=0.2
      IERROR=0

c     write(*,*) 'entering newton-raphson'
c     pause

      DO 1000 K=1,KMAX

C *** RESOLVED SHEARS CALCULATION & OUTSIDE Y.S. ERROR MANAGING BLOCK.
C *** NRS MAY BE EVEN OR ODD:
C     GD ALWAYS > 0 --> GD IS USED TO GET DERIVATIVES TO BUILD THE
C     COEFFICIENT MATRIX FOR N-R METHOD IN F(I) CALCULATION (INDEPENDENT
C     TERM FOR N-R METHOD)   RSS*GD=GAMDOT -> SIGN(RSS*GD)=SIGN(RSS)

        DO IS=1,NSYSTX
          RSS(IS)=SCX(1,IS)*X(1)+SCX(2,IS)*X(2)+SCX(3,IS)*X(3)
     #           +SCX(4,IS)*X(4)+SCX(5,IS)*X(5)
          IF(.NOT.(RSS(IS).GT.0. .OR. ISENSEX(IS).EQ.1)) RSS(IS)=0.
          RSS(IS)=RSS(IS)/TAUX(IS)
          IF(ABS(RSS(IS)).LT.1.E-10) RSS(IS)=0.

cpp          write(*,*) 'X=',x
cpp          write(*,*) 'K,IS,RSS(IS)=',k,is,rss(is)
cpp          pause

          GD(IS)=GAMD0X(IS)
          IF(NRSX(IS).NE.1) GD(IS)=GD(IS)*ABS(RSS(IS)**(NRSX(IS)-1))

          IF(ABS(RSS(IS)).GT.TAULIM) THEN
            DO I=1,5
              X(I)=XOLD(I)+COEF*(X(I)-XOLD(I))
            ENDDO
            GO TO 1000
          ENDIF
        ENDDO

c       if(iprx.eq.1) then
c         write( *,'('' db & rss='',5f10.4)') db
c         write( *,'(6f10.4)') (rss(is),is=1,nsystx)
c         write(10,'('' db & rss='',5f10.4)') db
c         write(10,'(6f10.4)') (rss(is),is=1,nsystx)
c         write(*,'(''nrsx & xmast='',30i3)') (nrsx(is),is=1,nsystx)
c         write(*,'(5f13.7)') ((xmastx(i,j),j=1,5),i=1,5)
c       endif

        DO I=1,5
          F(I)=-DB(I)
          DO J=1,5
            F(I)=F(I)+XMASTX(I,J)*X(J)
          ENDDO
        ENDDO
        DO I=1,5
          DO IS=1,NSYSTX
            F(I)=F(I)+SCX(I,IS)*RSS(IS)*GD(IS)
          ENDDO
        ENDDO
        DO I=1,5
          DO J=1,5
            FGRAD(I,J)=-XMASTX(I,J)
          ENDDO
        ENDDO

        DO IS=1,NSYSTX
          SFACTOR=NRSX(IS)*GD(IS)/TAUX(IS)
          DO I=1,5
          DO J=1,5
            FGRAD(I,J)=FGRAD(I,J)-SFACTOR*SCX(I,IS)*SCX(J,IS)
          ENDDO
          ENDDO
        ENDDO

        DO I=1,5
          XOLD(I)=X(I)
        ENDDO

C *** SOLVES LINEAR SYSTEM
        IF(IRC.EQ.0) THEN

          if(iprx.eq.1) then
            write(10,'('' f    ='',5e12.3)') f
            write(10,'('' fgrad='',5e12.3,/,(6x,5e12.3))') fgrad
          endif

          CALL LU_EQSYSTEM (FGRAD,F,5,ISINGULAR)
          IF(ISINGULAR.EQ.1) THEN
            if(iprx.eq.1) then
              write( *,'('' f    ='',5e12.3)') f
              write( *,'('' fgrad='',5e12.3,/,(6x,5e12.3))') fgrad
              write(10,'('' f    ='',5e12.3)') f
              write(10,'('' fgrad='',5e12.3,/,(6x,5e12.3))') fgrad
            endif
            IERROR=1
            RETURN
          ENDIF

CFEB
C *** BOUNDS THE STRESS CORRECTION TO AVOID LARGE OSCILATIONS IN CONVERGENCE
c         if(iprx.eq.1) then
c         rcorr=VNORM(F,5)/VNORM(XOLD,5)
c         write(10,'(''*** NR correction'',5f9.3,f12.5)')
c    #                 (f(i),i=1,5),rcorr
c         endif
CFEE

          DO I=1,5
            X(I)=XOLD(I)+F(I)
          ENDDO
        ENDIF

C **********************************************************************
C *** THIS BLOCK IS FOR RELAXED CONSTRAINTS CASE (NOT A STANDARD OPTION)
        IF(IRC.EQ.1) THEN
          FX(1)=F(1)
          FX(2)=F(2)
          FX(3)=F(5)
          FGRADX(1,1)=FGRAD(1,1)
          FGRADX(1,2)=FGRAD(1,2)
          FGRADX(1,3)=FGRAD(1,5)
          FGRADX(2,1)=FGRAD(2,1)
          FGRADX(2,2)=FGRAD(2,2)
          FGRADX(2,3)=FGRAD(2,5)
          FGRADX(3,1)=FGRAD(5,1)
          FGRADX(3,2)=FGRAD(5,2)
          FGRADX(3,3)=FGRAD(5,5)
          CALL LU_EQSYSTEM (FGRADX,FX,3,ISINGULAR)
          IF(ISINGULAR.EQ.1) THEN
            IERROR=1
            RETURN
          ENDIF
          X(1)=XOLD(1)+FX(1)
          X(2)=XOLD(2)+FX(2)
          X(3)=0.
          X(4)=0.
          X(5)=XOLD(5)+FX(3)
        ENDIF
C **********************************************************************

        RERROR=VMISMATCH(X,XOLD,5)
        IF(RERROR.LT.EPS) RETURN

1000  CONTINUE      ! END OF MASTER DO
C *******************************************************************

      IERROR=2

      RETURN
      END
C
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
C     SUBROUTINE NORMALIZE   ---->   VERSION 26/MAY/2000
C
C     NORMALIZES IN ORDER TO WORK WITH MAGNITUDES OF ORDER ONE.
C     THIS NORMALIZATION APPLIES TO ALL MAGNITUDES WITH UNITS OF [rate],
C     [stress] AND [rate/stress]
C       IF NRMOPTION=0 ==> NORMALIZES
C       IF NRMOPTION=1 ==> RENORMALIZES TO ORIGINAL UNITS
C
C     SUPERSEDED BY MORE SPECIFIC ROUTINES SCALE_1 AND SCALE_2 (MAY/2000)
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      SUBROUTINE NORMALIZE (NRMOPTION,ISTEP)

      INCLUDE 'vpsc7.dim'

      SAVE DFACTOR,SFACTOR,XFACTOR

C *** DEFINES THE REFERENCES FOR THE STRESS, STRAIN RATE & COMPLIANCES.

      IF (NRMOPTION.EQ.0) THEN
        DFACTOR=VNORM(DBAR,5)/3.
        IF(ISTEP.EQ.1.AND.IRECOVER.EQ.0) THEN
C         SFACTOR=TAU(1,0,1)
          SFACTOR=VNORM(SBAR,5)/3.     ! added dec 02 2005 to try
        ELSE
          SFACTOR=VNORM(SAV,5)/3.
        ENDIF
        SFACTOR=SFACTOR*(DFACTOR/GAMD0g(1))**(1./NRS(1,1))
        XFACTOR=DFACTOR/SFACTOR

        DFACTOR=1./DFACTOR
        SFACTOR=1./SFACTOR
        XFACTOR=1./XFACTOR
      ENDIF

      IF (NRMOPTION.EQ.1) THEN
        DFACTOR=1./DFACTOR
        SFACTOR=1./SFACTOR
        XFACTOR=1./XFACTOR
      ENDIF

C *** NORMALIZES STATES, MODULI AND PARAMETERS WHEN NRMOPTION=0
C *** RE-NORMALIZES STATES, MODULI AND PARAMETERS WHEN NRMOPTION=1

        SVM =SVM *SFACTOR
        DVM =DVM *DFACTOR
      DO I=1,5
        SAV(I) =SAV(I) *SFACTOR
        SBAR(I)=SBAR(I)*SFACTOR
        DAV(I) =DAV(I) *DFACTOR
        DBAR(I)=DBAR(I)*DFACTOR
cnt  --> need to normalize Dzero and Dczero ??
        DO J=1,5
          XMTG(I,J)=XMTG(I,J)*XFACTOR
        ENDDO
      ENDDO

      DO I=1,5
        KGX=1
        DO IPH=IPHBOT,IPHTOP
CFEB
          D5PH(I,IPH)=D5PH(I,IPH)/XFACTOR
CFEE
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          SG(I,KKK)  =SG(I,KKK)  *SFACTOR
          DG(I,KGX)  =DG(I,KGX)  *DFACTOR
CFEB
          D5GR(I,KKK)=D5GR(I,KKK)/XFACTOR
CFEE
          KGX=KGX+1
        ENDDO
        ENDDO
      ENDDO

      DO I=1,3
        DO J=1,3
          UDOT(I,J)   =UDOT(I,J)   *DFACTOR
          DSIM(I,J)   =DSIM(I,J)   *DFACTOR
          ROTBAR(I,J) =ROTBAR(I,J) *DFACTOR
          SCAUCHY(I,J)=SCAUCHY(I,J)*SFACTOR
          SDEVIAT(I,J)=SDEVIAT(I,J)*SFACTOR
        ENDDO
      ENDDO

      KGX=1
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          GAMD0G(KGX)=GAMD0G(KGX)          *DFACTOR
          DO NS=1,NSYST(IPHEL)
            GAMDOT(NS,KGX)=GAMDOT(NS,KGX)  *DFACTOR
            CRSS(NS,KKK)  =CRSS(NS,KKK)    *SFACTOR
          ENDDO
          KGX=KGX+1
        ENDDO
      ENDDO

      RETURN
      END
CFEB
C *********************************************************************
C     SUBROUTINE PCYS      --->      VERSION 10/JAN/2009
C
C  IF IOPTION=0 GENERATES AND STORES EQUISPACED STRAIN-RATE VECTORS TO
C     PROBE THE POLYCRYSTAL YIELD SURFACE IN A SUBSPACE
C  IF IOPTION=1 FEEDS 'DBAR' FOR EACH PROBING STEP
C  IF IOPTION=2 NORMALIZES STRESS 'SPCYS' AND RATE 'DPCYS' IN ORDER TO
C     FOR EACH POINT OF THE PCYS TO REPRESENT THE SAME DISSIPATION RATE
C     ARBITRARILY CHOSEN HERE TO BE =1.
C *********************************************************************

      SUBROUTINE PCYS (ISTEP,INDX,INDY,IOPTION)

      INCLUDE 'vpsc7.dim'

      PARAMETER(NPROBEMX=36)

      DIMENSION ITHETA(2,5),UNITDIR(5),AUX55(5,5),AUX3333(3,3,3,3)
      DIMENSION STRAINR(5,NPROBEMX),DPCYS(2,NPROBEMX),SPCYS(2,NPROBEMX)
      SAVE      STRAINR,DPCYS,SPCYS,NPART,WRATEREF,STNORM,NPROBES

      IU=14      ! UNIT FOR WRITING OUTPUT INTO 'PCYS.OUT'

C ********************************************************************
      IF(IOPTION.EQ.0) THEN

        WRITE(10,*)
        WRITE(10,*) '******* STARTS A PCYS CALCULATION *******'
        WRITE(10,*)
        IF(ICS.EQ.1) WRITE(10,*) 'CENTRO-SYMMETRIC YIELD SURFACE'
        IF(ICS.EQ.0) WRITE(10,*) 'NON CENTRO-SYMMETRIC YIELD SURFACE'

        DMOD=1
        WRITE(10,*)
        WRITE(10,*) 'NORM OF STRAIN-RATE PROBES IS HARDWIRED TO 1'

        WRITE(10,*)
        WRITE(10,'(''WILL CALCULATE A'',2I4,''   PCYS PROJECTION'')')
     #             INDX,INDY
        WRITE(10,*) 'INDICES OF THE COMPONENTS DEFINING STRESS SPACE'
        WRITE(10,*) '   1 = (S22-S11)/SQRT(2)'
        WRITE(10,*) '   2 = (2*S33-S22-S11)/SQRT(6)'
        WRITE(10,*) '   3 = S23*SQRT(2)'
        WRITE(10,*) '   4 = S13*SQRT(2)'
        WRITE(10,*) '   5 = S12*SQRT(2)'
        WRITE(10,*)

        IF(INDX.EQ.INDY) THEN
          WRITE(*,*) 'INDICES HAVE TO BE DIFFERENT'
          STOP
        ELSE IF(INDX.GT.INDY) THEN
          IAUX=INDX
          INDX=INDY
          INDY=IAUX
        ENDIF

        NPART=NPROBEMX/4
        DANG=PI/2.D0/NPART

C *********************************************************************
C     GENERATES EQUISPACED UNIT STRAIN-RATE VECTORS (b-BASIS REPRESENT).
C        NPART= # OF PARTITIONS IN EACH INTERVAL [0,PI/2]'
C        FOR NON-CENTRO SYMMETRIC PROPERTIES (ICS=0) SCANS -PI<THETA<PI
C        FOR     CENTRO SYMMETRIC PROPERTIES (ICS=1) SCANS   0<THETA<PI
C        WHEN THETA(1,i)=THETA(2,i)=PI/2  --> UNITDIR(i)=0
C *********************************************************************

      DO I=1,5
        ITHETA(1,I)=NPART
        ITHETA(2,I)=NPART
      ENDDO
      ITHETA(1,INDX)=0
      ITHETA(2,INDX)=0
      ITHETA(1,INDY)=2*NPART*(-1+ICS)
      ITHETA(2,INDY)=2*NPART-1

      NPROBES=0

      DO 100 ITH5=ITHETA(1,5),ITHETA(2,5)
        THETA5=ITH5*DANG
        COSTH5=COS(THETA5)
        SINTH5=SIN(THETA5)

      DO 100 ITH4=ITHETA(1,4),ITHETA(2,4)
        THETA4=ITH4*DANG
        COSTH4=COS(THETA4)
        SINTH4=SIN(THETA4)

      DO 100 ITH3=ITHETA(1,3),ITHETA(2,3)
        THETA3=ITH3*DANG
        COSTH3=COS(THETA3)
        SINTH3=SIN(THETA3)

      DO 100 ITH2=ITHETA(1,2),ITHETA(2,2)
        THETA2=ITH2*DANG
        COSTH2=COS(THETA2)
        SINTH2=SIN(THETA2)

      DO 100 ITH1=ITHETA(1,1),ITHETA(2,1)
        THETA1=ITH1*DANG
        COSTH1=COS(THETA1)      ! CAN ADOPT ONLY VALUES 1 OR 0

        NPROBES=NPROBES+1

C *** CALCULATES NORMALIZED VECTOR COMPONENTS IN 5-D SPACE.

      UNITDIR(1)= COSTH1*SINTH2*SINTH3*SINTH4*SINTH5
      UNITDIR(2)=        COSTH2*SINTH3*SINTH4*SINTH5
      UNITDIR(3)=               COSTH3*SINTH4*SINTH5
      UNITDIR(4)=                      COSTH4*SINTH5
      UNITDIR(5)=                             COSTH5

      DO I=1,5
        STRAINR(I,NPROBES)=DMOD*UNITDIR(I)
      ENDDO

C *** AVOID RECALCULATING FOR REDUNDANT COMBINATIONS
C *** (i.e. IF THETA(5)=0 THEN UNIT1=UNIT2=UNIT3=UNIT4=0 INDEPENDENT OF
C *** THE VALUE OF ITH1,ITH2,ITH3,ITH4)
C
C     IF(ITH5.EQ.0 .AND. ITH4.NE.0)
C         RESPONSE(ITH2,ITH3,ITH4,ITH5,I)=RESPONSE(ITH2INI,0,0,0,I)
C
C     IF(ITH4.EQ.0 .AND. ITH3.NE.0)
C         RESPONSE(ITH2,ITH3,ITH4,ITH5,I)=RESPONSE(ITH2INI,0,0,ITH5,I)
C
C     IF(ITH3.EQ.0 .AND. ITH2.NE.ITH2INI)
C        RESPONSE(ITH2,ITH3,ITH4,ITH5,I)=RESPONSE(ITH2INI,0,ITH4,ITH5,I)

  100 CONTINUE

C *** HARDWIRED RUN OPTIONS: FULLY IMPOSED STRAIN RATE

        STRAIN_CONTROL=1
        DO I=1,3
        DO J=1,3
          IUDOT(I,J)=1
          SCAUCHY(I,J)=0.
        ENDDO
        ENDDO
        DO I=1,6
          IDSIM(I)=1
          ISCAU(I)=0
        ENDDO
        NSTEPS=NPROBES

      ENDIF      ! END OF IOPTION=0 TO GENERATE EQUISPACED RATE VECTORS

C ***************************************************************************
C     DEFINE THE STRAIN-RATE PROBE 'DBAR' FOR THE STEP

      IF(IOPTION.EQ.1) THEN
        DO I=1,5
          DBAR(I)=STRAINR(I,ISTEP)
        ENDDO
        CALL CHG_BASIS(DBAR,DSIM,AUX55,AUX3333,1,5)
C       WRITE(IU,'(I5,5F10.3)') ISTEP,DBAR
      ENDIF
C ***************************************************************************
C *** STORES THE RESPONSE 'SAV' TO IMPOSED STRAIN-RATE 'DBAR'.
C *** POINTS OF THE PCYS ARE NORMALIZED TO THE SAME DISSIPATION RATE
C     (WRATEREF) ARBITRARILY TAKEN AS WRATEREF=1.
C *** SUPPRESSED NORMALIZING THE STRESS TO THE FIRST POINT IN THE SECTION
C     BECAUSE IT PREVENTS COMPARING LOCI OF DIFFERENT SECTIONS.
C *** A POSSIBILITY IS TO NORMALIZE TO THE INITIAL CRSS OF THE FIRST SYSTEM
C     IN THE FIRST PHASE: STNORM=TAU(1,0,1)

      IF(IOPTION.EQ.2) THEN

C       WRITE(IU,'(''DBAR'',I5,5F10.3)') ISTEP,DBAR
C       WRITE(IU,'(''DAV '',I5,5F10.3)') ISTEP,DAV

        WRATEREF=1.
        STNORM=1.
C       STNORM=TAU(1,0,1)    ! NORMALIZE TO THE initial CRSS OF THE 1st SYSTEM

        NRSX=NRS(1,1)
        IF(NUNIQUE.EQ.1) THEN
          WRATE=0.0
          DO I=1,5
            WRATE=WRATE+DAV(I)*SAV(I)
          ENDDO
          SCALEF=(WRATEREF/WRATE)**(NRSX/(1.+NRSX))
        ELSE
          SCALEF=1.
        ENDIF

C *** CARTESIAN COMPONENTS OF RATE AND STRESS DEFINING PCYS PROJECTION
        DPCYS(1,ISTEP)= DAV(INDX) *SCALEF
        DPCYS(2,ISTEP)= DAV(INDY) *SCALEF
        SPCYS(1,ISTEP)= SAV(INDX) *SCALEF**(1./NRSX) /STNORM
        SPCYS(2,ISTEP)= SAV(INDY) *SCALEF**(1./NRSX) /STNORM

C *** STORES OPPOSITE STATE FOR CENTRO-SYMMETRIC YIELD SURFACE.
        IF(ICS.EQ.1) THEN
          DPCYS(1,ISTEP+NPROBES)=-DPCYS(1,ISTEP)
          DPCYS(2,ISTEP+NPROBES)=-DPCYS(2,ISTEP)
          SPCYS(1,ISTEP+NPROBES)=-SPCYS(1,ISTEP)
          SPCYS(2,ISTEP+NPROBES)=-SPCYS(2,ISTEP)
        ENDIF

        IF(ISTEP.EQ.NSTEPS) THEN
          WRITE(IU,'(10X,''S'',I1,10X,''S'',I1,10X''D'',I1,10X,''D'',
     #                         I1)') INDX,INDY,INDX,INDY
          WRITE(IU,'(4E12.4)')
     #         (SPCYS(1,J),SPCYS(2,J),DPCYS(1,J),DPCYS(2,J),J=1,4*NPART)
        ENDIF

      ENDIF      ! END OF IOPTION=2

      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE PCYS_IT      --->      VERSION 04/OCT/2011
C
C     IOPTION=0: GENERATES AND STORES EQUISPACED STRAIN-RATE OR STRESS
C                VECTORS IN 5D DEVIATORIC SPACE TO PROBE THE
C                POLYCRYSTAL YIELD SURFACE.
C     IOPTION=1: DEFINES 'DBAR' OR 'SBAR' TO BE IMPOSED AT EACH PROBING STEP.
C     IOPTION=2: STORES RATE OT STRESS (REACTION) IN INTERPOLATION TABLE.
C **************************************************************************

      SUBROUTINE PCYS_IT (ISTEP,ISKIP,IOPTION)

      INCLUDE 'vpsc7.dim'

      PARAMETER(NPRBMX=20000)

      DIMENSION ITHETA(2,4),AUX55(5,5),AUX3333(3,3,3,3)
      COMMON/TABLE/ACTION  (0:12,0:6,0:6,0:6,5),
     #             REACTION(0:12,0:6,0:6,0:6,5),
     #             THGRID(4,NPRBMX),ITHGRID(4,NPRBMX)
      SAVE ITABLE

      IU=14      ! UNIT FOR WRITING OUTPUT INTO 'PCYS.OUT'

C ********************************************************************
      IF(IOPTION.EQ.0) THEN

        WRITE(10,*)
        WRITE(10,*) '******* STARTS A PCYS CALCULATION *******'
        WRITE(10,*)
        IF(ICS.EQ.1) WRITE(10,*) 'CENTRO-SYMMETRIC YIELD SURFACE'
        IF(ICS.EQ.0) WRITE(10,*) 'NON CENTRO-SYMMETRIC YIELD SURFACE'

        WRITE(*,*)
        WRITE(*,*) 'ENTER PROBING MODE itable'
        WRITE(*,*) '  (0) for STRAIN RATE , (1) FOR STRESS --> '
        READ (*,*) ITABLE
        WRITE(*,*)
        WRITE(*,*) 'ENTER PI/2 PARTITION npart'
        WRITE(*,*) '  1,2,3,4,5,6  for  90,45,30,22.5,18,15 --> '
        READ (*,*) NPART
        DANG=PI/2.D0/FLOAT(NPART)
        IF(NPART.GT.6) THEN
          WRITE(*,*) 'INCREASE DIMENSION OF ACTION & REACTION ARRAYS !'
          STOP
        ENDIF

        WRITE(IU,'('' PCYS INTERPOLATION TABLE'')')
        WRITE(IU,'('' CRYSTAL FILE USED: '',A)') FILECRYS
        WRITE(IU,'('' TEXTURE FILE USED: '',A)') FILETEXT
        WRITE(IU,'('' INTERACTION USED : '',I2)') INTERACTION
        IF (ITABLE.EQ.0)
     #    WRITE(IU,'('' INTERP TABLE BASED ON STRAIN RATE PROBES'')')
        IF (ITABLE.EQ.1)
     #    WRITE(IU,'('' INTERP TABLE BASED ON STRESS PROBES'')')
        WRITE(IU,'(I5)') ITABLE
        WRITE(IU,'('' PARTITION OF PI/2 INTERVAL'')')
        WRITE(IU,'(I5)') NPART
        WRITE(IU,'('' N POWER IN RATE SENSITIVE LAW'')')
        WRITE(IU,'(I5)') NRS(1,1)

C *********************************************************************
C     GENERATES EQUISPACED UNIT STRAIN-RATE VECTORS (b-BASIS REPRESENT).
C        NPART= # OF PARTITIONS IN EACH INTERVAL [0,PI/2]'
C        FOR NON-CENTRO SYMMETRIC PROPERTIES (ICS=0) SCANS -PI<THETA<PI
C        FOR     CENTRO SYMMETRIC PROPERTIES (ICS=1) SCANS   0<THETA<PI
C *********************************************************************

      DO I=1,4
        ITHETA(1,I)=0         ! use -NPART to avoid ortho symmetry ?
        ITHETA(2,I)=NPART
      ENDDO
      ITHETA(2,1)=2*NPART

      NPROBE=0

      DO 100 ITH4=ITHETA(1,4),ITHETA(2,4)
        THETA4=ITH4*DANG
        COSTH4=COS(THETA4)
        SINTH4=SIN(THETA4)

      DO 100 ITH3=ITHETA(1,3),ITHETA(2,3)
        THETA3=ITH3*DANG
        COSTH3=COS(THETA3)
        SINTH3=SIN(THETA3)

      DO 100 ITH2=ITHETA(1,2),ITHETA(2,2)
        THETA2=ITH2*DANG
        COSTH2=COS(THETA2)
        SINTH2=SIN(THETA2)

      DO 100 ITH1=ITHETA(1,1),ITHETA(2,1)
        THETA1=ITH1*DANG
        COSTH1=COS(THETA1)
        SINTH1=SIN(THETA1)

        NPROBE=NPROBE+1
        IF(NPROBE.GT.NPRBMX) THEN
          WRITE(*,*) 'MAXIMUM PROBING DIMENSION EXCEEDED'
          WRITE(*,*) 'NPROBE=', NPROBE
          STOP
        ENDIF

C *** CALCULATES NORMALIZED VECTOR COMPONENTS IN 5-D SPACE.

        ACTION(ITH1,ITH2,ITH3,ITH4,1)= SINTH1*SINTH2*SINTH3*SINTH4
        ACTION(ITH1,ITH2,ITH3,ITH4,2)= COSTH1*SINTH2*SINTH3*SINTH4
        ACTION(ITH1,ITH2,ITH3,ITH4,3)=        COSTH2*SINTH3*SINTH4
        ACTION(ITH1,ITH2,ITH3,ITH4,4)=               COSTH3*SINTH4
        ACTION(ITH1,ITH2,ITH3,ITH4,5)=                      COSTH4

        THGRID(1,NPROBE)=THETA1*180./PI
        THGRID(2,NPROBE)=THETA2*180./PI
        THGRID(3,NPROBE)=THETA3*180./PI
        THGRID(4,NPROBE)=THETA4*180./PI

        ITHGRID(1,NPROBE)=ITH1
        ITHGRID(2,NPROBE)=ITH2
        ITHGRID(3,NPROBE)=ITH3
        ITHGRID(4,NPROBE)=ITH4

C       WRITE(IU,'('' ACTION'',I3,3X,5F10.5)')
C    #      NPROBE,(ACTION(ITH1,ITH2,ITH3,ITH4,i),i=1,5)

  100 CONTINUE

C *** HARDWIRE RUN PARAMETERS

      IF(ITABLE.EQ.0) THEN      ! PROBES PCYS USING STRAIN RATES
        STRAIN_CONTROL=1
        DO I=1,3
        DO J=1,3
          IUDOT(I,J)=1
          SCAUCHY(I,J)=0.
        ENDDO
        ENDDO
        DO I=1,6
          IDSIM(I)=1
          ISCAU(I)=0
        ENDDO
      ELSE IF(ITABLE.EQ.1) THEN      ! PROBES PCYS USING STRESS
        STRAIN_CONTROL=0
        DO I=1,3
        DO J=1,3
          IUDOT(I,J)=0
        ENDDO
        ENDDO
        IUDOT(2,1)=1
        IUDOT(3,1)=1
        IUDOT(3,2)=1
        DO I=1,6
          IDSIM(I)=0
          ISCAU(I)=1
        ENDDO
      ENDIF

      NSTEPS=NPROBE

      WRITE(IU,'('' NUMBER OF PROBE STATES USED'')')
      WRITE(IU,'(I7)') NPROBE
      WRITE(IU,*)
      IF(ITABLE.EQ.0) WRITE(IU,'(''  THE1  THE2  THE3  THE4''
     #      ,11X,''S1'',11X,''S2'',11X,''S3'',11X,''S4'',11X,''S5'')')
      IF(ITABLE.EQ.1) WRITE(IU,'(''  THE1  THE2  THE3  THE4''
     #      ,11X,''D1'',11X,''D2'',11X,''D3'',11X,''D4'',11X,''D5'')')

      ENDIF      ! END OF IOPTION=0 TO GENERATE EQUISPACED UNIT VECTORS

C ***************************************************************************
      IF(IOPTION.EQ.1) THEN

C *** DEFINE THE PROBE VECTOR 'DBAR' OR 'SBAR' FOR THE STEP
        IF(ISTEP.EQ.1) NPROBERED=0

        ITH1=ITHGRID(1,ISTEP)
        ITH2=ITHGRID(2,ISTEP)
        ITH3=ITHGRID(3,ISTEP)
        ITH4=ITHGRID(4,ISTEP)

C *** AVOID RECALCULATING FOR REDUNDANT COMBINATIONS
C     (i.e. IF THETA(4)=0 THEN ACTION1=ACTION2=ACTION3=ACTION4=0,
C     INDEPENDENT OF THE VALUE OF ITH1,ITH2,ITH3)

      ISKIP=0
      IF(ITH4.EQ.0 .AND. (ITH3+ITH2+ITH1).NE.0) THEN
        DO I=1,5
          REACTION(ITH1,ITH2,ITH3,ITH4,I)=REACTION(0,0,0,0,I)
        ENDDO
        ISKIP=1
      ELSE IF(ITH3.EQ.0 .AND. (ITH2+ITH1).NE.0) THEN
        DO I=1,5
          REACTION(ITH1,ITH2,ITH3,ITH4,I)=REACTION(0,0,0,ITH4,I)
        ENDDO
        ISKIP=1
      ELSE IF(ITH2.EQ.0 .AND. (ITH1).NE.0) THEN
        DO I=1,5
          REACTION(ITH1,ITH2,ITH3,ITH4,I)=REACTION(0,0,ITH3,ITH4,I)
        ENDDO
        ISKIP=1
      ENDIF

      IF(ISKIP.EQ.0) THEN
        NPROBERED=NPROBERED+1
        IF(ITABLE.EQ.0) THEN
          DO I=1,5
            DBAR(I)=ACTION(ITH1,ITH2,ITH3,ITH4,I)
          ENDDO
          CALL CHG_BASIS(DBAR,DSIM,AUX55,AUX3333,1,5)
        ELSE IF(ITABLE.EQ.1) THEN
          DO I=1,5
            SBAR(I)=ACTION(ITH1,ITH2,ITH3,ITH4,I)
          ENDDO
          CALL CHG_BASIS(SBAR,SCAUCHY,AUX55,AUX3333,1,5)
        ENDIF
      ENDIF

      IF(ISKIP.EQ.1) THEN
        WRITE(IU,'(4F6.1,5E13.5)') (THGRID(I,ISTEP),I=1,4),
     #               (REACTION(ITH1,ITH2,ITH3,ITH4,I),I=1,5)

        IF(ISTEP.EQ.NSTEPS) THEN
          WRITE(IU,*)
          WRITE(IU,'('' NPROBERED ='',I7)') NPROBERED
        ENDIF
      ENDIF

      ENDIF      ! END OF IOPTION=1
C ***************************************************************************
      IF(IOPTION.EQ.2) THEN

C     STORES THE REACTION 'SAV' TO STRAIN-RATE 'DBAR' (IF ITABLE=0)
C     OR THE REACTION 'DBAR TO THE STRESS 'SBAR' (IF ITABLE=1)

        ITH1=ITHGRID(1,ISTEP)
        ITH2=ITHGRID(2,ISTEP)
        ITH3=ITHGRID(3,ISTEP)
        ITH4=ITHGRID(4,ISTEP)

        IF(ITABLE.EQ.0) THEN
          SNORM=SBAR(1)**2+SBAR(2)**2+SBAR(3)**2+SBAR(4)**2+SBAR(5)**2
          SNORM=SQRT(SNORM)
          DO I=1,5
            IF(ABS(SBAR(I)/SNORM) .LE. 1.E-5) SBAR(I)=0.
            REACTION(ITH1,ITH2,ITH3,ITH4,I)=SBAR(I)
          ENDDO
        ELSE IF(ITABLE.EQ.1) THEN
          DNORM=DBAR(1)**2+DBAR(2)**2+DBAR(3)**2+DBAR(4)**2+DBAR(5)**2
          DNORM=SQRT(DNORM)
          DO I=1,5
            IF(ABS(DBAR(I)/DNORM) .LE. 1.E-5) DBAR(I)=0.
            REACTION(ITH1,ITH2,ITH3,ITH4,I)=DBAR(I)
          ENDDO
        ENDIF

        WRITE(IU,'(4F6.1,5E13.5)') (THGRID(I,ISTEP),I=1,4),
     #               (REACTION(ITH1,ITH2,ITH3,ITH4,I),I=1,5)

        IF(ISTEP.EQ.NSTEPS) THEN
          WRITE(IU,*)
          WRITE(IU,'('' NPROBERED ='',I7)') NPROBERED
        ENDIF

      ENDIF      ! END OF IOPTION=2
C **********************************************************************

      RETURN
      END
C
C ***********************************************************************
C     SUBROUTINE POSTMORTEM     --->      VERSION 23/MAR/2007
C
C     SAVES ARRAYS ASSOCIATED WITH A GIVEN STATE OF DEFORMATION IN
C     GRAINS AND POLYCRYSTAL. PERMITS TO START RUN FROM SUCH STATE.
C     THIS VERSION IS FOR A SINGLE ELEMENT RUN.
C     THIS VERSION READS AND WRITES A BINARY FILE.
C
C        IF IOPTION=1 READS GRAIN AND PX STATES FROM 'postmort.in'
C        IF IOPTION=2 SAVES GRAIN AND PX STATES INTO 'postmort.out'
C
C        ISAVE=1 : SAVES MACRO TENSORS AND INITIAL GRAIN STRESS.
C                  MEANT FOR RUNNING ONLY ONE STEP IN ORDER TO GET QUICK
C                  INITIAL CONVERGENCE OR RESTART WITH AN OPEN SCYS.
C        ISAVE=ISTEP : SAVES FULL GRAIN STATES ASSOCIATED WITH ISTEP AND
C                      ALLOWS TO CONTINUE DEFORMATION FROM A PREVIOUS RUN.
C ************************************************************************
C
      SUBROUTINE POSTMORTEM (ioption)

      INCLUDE 'vpsc7.dim'

      ngr1=1
      ngr2=ngr(nph)

      IF (IOPTION.EQ.1) THEN

        read(UR4) isaveprevious

        read(UR4) (dav(i),i=1,5)
        read(UR4) (sav(i),i=1,5)
        read(UR4) (dzero(i),i=1,5)
        read(UR4) ((xmtg(i,j),j=1,5),i=1,5)
        read(UR4) ((xltg(i,j),j=1,5),i=1,5)
        read(UR4) ((sg(i,KKK),i=1,5),KKK=ngr1,ngr2)

        if(isaveprevious.eq.1) return

        read(UR4) ((epstot(i,j),i=1,3),j=1,3),epsvm,epsacu
        read(UR4) ((axisph(i,j,0),i=0,3),j=1,3)
        read(UR4) (( fijph(i,j,0),i=1,3),j=1,3)

        do iph=1,nph
          ngr1=ngr(iph-1)+1
          ngr2=ngr(iph)
          read(UR4) ((axisph(i,j,iph),i=0,3),j=1,3)
          read(UR4) (( fijph(i,j,iph),i=1,3),j=1,3)

          read(UR4) (((ag(i,j,kkk),i=1,3),j=1,3),KKK=ngr1,ngr2)
          read(UR4) (wgt(kkk),KKK=ngr1,ngr2)
          read(UR4) (gtotgr(kkk),KKK=ngr1,ngr2)
          if(ihardlaw.eq.0) read(UR4) ((crss(is,kkk),is=1,nsyst(iph)),
     #                  KKK=ngr1,ngr2)
          if(ihardlaw.eq.1) read(UR4) ((taue(is,kkk),is=1,nsyst(iph)),
     #                  KKK=ngr1,ngr2)

c   read twin-related arrays for each phase if appropriate.
          if(ntwmod(iph).ne.0) then
            read(UR4)  pritw(iph),sectw(iph)
            read(UR4) (ntwevents(kkk),KKK=ngr1,ngr2)
            read(UR4) (twfrph(itwm,iph),itwm=1,ntwmod(iph))
            read(UR4) (eftwfr(itwm,iph),itwm=1,ntwmod(iph))
            read(UR4) (ktwsmx(kkk),KKK=ngr1,ngr2)
            read(UR4) ((twfrsy(is,kkk),is=1,nsyst(iph)),KKK=ngr1,ngr2)
          endif
        enddo

      ENDIF

      IF (IOPTION.EQ.2) THEN

        write(UW2) isave

        write(UW2) (dav(i),i=1,5)
        write(UW2) (sav(i),i=1,5)
        write(UW2) (dzero(i),i=1,5)
        write(UW2) ((xmtg(i,j),j=1,5),i=1,5)
        write(UW2) ((xltg(i,j),j=1,5),i=1,5)
        write(UW2) ((sg(i,KKK),i=1,5),KKK=ngr1,ngr2)

        if(isave.eq.1) return

        write(UW2) ((epstot(i,j),i=1,3),j=1,3),epsvm,epsacu
        write(UW2) ((axisph(i,j,0),i=0,3),j=1,3)
        write(UW2) (( fijph(i,j,0),i=1,3),j=1,3)

        do iph=1,nph
          ngr1=ngr(iph-1)+1
          ngr2=ngr(iph)
          write(UW2) ((axisph(i,j,iph),i=0,3),j=1,3)
          write(UW2) (( fijph(i,j,iph),i=1,3),j=1,3)

          write(UW2) (((ag(i,j,kkk),i=1,3),j=1,3),KKK=ngr1,ngr2)
          write(UW2) (wgt(kkk),KKK=ngr1,ngr2)
          write(UW2) (gtotgr(kkk),KKK=ngr1,ngr2)
          if(ihardlaw.eq.0) write(UW2) ((crss(is,kkk),is=1,nsyst(iph)),
     #                  KKK=ngr1,ngr2)
          if(ihardlaw.eq.1) write(UW2) ((taue(is,kkk),is=1,nsyst(iph)),
     #                  KKK=ngr1,ngr2)

c   read twin-related arrays for each phase if appropriate.
          if(ntwmod(iph).ne.0) then
            write(UW2)  pritw(iph),sectw(iph)
            write(UW2) (ntwevents(kkk),KKK=ngr1,ngr2)
            write(UW2) (twfrph(itwm,iph),itwm=1,ntwmod(iph))
            write(UW2) (eftwfr(itwm,iph),itwm=1,ntwmod(iph))
            write(UW2) (ktwsmx(kkk),KKK=ngr1,ngr2)
            write(UW2) ((twfrsy(is,kkk),is=1,nsyst(iph)),KKK=ngr1,ngr2)
          endif
        enddo

      ENDIF

      RETURN
      END

C ********************************************************************
C     SUBROUTINE POSTMORTEM_FE     --->      VERSION 23/MAR/07
C
C     SAVES ARRAYS ASSOCIATED WITH A GIVEN STATE OF DEFORMATION IN
C     GRAINS AND POLYCRYSTAL. PERMITS TO START RUN FROM SUCH STATE.
C     THIS VERSION IS FOR A MULTIELEMENT RUN.
C     THIS VERSION READS AND WRITES A BINARY FILE.
C        IF IOPTION=1 READ ARRAYS FROM 'postmort.in'
C        IF IOPTION=2 SAVE ARRAYS INTO 'postmort.out'
C ***************************************************************
      SUBROUTINE POSTMORTEM_FE (ioption)

      INCLUDE 'vpsc7.dim'

      COMMON/MULTIELEM/EVMELE(NELMX),SAVELE(5,NELMX),DZEROELE(5,NELMX),
     #            XMTGELE(5,5,NELMX),XLTGELE(5,5,NELMX),TEMPELE(NELMX)

      DO IELEM=1,NELEM

      iphbot=(ielem-1)*nph+1
      iphtop=(ielem-1)*nph+nph
      ngr1=ngr(iphbot-1)+1
      ngr2=ngr(iphtop)

      IF (IOPTION.EQ.1) THEN

        read(UR4) evmele(ielem),tempele(ielem)
        read(UR4) (savele(i,ielem),i=1,5)
        read(UR4) (dzeroele(i,ielem),i=1,5)
        read(UR4) ((xmtgele(i,j,ielem) ,j=1,5),i=1,5)
        read(UR4) ((xltgele(i,j,ielem),j=1,5),i=1,5)
        read(UR4) ((sg(i,kkk),i=1,5),kkk=ngr1,ngr2)

        do iph=iphbot,iphtop
          ngr1=ngr(iph-1)+1
          ngr2=ngr(iph)
          iphel=iph-nph*(ielem-1)
          nsys=nsyst(iphel)
          ntwm=ntwmod(iphel)

          read(UR4) ((axisph(i,j,iph),i=0,3),j=1,3)
          read(UR4) (( fijph(i,j,iph),i=1,3),j=1,3)
          read(UR4) (((ag(i,j,kkk),i=1,3),j=1,3),kkk=ngr1,ngr2)
          read(UR4) (wgt(kkk),kkk=ngr1,ngr2)
          read(UR4) (gtotgr(kkk),kkk=ngr1,ngr2)
          if(ihardlaw.eq.0)
     #             read(UR4) ((crss(is,kkk),is=1,nsys),kkk=ngr1,ngr2)
          if(ihardlaw.eq.1)
     #             read(UR4) ((taue(is,kkk),is=1,nsys),kkk=ngr1,ngr2)

C *** TWINNING RELATED ARRAYS. THE RANDOM NUMBER SEED WILL MODIFY RESULTS
C     RECOVERED FROM 'POSTMORT' (COMPARED WITH STRAIGHT RUN)

          if(ntwm.ne.0) then
            read(UR4) (twfrph(itwm,iph),itwm=1,ntwm)
            read(UR4) (eftwfr(itwm,iph),itwm=1,ntwm)
            read(UR4) (ktwsmx(kkk),kkk=ngr1,ngr2)
            read(UR4) ((twfrsy(is,kkk),is=1,nsys),kkk=ngr1,ngr2)
          endif
        enddo

      ENDIF

      IF (IOPTION.EQ.2) THEN

        write(UW2) evmele(ielem),tempele(ielem)
        write(UW2) (savele(i,ielem),i=1,5)
        write(UW2) (dzeroele(i,ielem),i=1,5)
        write(UW2) ((xmtgele(i,j,ielem) ,j=1,5),i=1,5)
        write(UW2) ((xltgele(i,j,ielem),j=1,5),i=1,5)
        write(UW2) ((sg(i,kkk),i=1,5),kkk=ngr1,ngr2)

        do iph=iphbot,iphtop
          ngr1=ngr(iph-1)+1
          ngr2=ngr(iph)
          iphel=iph-nph*(ielem-1)
          nsys=nsyst(iphel)
          ntwm=ntwmod(iphel)

          write(UW2) ((axisph(i,j,iph),i=0,3),j=1,3)
          write(UW2) (( fijph(i,j,iph),i=1,3),j=1,3)
          write(UW2) (((ag(i,j,kkk),i=1,3),j=1,3),kkk=ngr1,ngr2)
          write(UW2) (wgt(kkk),kkk=ngr1,ngr2)
          write(UW2) (gtotgr(kkk),kkk=ngr1,ngr2)
          if(ihardlaw.eq.0)
     #             write(UW2) ((crss(is,kkk),is=1,nsys),kkk=ngr1,ngr2)
          if(ihardlaw.eq.1)
     #             write(UW2) ((taue(is,kkk),is=1,nsys),kkk=ngr1,ngr2)

C *** TWINNING RELATED ARRAYS. THE RANDOM NUMBER SEED WILL MODIFY RESULTS
C     RECOVERED FROM 'POSTMORT' (COMPARED WITH STRAIGHT RUN)

          if(ntwm.ne.0) then
            write(UW2) (twfrph(itwm,iph),itwm=1,ntwm)
            write(UW2) (eftwfr(itwm,iph),itwm=1,ntwm)
            write(UW2) (ktwsmx(kkk),kkk=ngr1,ngr2)
            write(UW2) ((twfrsy(is,kkk),is=1,nsys),kkk=ngr1,ngr2)
          endif
        enddo

      ENDIF

      ENDDO

      RETURN
      END

CFEE

C *****************************************************************************
C     SUBROUTINE RODRIGUES (ex-REORIENT_GRAIN)   --->   VERSION 03/NOV/09

C     BUILDS INCREMENTAL ROTATION MATRIX 'AROT' BASED ON RODRIGUES FORMULA.
C             --> AROT=I+sin(phi)*C+(1-cos(phi))*C^2
C     'C'   :INCREMENTAL LATTICE SPIN (ANTI-SYMMETRIC) (normalized)
C     'AROT':INCREMENTAL TRANSFORMATION FROM INITIAL TO FINAL ORIENTATION.
C *****************************************************************************

      SUBROUTINE RODRIGUES (C,AROT)

      dimension c(3,3),c2(3,3),v(3),xid33(3,3),arot(3,3)
      data xid33/1.,0.,0.,0.,1.,0.,0.,0.,1./

c ** v(i) is the Rodrigues spin axis. The norm is the rotation angle phi.
      v(1)=c(3,2)
      v(2)=c(1,3)
      v(3)=c(2,1)
      vnorm=sqrt(v(1)*v(1)+v(2)*v(2)+v(3)*v(3))
      if(vnorm.lt.1.e-06) then
        write(*,*) ' zero rotation inside Rodrigues'
cx        write(*,*) ' press RETURN to continue'
cx        pause
        do i=1,3
        do j=1,3
          arot(i,j)=xid33(i,j)
        enddo
        enddo
        return
      endif

      coef1=sin(vnorm)/vnorm
      coef2=(1.-cos(vnorm))/vnorm**2

      do i=1,3
      do j=1,3
        c2(i,j)=0.
        do k=1,3
          c2(i,j)=c2(i,j)+c(i,k)*c(k,j)
        enddo
      enddo
      enddo

      do i=1,3
      do j=1,3
        arot(i,j)=xid33(i,j)+coef1*c(i,j)+coef2*c2(i,j)
      enddo
      enddo

      return
      end
C
C *************************************************************************
C     SUBROUTINE SCALE_3   ---->   VERSION 26/MAY/2000
C
C     THIS SUBROUTINE IS MEANT TO BE USED IN COMBINATION WITH MTS MODEL
C     WHERE RATE EFFECTS ARE ACCOUNTED FOR IN THE FUNCTIONAL FORM OF CRSS.
C
C     BY REDEFINING THE FACTOR 'GAMD0' TO BE OF THE ORDER OF THE STRAIN
C     RATE THE RATIO (RSS/CRSS) WILL BE OF ORDER ONE AND THERE ARE NO RATE
C     SENSITIVITY EFFECTS ASSOCIATED WITH THE N'th POWER.
C     THE N'th POWER IS ONLY A WAY TO AVOID AMBIGUITIES AND IS UNIQUE.
C *************************************************************************

      SUBROUTINE SCALE_3 (ISTEP)

      INCLUDE 'vpsc7.dim'

C     DIMENSION DGX(5)

      REFRATE=VNORM(DBAR,5)
C     REFRATE=DVM      ! REFERENCE USED BY KOK & BEAUDOIN

      KGX=1
      DO IPH=IPHBOT,IPHTOP
        DO KKK=NGR(IPH-1)+1,NGR(IPH)

C          IF(ISTEP.GT.1) THEN      ! DG(I,KGX) NOT STORED FOR MULTIELEM CALC
C            DO I=1,5
C              DGX(I)=DG(I,KGX)
C            ENDDO
C            REFRATE=VNORM(DGX,5)
C          ENDIF

          GAMD0G(KGX)=REFRATE
          KGX=KGX+1
        ENDDO
      ENDDO

      RETURN
      END
C
C *****************************************************************************
C     SUBROUTINE STATE_5x5      --->      VERSION 26/jan/2000
C
C     BASED ON SECANT EQUATION:   D(i)=MS(i,j)*S(j)
C     SHIFTS KNOWN COMPONENTS TO INDEPENDENT TERM, CALCULATES COEFFICIENTS
C     FOR UNKNOWN COMPONENTS AND INVERTS THE LINEAR SYSTEM.
C *****************************************************************************

      subroutine state_5x5 (ibc_d,BC_D,ibc_s,BC_S,XMS)

      dimension aux11(5),aux21(5,5)
      dimension XMS(5,5)
      dimension ibc_d(5),bc_d(5),ibc_s(5),bc_s(5)

      do i=1,5
        aux11(i)=-1.d0*ibc_d(i)*bc_d(i)
        do j=1,5
          aux11(i)=aux11(i)+xms(i,j)*ibc_s(j)*bc_s(j)
          aux21(i,j)=ibc_s(j)*(i/j)*(j/i)-ibc_d(j)*xms(i,j)
        enddo
      enddo

      CALL LU_EQSYSTEM(AUX21,AUX11,5,IER)

      if(ier.eq.1) then
      write(*,*) 'SINGULAR SYSTEM IN STATE_5X5'
      stop
      endif

      do i=1,5
        bc_d(i)=ibc_d(i)*bc_d(i)+ibc_s(i)*aux11(i)
        bc_s(i)=ibc_s(i)*bc_s(i)+ibc_d(i)*aux11(i)
      enddo

      return
      end
C
C *****************************************************************************
C     SUBROUTINE STATE_6x6      --->      VERSION 16/NOV/97
C
C     BASED ON SECANT EQUATION:   D(i)=MS(i,j)*S(j)
C     SHIFTS KNOWN COMPONENTS TO INDEPENDENT TERM, CALCULATES COEFFICIENTS
C     FOR UNKNOWN COMPONENTS AND INVERTS THE LINEAR SYSTEM.
C *****************************************************************************
c
      subroutine state_6x6 (ibc_d,AUX_D,ibc_s,AUX_S,AUX_MS)
c
      dimension aux4(3,3,3,3),aux2(6,6),aux11(6),aux21(6,6)
      dimension AUX_D(3,3),AUX_S(3,3),AUX_MS(5,5)
      dimension ibc_d(6),bc_d(6),ibc_s(6),bc_s(6)
      dimension profac(6)
      dimension aux5(5),aux33(3,3)
c
      do i=1,6
        profac(i)=1.d0+(i/4)
      enddo
C
C *** PUTS CARTESIAN 'D' & 'S' IN VOIGT.
        CALL VOIGT (BC_D,AUX_D,AUX2,AUX4,2)
        CALL VOIGT (BC_S,AUX_S,AUX2,AUX4,2)
C *** PUTS b-BASIS 'MS' IN VOIGT.
        CALL CHG_BASIS(AUX5,AUX33,AUX_MS,AUX4,3,5)
        CALL VOIGT (AUX11,AUX33,AUX2,AUX4,4)

      do i=1,6
        aux11(i)=-1.d0*ibc_d(i)*bc_d(i)
        do j=1,6
          aux11(i)=aux11(i)+aux2(i,j)*ibc_s(j)*bc_s(j)*profac(j)
          aux21(i,j)=ibc_s(j)*(i/j)*(j/i)-ibc_d(j)*aux2(i,j)*profac(j)
        enddo
      enddo

      CALL LU_EQSYSTEM(AUX21,AUX11,6,IER)

      if(ier.eq.1) then
      write(*,*) 'SINGULAR SYSTEM IN STATE_6X6'
      stop
      endif

      do i=1,6
        bc_d(i)=ibc_d(i)*bc_d(i)+ibc_s(i)*aux11(i)
        bc_s(i)=ibc_s(i)*bc_s(i)+ibc_d(i)*aux11(i)
      enddo
      CALL VOIGT (BC_D,AUX_D,AUX2,AUX4,1)
      CALL VOIGT (BC_S,AUX_S,AUX2,AUX4,1)

      return
      end
CFEB
C ***************************************************************************
C     SUBROUTINE STATISTICS      --->      VERSION 02/APR/2004
C ***************************************************************************
      SUBROUTINE STATISTICS (VECT,WGT,IDIM,FOM,SOM)

      DIMENSION VECT(IDIM),WGT(IDIM)

      WTOT=0.
      DO I=1,IDIM
        WTOT=WTOT+WGT(I)
      ENDDO

      FOM=0.
      SOM=0.
      DO I=1,IDIM
        FOM=FOM+VECT(I)    *WGT(I)/WTOT
        SOM=SOM+VECT(I)**2 *WGT(I)/WTOT
      ENDDO
      SOM=(SOM-FOM**2)      ! MATHEMATICALLY SOM.LE.0 ALWAYS
      IF(SOM.LT.0.) SOM=0.
      IF(SOM.GT.0.) SOM=SQRT(SOM)

      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE STAT_GRAIN_SHAPE    --->    VERSION 29/SEP/2005
C
C     PERFORMS STATISTICS ON GRAIN AXES (AVERAGE & ST. DEV.) AND PHASE AXES
C
C     CNT MODIFIED SET/2005:
C       DIMENSIONING AND OUTPUTTING IS MADE LOCALLY WITHIN THE SUBROUTINE.
C       OUTPUT FILES 'AVAXES' & 'GRAXFAC' WERE MERGED INTO ONE: 'STAT_AX'
C **************************************************************************

      SUBROUTINE STAT_GRAIN_SHAPE

      INCLUDE 'vpsc7.dim'

      DIMENSION avax(3,NPHMX),sdax(3,NPHMX),graxph(3,NPHMX)

      DO IPH=IPHBOT,IPHTOP

      IF(ISHAPE(IPH).NE.0 .AND. WPH(IPH).GT.0.) THEN

      do i=1,3
        avax(i,iph)=0.
        sdax(i,iph)=0.
      enddo

      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        do i=1,3
          avax(i,iph)=avax(i,iph)+AXISGR(0,I,KKK)*wgt(kkk)/wph(iph)
        enddo
      ENDDO

      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        do i=1,3
          sdax(i,iph)=sdax(i,iph)+(AXISGR(0,I,KKK)-avax(i,iph))**2*
     #                wgt(kkk)/wph(iph)
        enddo
      ENDDO

      avaxn=sqrt(avax(1,iph)**2+avax(2,iph)**2+avax(3,iph)**2)
      do i=1,3
        sdax(i,iph)=sdax(i,iph)/avaxn
      enddo

C     CALCULATION OF MAJOR GRAIN AXIS FACTORS:
C     FIRST COLUMN OF 'AXISGR' IS THE MAJOR AXIS OF ELLIPSOID IN SAMPLE AXES

      do i=1,3
        graxph(i,iph)=0.
      enddo

      DO KKK=NGR(IPH-1)+1,NGR(IPH)
       DO I=1,3
         graxph(i,iph)=graxph(i,iph)+(AXISGR(i,1,kkk)**2)*
     #                                           wgt(kkk)/wph(iph)
       ENDDO
      ENDDO

      WRITE(16,'(F6.2,I5,3X,3F8.3,3X,3F8.3)')
     #           epsacu,iph,(avax(i,iph),i=1,3),(graxph(i,iph),i=1,3)

      ENDIF

      ENDDO

      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE STAT_SHEAR_ACTIVITY
C
C     MAKES STATISTIC ON DEFORMATION MODE ACTIVITY.
C     CALCULATES ARRAYS:
C     - GMAX : maximum dgam for a given mode and a given grain.
C     - GTOT : sum of dgam for a given mode and a given grain.
C     - GAVGR: sum of all dgam for a given grain.
C     - GMAXG: maximum dgam for a given grain.
C     - ACT  : number of active systems in a given grain.
C     - ACTIV: weighted number of active systems in a given phase.
C     - GAVMOD: weighted sum of dgam for a given mode in a given phase.
C     - GAVPH: weighted sum of dgam for a given phase.
C
C     The above arrays are dimensioned to the maximum number of grains and
C     phases in COMMON/STATSH/
C     For FE application this COMMON is commented out and IPH varies between
C     1 and NPH=NELEM
C ***************************************************************************

      SUBROUTINE STAT_SHEAR_ACTIVITY

      INCLUDE 'vpsc7.dim'

      KGX=1
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
      DO KGR=NGR(IPH-1)+1,NGR(IPH)

        gavgr(kgr)=0.
        act(kgr)=0.
        gmaxg=0.
        is=0
        do kmo=1,nmodes(IPHEL)
          gmax(kmo,iph)=0.
          gtot(kmo,kgr)=0.
            do ksy=1,nsm(kmo,IPHEL)
              is=is+1
              gabs=abs(gamdot(is,KGX))
              gtot(kmo,kgr)=gtot(kmo,kgr)+gabs
              if(gabs.gt.gmax(kmo,iph)) gmax(kmo,iph)=gabs
            enddo
          gavgr(kgr)=gavgr(kgr)+gtot(kmo,kgr)
          gmaxg=max(gmaxg,gmax(kmo,iph))
        enddo
        gming=gmaxg*0.05
        do iz=1,nsyst(IPHEL)
          if(abs(gamdot(iz,KGX)).ge.gming) act(kgr)=act(kgr)+1
        enddo

        KGX=KGX+1
      ENDDO
      ENDDO

      GAVPC=0.
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1

        activ(iph)=0.
        GAVPH(IPH)=0.
        do kmo=1,nmodes(IPHEL)
          gavmod(kmo,iph)=0.
        enddo

        IF(WPH(IPH).NE.0.) THEN
          do kgr=ngr(iph-1)+1,ngr(iph)
            do kmo=1,nmodes(IPHEL)
              gavmod(kmo,iph)=gavmod(kmo,iph)+gtot(kmo,kgr)*wgt(kgr)
            enddo
            GAVPH(IPH)=GAVPH(IPH)+gavgr(kgr)*wgt(kgr)
            activ(iph)=activ(iph)+act(kgr)*wgt(kgr)*gavgr(kgr)
          enddo
          activ(iph)=activ(iph)/GAVPH(IPH)
          GAVPC=GAVPC+GAVPH(IPH)
        ENDIF
      ENDDO

      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        do kmo=1,nmodes(IPHEL)
          gavmod(kmo,iph)=gavmod(kmo,iph)/GAVPC
        enddo
      ENDDO

      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE STAT_STRESS_STRAIN
C
C     AVERAGE & STANDARD DEVIATION OF STRESS & STRAIN-RATE COMPONENTS
C **************************************************************************

      SUBROUTINE STAT_STRESS_STRAIN

      INCLUDE 'vpsc7.dim'

      do i=1,5
        sav(i)=0.
        dav(i)=0.
        stdevs(i)=0.
        stdevd(i)=0.
      enddo

      KGX=1
      DO IPH=IPHBOT,IPHTOP
      DO KGR=ngr(iph-1)+1,ngr(iph)
        do i=1,5
          sav(i)=sav(i)+sg(i,KGR)*wgt(kgr)
          dav(i)=dav(i)+dg(i,KGX)*wgt(kgr)
        enddo
        KGX=KGX+1
      enddo
      enddo

      KGX=1
      DO IPH=IPHBOT,IPHTOP
      DO KGR=ngr(iph-1)+1,ngr(iph)
        do i=1,5
          difd=dg(i,KGX)-dav(i)
          difs=sg(i,kgr)-sav(i)
          stdevd(i)=stdevd(i)+wgt(kgr)*difd*difd
          stdevs(i)=stdevs(i)+wgt(kgr)*difs*difs
        enddo
        KGX=KGX+1
      enddo
      enddo

      do i=1,5
        stdevd(i)=sqrt(stdevd(i))/Vnorm(dav,5)
        stdevs(i)=sqrt(stdevs(i))/Vnorm(sav,5)
      enddo

      RETURN
      END
C
C ***************************************************************************
C     SUBROUTINE TEXTURE_ROTATION     -->      VERSION OF 14/OCT/2006
C
C     USER PROVIDES A ROTATION MATRIX 'ROTMAT' THAT OPERATES ON
C     CRYSTALLOGRAPIC AND MORPHOLOGIC TEXTURE AS FOLLOWS:
C
C     1- CHANGE OF REFERENCE SYSTEM   ***
C        COLUMNS OF 'ROTMAT' ARE 'old' SYSTEM AXES EXPRESSED IN 'new' SYSTEM.
C       'ROTMAT' TRANSFORMS VECTORS AND TENSORS EXPRESED IN 'old' SET OF
C        AXES, AND EXPRESSES THEIR COMPONENTS IN 'new' SET OF AXES:
C
C          Vnew(i)  =ROTMAT(i,j)*Vold(j)
C          Tnew(i,j)=ROTMAT(i,k)*ROTMAT(j,l)*Told(k,l)
C
C     2- RIGID ROTATION OF THE SAMPLE WITH RESPECT TO LABORATORY AXES   ***
C        'ROTMAT' ROTATES THE SAMPLE FROM 'OLD' TO 'NEW POSITION.
C        COLUMNS OF 'ROTMAT' ARE THE SAMPLE AXES AFTER ROTATION, EXPRESSED
C        IN UNROTATED SAMPLE AXES.
C ***************************************************************************

      SUBROUTINE TEXTURE_ROTATION (ROTMAT)

      INCLUDE 'vpsc7.dim'

      DIMENSION ROTMAT(3,3),AUX33(3,3)

      DO IPH=1,NPH
        DO KGX=NGR(IPH-1)+1,NGR(IPH)

C *** 'AG' TRANSFORMS FROM CRYSTAL TO 'OLD' SAMPLE AXES.
C      THE COLUMNS OF 'AG' ARE THE CRYSTAL AXES EXPRESSED IN 'OLD' SYSTEM.
C     'ROTMAT' ROTATES THEM TO 'NEW' SYSTEM.
          DO I=1,3
          DO J=1,3
            AUX33(I,J)=0.
            DO K=1,3
              AUX33(I,J)=AUX33(I,J)+ROTMAT(I,K)*AG(K,J,KGX)
            ENDDO
          ENDDO
          ENDDO
          DO I=1,3
          DO J=1,3
            AG(I,J,KGX)=AUX33(I,J)
          ENDDO
          ENDDO

        ENDDO      ! END OF LOOP OVER GRAINS IN THE PHASE

C *** COLUMNS OF 'FIJPH' ARE GRAIN AXES EXPRESSED IN 'OLD' SAMPLE SYSTEM.
C     SUBR 'UPDATE_SHAPE' CALCULATES EIGENVECTORS AND EIGENVALUES USED
C     INSIDE 'SUBR VPSC' TO ROTATE 'C4SA' INTO 'C4GA' AND CALC ESHELBY TENSOR.

        DO I=1,3
        DO J=1,3
          AUX33(I,J)=0.
          DO K=1,3
            AUX33(I,J)=AUX33(I,J)+ROTMAT(I,K)*FIJPH(K,J,IPH)
          ENDDO
        ENDDO
        ENDDO
        DO I=1,3
        DO J=1,3
          FIJPH(I,J,IPH)=AUX33(I,J)
        ENDDO
        ENDDO

        IF(ISHAPE(IPH).GE.1) THEN
          DO KGX=NGR(IPH-1)+1,NGR(IPH)
            DO I=1,3
            DO J=1,3
              AUX33(I,J)=0.
              DO K=1,3
                AUX33(I,J)=AUX33(I,J)+ROTMAT(I,K)*FIJGR(K,J,KGX)
              ENDDO
            ENDDO
            ENDDO
            DO I=1,3
            DO J=1,3
              FIJGR(I,J,KGX)=AUX33(I,J)
            ENDDO
            ENDDO
          ENDDO
        ENDIF

        WRITE(10,'(''  EULER ANGLES OF PHASE before rotation'',I4)') IPH
        WRITE(10,'(3F10.3)') (EULERPH(I,IPH),I=1,3)
        WRITE(10,'(''  ELLIPSOID AXES OF PHASE before rotatn'',I4)') IPH
        WRITE(10,'(3F10.3)') (AXISPH(0,I,IPH),I=1,3)

        CALL UPDATE_SHAPE (IPH)    ! updates also grain shape if ishape>0

        WRITE(10,'(''  EULER ANGLES OF PHASE after rotation'',I4)') IPH
        WRITE(10,'(3F10.3)') (EULERPH(I,IPH),I=1,3)
        WRITE(10,'(''  ELLIPSOID AXES OF PHASE after rotatn'',I4)') IPH
        WRITE(10,'(3F10.3)') (AXISPH(0,I,IPH),I=1,3)

      ENDDO      ! END OF LOOP OVER PHASES

      RETURN
      END
CFEE

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     FUNCTION VNORM    ---->   VERSION OF 23/NOV/2011
C
C     CALCULATES THE NORM OF A VECTOR V WITH N COMPONENTS
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      FUNCTION VNORM (V,N)

      DIMENSION V(N)

      VNORM=0.
      DO I=1,N
        VNORM=VNORM+V(I)*V(I)
      ENDDO
      VNORM=SQRT(VNORM)

      RETURN
      END

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     FUNCTION TNORM5x5    ---->   VERSION OF 23/NOV/2011
C
C     CALCULATES THE NORM OF A 5x5 MATRIX
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      FUNCTION TNORM5x5 (T)

      DIMENSION T(25)

      TNORM=0.
      DO I=1,25
        TNORM=TNORM+T(I)*T(I)
      ENDDO
      TNORM5x5=SQRT(TNORM)

      RETURN
      END

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     FUNCTION TNORM6x6    ---->   VERSION OF 23/NOV/2011
C
C     CALCULATES THE NORM OF A 6x6 MATRIX
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      FUNCTION TNORM6x6 (T)

      DIMENSION T(36)

      TNORM=0.
      DO I=1,36
        TNORM=TNORM+T(I)*T(I)
      ENDDO
      TNORM6x6=SQRT(TNORM)

      RETURN
      END

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     FUNCTION VMISMATCH   ---->   VERSION OF 23/NOV/2011
C
C     CALCULATES RELATIVE DIFFERENCE BETWEEN TWO VECTORS WITH N COMPONENTS.
C     THE DIFFERENCE IS RELATIVE TO THE NORM OF THE ARITHMETIC AVERAGE.
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      FUNCTION VMISMATCH (V1,V2,N)

      DIMENSION V1(N),V2(N)
      DIMENSION V_dif(N),V_ave(N)

      DO I=1,N
        V_dif(I)=V1(I)-V2(I)
        V_ave(I)=0.5*(V1(I)+V2(i))
      ENDDO
      VMISMATCH =VNORM(V_dif,N)/VNORM(V_ave,N)

      RETURN
      END

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     FUNCTION TMISMATCH5x5   ---->   VERSION OF 23/NOV/2011
C
C     CALCULATES RELATIVE DIFFERENCE BETWEEN TWO 5x5 MATRICES.
C     THE DIFFERENCE IS RELATIVE TO THE NORM OF THE ARITHMETIC AVERAGE.
C     REPLACES PREVIOUS 'TMISMATCH' AND 'TMISMATCH5'
C     MAKE SURE THAT DIMENSION OF INPUT ARRAY IN CALLING ROUTINE IS 5x5
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      FUNCTION TMISMATCH5x5 (T1,T2)

      DIMENSION T1(25),T2(25)
      DIMENSION T_dif(25),T_ave(25)

      DO I=1,25
        T_dif(I)=T1(I)-T2(I)
        T_ave(I)=0.5*(T1(I)+T2(i))
      ENDDO
      TMISMATCH5x5=VNORM(T_dif,25)/VNORM(T_ave,25)

      RETURN
      END

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     FUNCTION TMISMATCH6x6   ---->   VERSION OF 23/NOV/2011
C
C     CALCULATES RELATIVE DIFFERENCE BETWEEN TWO 6x6 MATRICES.
C     THE DIFFERENCE IS RELATIVE TO THE NORM OF THE ARITHMETIC AVERAGE.
C     REPLACES PREVIOUS 'TMISMATCH'
C     MAKE SURE THAT DIMENSION OF INPUT ARRAY IN CALLING ROUTINE IS 6x6
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      FUNCTION TMISMATCH6x6 (T1,T2)

      DIMENSION T1(36),T2(36)
      DIMENSION T_dif(36),T_ave(36)

      DO I=1,36
        T_dif(I)=T1(I)-T2(I)
        T_ave(I)=0.5*(T1(I)+T2(i))
      ENDDO
      TMISMATCH6x6=VNORM(T_dif,36)/VNORM(T_ave,36)

      RETURN
      END


C
C *****************************************************************************
C     SUBROUTINE TWIN_ORIENTATION    --->    VERSION OF 08/DEC/2011
C
C     GIVEN THE SHEAR DIRECTION 'TWB' AND TWIN PLANE NORMAL 'TWN', DEFINES
C     THE ORIENTATION OF THE TWIN RELATED CRYSTAL.
C
C     FOR TYPE I twins: MAKES A ROTATION OF 180 deg AROUND NORMAL TO TWIN
C       PLANE DEFINED BY 'TWN'
C     FOR TYPE II twins: MAKES A ROTATION OF 180 deg AROUND SHEAR DIRECTION
C       DEFINED BY 'TWB'
C
C     USES THE RODRIGUES FORMULA FOR THE CASE phi=180 deg
C          --> R=I+sin(phi)*N+(1-cos(phi))*N^2=-I+2*V^2=-I+2*Vi*Vj
C
C     THE MATRIX 'ATWIN' TRANSFORMS FROM TWIN TO PARENT CRYSTAL AXES
C *****************************************************************************

      SUBROUTINE TWIN_ORIENTATION (ITWTYPE,TWB,TWN,ATWIN)

      DIMENSION TWB(3),TWN(3),ATWIN(3,3),XID33(3,3)

      DATA XID33/1.,0.,0.,0.,1.,0.,0.,0., 1./


C *** ROTATION OF 180 deg AROUND NORMAL TO TWIN PLANE
      IF(ITWTYPE.EQ.1) THEN
        DO I=1,3
        DO J=1,3
          ATWIN(I,J)=2.*TWN(I)*TWN(J)-XID33(I,J)
        ENDDO
        ENDDO
      ENDIF

C *** ROTATION OF 180 deg AROUND SHEAR VECTOR ON TWIN PLANE
      IF(ITWTYPE.EQ.2) THEN
        DO I=1,3
        DO J=1,3
          ATWIN(I,J)=2.*TWB(I)*TWB(J)-XID33(I,J)
        ENDDO
        ENDDO
      ENDIF

      RETURN
      END

CFEB
C *****************************************************************************
C     SUBROUTINE UPDATE_CRSS_DD      -->     VERSION 29/JUNE/2011

C     Updates the CRSS taking into account dislocation activities.
C     Based on Beyerlein and Tome, IJP 2008.
C     Capolungo replaced 'mode densities' by 'system densities', but kept
C     the same equations (May 2011)

C     Sanitized version of SUBROUTINE UPDATE_CRSS_CG_DISL in VPSC7:
C       algorithms associated with twin barriers, dislocation transfer,
C       and with Composite Grain were eliminated (CT - June 2011)
C *****************************************************************************

      SUBROUTINE UPDATE_CRSS_DD (IOPTION)

      INCLUDE 'vpsc7.dim'

      COMMON/DISL/ SH_MOD,BURG(9),ACTENER(9),BOLTZ,EREF,aKOVB3(9),
     # ACRIT(9),TCRIT(9),YCRIT(9), APROP(9),TPROP(9),YPROP(9),
     # TAU_PROP(9),TAU_CRIT(9),aQ1(9),aQ2(9),aQ0(9),
     # EDOTESO(9),ATAU(9),ALPHA_INT,
     # DELGAM(NSYSMX),RHOSAT(9),aK2(9),TLATENT(9,9),DRAG(9),
     # HPK0(9),HPK1(9),HPSFE(9),HPK2(9),aQ5(9),aQ6,
     # YONE(9),BONE(9),SONE(9),aKGENER(9),
     # RHO_INITS(9),RHO_INITW(9),
     # DELRHOS(NSYSMX),DELRHOW(NSYSMX),
     # RHO_S(NSYSMX,NGRMX),RHO_DEB(NGRMX),
     # ro_for(NMODMX,2),ro_deb(2),ro_tot(2)

C     DIMENSION DMFP(NSYSMX)   ! placeholder for CG model implementation

      iprint=0   ! controls diagnostic print-out

      open(unit=59,file='DIS_DEN.OUT',status='unknown')

      BOLTZ=1.380622E-29      ! units of MPa*m^3/K

      ro_tot(1)=0.
      ro_tot(2)=0.

      IF (IOPTION.EQ.0) THEN

C *** INITIALIZE THE CRSS IN ALL SYSTEMS OF EACH PHASE IN ALL GRAINS
C *** THE 'CHILD' PHASE HAS INITIAL ZERO WEIGHT, AND CRSS's WILL BE
C *** REDEFINED WHEN THE TWINS ARE CREATED.

        IPHEL=1
        IPH  =1

        NSLSYSX=NSLSYS(IPHEL)
        NSLMODX=NSLMOD(IPHEL)
        NMODESX=NMODES(IPHEL)

        NRSX=20        ! power to use in 'rate sensitive' law
        DO IS=1,NSYST(IPH)
          NRS(IS,IPH)=NRSX
          DO JS=1,NSYST(IPH)
            HARD(IS,JS,IPH)=1.0
          ENDDO
        ENDDO

        DO NN=1,NSLMODX
          ro_for(NN,IPHEL)=0.
          ro_deb(IPHEL)=0.
        ENDDO

        write(59,*) ('Rho_for_mod',kk=1,NSLMODX)
     #    ,'       ','Rho_deb','        ','Rho_tot'

C *** READS HARDENING PARAMETERS FOR SLIP AND TWINS (Beyerlein & Tome, 2008)

          READ(UR1,*) SH_MOD,EREF
          READ(UR1,*) ALPHA_INT,aQ6
          DO KMO=1,NSLMODX
            READ(UR1,'(A)') PROSA
            READ(UR1,*) BURG(KMO),ACTENER(KMO)
            READ(UR1,*) aKGENER(KMO),DRAG(KMO)
            READ(UR1,*) EDOTESO(KMO)
            READ(UR1,*) RHO_INITS(KMO),RHO_INITW(KMO)
            READ(UR1,*) YONE(KMO),BONE(KMO),SONE(KMO)
            READ(UR1,*) (TLATENT(KTM,KMO),KTM=1,NTWMOD(IPHEL)) !belongs in twin
            READ(UR1,*) HPK0(KMO),HPK1(KMO),HPK2(KMO)
            READ(UR1,*) aQ0(KMO),aQ1(KMO),aQ2(KMO)

            aKOVB3(KMO)=BOLTZ/(BURG(KMO)**3)     !units of MPa/K
          ENDDO

          IF(NTWMOD(IPHEL).NE.0) THEN
            DO KMO=NSLMODX+1,NMODESX
              READ(UR1,'(A)') PROSA
              READ(UR1,*) YCRIT(KMO),ACRIT(KMO),TCRIT(KMO)
              READ(UR1,*) YPROP(KMO),APROP(KMO),TPROP(KMO)
              READ(UR1,*) BURG(KMO)
              READ(UR1,*) HPK0(KMO)              ! CNT added
            ENDDO
          ENDIF

      ENDIF   ! END OF ioption=0
C **************************************************************************************
C *** CALCULATES INITIAL CRSS (TEMPERATURE DEPENDENT)
C **************************************************************************************

      IF(IOPTION.EQ.1) THEN

C------------------------------------------------------------------------
C   TWO RELATIONSHIPS BETWEEN SHEAR MOD AND TEMP FOR ZR (IN MPA*1000=GPA)
C       SH_MOD=(41.04298-0.02939*TEMPERAT+9.51267E-6*TEMPERAT^2.)*1.e+03
C       SH_MOD=(40.06-0.022*TEMPERAT)*1.e+03
C------------------------------------------------------------------------

C --> EQ 3.26 --> TAU_0_beta FOR THE TWIN SYSTEMS
          IF(NTWMOD(IPHEL).NE.0) THEN
            DO KTM=NSLMODX+1,NMODESX
              TAU_PROP(KTM)=YPROP(KTM)+
     #                      APROP(KTM)*EXP(-TEMPERAT/TPROP(KTM))
              TAU_CRIT(KTM)=YCRIT(KTM)+
     #                      ACRIT(KTM)*EXP(-TEMPERAT/TCRIT(KTM))
            ENDDO
          ENDIF

          DO KKK=NGR(IPH-1)+1,NGR(IPH)

C   ASSIGNS INITIAL VALUES FOR SLIP

          ISM=0
          DO KMO=1,NSLMODX

C --> EQ 3.17 --> TAU_0
            ATAU(KMO)=YONE(KMO)+BONE(KMO)*EXP(-TEMPERAT/SONE(KMO))

            RHO_DEB(KKK)=RHO_INITW(KMO)

            DO IS=1,NSM(KMO,IPHEL)
              ISM=ISM+1

              RHO_S(ISM,KKK)=RHO_INITS(KMO)

C --> EQ 3.19 --> TAU_0 + TAU_for
              TAUE(ISM,KKK)=SH_MOD*ALPHA_INT
     #              *BURG(KMO)*(SQRT(RHO_S(ISM,KKK))) +ATAU(KMO)

C --> EQ 3.20 --> TAU_0 + TAU_for + TAU_deb
              IF(RHO_DEB(KKK).GT.RHO_INITW(KMO))
     #              TAUE(ISM,KKK)=TAUE(ISM,KKK)
     #              -0.086/ALPHA_INT*SQRT(RHO_DEB(KKK))
     #              *LOG(BURG(KMO)*SQRT(RHO_DEB(KKK)))

C --> EQ 3.21 --> TAU_0 + TAU_for + TAU_deb + TAU_hp
C             HPFAC(ISM,IPHEL)=SQRT(BURG(KMO))*HPK0(KMO)*SH_MOD
C             CRSS(ISM,KKK)=TAUE(ISM,KKK)+HPFAC(ISM,IPHEL)/SQRT(GRSZE)

              CRSS(ISM,KKK)=TAUE(ISM,KKK)

        ro_for(KMO,IPHEL)=ro_for(KMO,IPHEL)+wgt(KKK)*RHO_S(ISM,KKK)

            ENDDO            ! end of IS
          ENDDO           ! end of KMO

        ro_deb(IPHEL)=ro_deb(IPHEL)+wgt(KKK)*RHO_DEB(KKK)

C   ASSIGNS INITIAL VALUES FOR TWINNING SYSTEMS
          IF(NTWMOD(IPHEL).NE.0) THEN

          DO KMO=NSLMODX+1,NMODESX
          DO IS=1,NSM(KMO,IPHEL)
            ISM=ISM+1

C --> EQ 3.26 --> TAU_0_beta
            RHOTEMP=0.
            TAUE(ISM,KKK)=TAUE(ISM,KKK)+TAU_PROP(KMO)+
     #        (TAU_CRIT(KMO)-TAU_PROP(KMO)) *EXP(-RHOTEMP)

C --> EQ 3.26 --> TAU_0_beta + TAU_hp
C            HPFAC(ISM,IPHEL)=HPK0(KMO)
C            CRSS(ISM,KKK)=TAUE(ISM,KKK)+HPFAC(ISM,IPHEL)/SQRT(GRSZE)

             CRSS(ISM,KKK)=TAUE(ISM,KKK)

          ENDDO
          ENDDO

          ENDIF

          ngg=10
          iprx=iprint*(ngg/kkk)*(kkk/ngg)
          if(iprx.ne.0) then
            write(10,'('' initial CRSS for grain # '', i4)') kkk
            write(10,'(12f6.0)') (crss(is,kkk),is=1,nsyst(iphel))
          endif

          ENDDO     ! end of KKK

          DO KMO=1,NSLMODX
            ro_tot(IPHEL)=ro_tot(IPHEL)+ro_for(KMO,IPHEL)+ro_deb(IPHEL)
          ENDDO

c      write(59,'(12e15.5)') ((ro_for(KMO,IPHEL),KMO=1,NSLMODX),
c    #   ro_deb(IPHEL),ro_tot(IPHEL))

c      write(59,'(''#10'',e11.3,11x,12e11.3)')            ! only grain #10
c    #          rho_deb(10),(rho_s(KSY,10),KSY=1,NSLSYSX)
c      write(59,'('' GAMD0G for grain #10'', f12.5)') gamd0g(10)
c      write(59,'(12e11.3)') (crss(KSY,10),KSY=1,NSLSYSX)   ! only grain #10

      ENDIF      ! END OF IOPTION=1

C **************************************************************************
C *** UPDATES DISLOCATION DENSITIES AND CRSS's OF SLIP & TWIN SYSTEMS
C **************************************************************************

      IF (IOPTION.EQ.2) THEN

        EDOT=SQRT(2./3.)*VNORM(DBAR,5)

        IPH=1
        IPHEL=1

        NSLSYSX=NSLSYS(IPHEL)
        NSLMODX=NSLMOD(IPHEL)
        NMODESX=NMODES(IPHEL)

        ro_deb(IPHEL)=0.

C       DO IS=1,NSYST(IPHEL)
C         DMFP(IS)=GRSZE
C       ENDDO

        DO KMO=1,NSLMODX

          aQ5(KMO)=aQ0(KMO)+aQ1(KMO)*log(1.+TEMPERAT/aQ2(KMO))

          aK2(KMO)=ALPHA_INT*BURG(KMO)/ACTENER(KMO)
     #           *(1.-aKOVB3(KMO)*TEMPERAT/DRAG(KMO)
     #           *LOG(EDOT/EDOTESO(KMO)))

          RHOSAT(KMO)=aK2(KMO)**(-2.0)

          ro_for(KMO,IPHEL)=0.

        ENDDO

        DO KKK=NGR(IPH-1)+1,NGR(IPH)

          ISM=0
          RHO_DEBx=RHO_DEB(KKK)

          DO KMO=1,NSLMODX
          DO ISY=1,NSM(KMO,IPHEL)

            ISM=ISM+1

            DELRHOS(ISM)=aKGENER(KMO)*SQRT(RHO_S(ISM,KKK))
     #           *(1.0-aK2(KMO)*SQRT(RHO_S(ISM,KKK)))

            DELRHOW(ISM)=aKGENER(KMO)*RHO_S(ISM,KKK)*aK2(KMO)*
     #        (BURG(KMO)*SQRT(RHO_DEBx))*aQ5(KMO)

            IF(DELRHOS(ISM).LT.0.0) DELRHOS(ISM)=0.0

            DELGAM(ISM)=ABS(GAMDOT(ISM,KKK))*TINCR
            RHO_S(ISM,KKK)=RHO_S(ISM,KKK)+DELRHOS(ISM)*DELGAM(ISM)
            RHO_DEB(KKK)=RHO_DEB(KKK)+aQ6*DELRHOW(ISM)*DELGAM(ISM)

          ENDDO      ! end of ISY=1,NSM
            ro_for(KMO,IPHEL)=ro_for(KMO,IPHEL)+wgt(kkk)*RHO_S(ISM,KKK)
          ENDDO      ! end of KMO=1,NSLMODX

          ro_deb(IPHEL)=ro_deb(IPHEL)+wgt(KKK)*RHO_DEB(KKK)

C *** UPDATES crss FOR THE SLIP SYSTEMS USING RECALCULATED DISLOC DENSITIES

          ISM=0
          DO KMO=1,NSLMODX
          DO ISY=1,NSM(KMO,IPHEL)
            ISM=ISM+1
            TAUE(ISM,KKK)=ATAU(KMO)+ALPHA_INT*
     #               BURG(KMO)*SH_MOD*(SQRT(RHO_S(ISM,KKK))
     #               -0.086/ALPHA_INT*SQRT(RHO_DEB(KKK))
     #                 *LOG(BURG(KMO)*SQRT(RHO_DEB(KKK))))

          ENDDO      ! end of ISY=1,NSM
          ENDDO      ! end of KMO=1,NSLMODX

C *** UPDATES crss FOR THE TWINNING SYSTEMS (COUPLED WITH DISL DENS)

          IF(NTWMOD(IPHEL).NE.0) THEN

          DO IMO=NSLMODX+1,NMODESX
          DO IS =1,NSM(IMO,IPHEL)
            ISM=ISM+1
            TAUE(ISM,KKK) =0.0
            RHOTEMP=0.0

            JSM=0
            DO JMO=1,NSLMODX
            DO JS =1,NSM(JMO,IPHEL)
              JSM=JSM+1

              TAUE(ISM,KKK)=TAUE(ISM,KKK)+SH_MOD*BURG(IMO)*
     #           BURG(JMO)*TLATENT(IMO,JMO)*RHO_S(JSM,KKK)
              RHOTEMP=RHOTEMP+RHO_S(JSM,KKK)/RHOSAT(JMO)

            ENDDO
            ENDDO

            TAUE(ISM,KKK)=TAUE(ISM,KKK)+TAU_PROP(IMO)+
     #        (TAU_CRIT(IMO)-TAU_PROP(IMO)) *exp(-RHOTEMP)

            IF (TAUE(ISM,KKK).le.0.0) TAUE(ISM,KKK)=1.0

          ENDDO
          ENDDO

          ENDIF

C *** HALL-PETCH EFFECT ON TAUE FOR SLIP AND TWINNING
C --> THE CALCULATION OF THE MEAN FREE PATH DEFINED BY THE PREDOMINANT
C     TWIN UPON EACH SYSTEM (DMFP(IS)) NEEDS TO BE REPROGRAMMED
C
C         DO IS=1,NSYST(IPHEL)
C           TAUHP=HPFAC(IS,IPHEL)/SQRT(DMFP(IS))
C           CRSS(IS,KKK)=TAUE(IS,KKK)+TAUHP
C         ENDDO

          DO IS=1,NSYST(IPHEL)
            CRSS(IS,KKK)=TAUE(IS,KKK)
          ENDDO

      ngg=10
      iprx=iprint*(ngg/kkk)*(kkk/ngg)
      if(iprx.ne.0) then
          write(10,'('' CRSS for grain  '',i5,6x,3f6.0,/,(12f6.0))')
     #          kkk,(crss(is,kkk),is=1,nsyst(iphel))
          gamdnorm=Vnorm(dbar,5)
          write(10,'('' GAMD(is,kkk)'',i5,6x,3f7.2,/,(12f7.2))')
     #          kkk,(gamdot(is,kkk)/gamdnorm,is=1,nsyst(iphel))
      endif

        ENDDO      ! END OF LOOP kkk OVER GRAINS

      do kmo=1,NSLMODX
        ro_tot(IPHEL)=ro_tot(IPHEL)+ro_for(KMO,IPHEL)+ro_deb(IPHEL)
      end do

c      write(59,'(12e12.4)') ((ro_for(KMO,IPHEL),KMO=1,NSLMODX),
c    #   ro_deb(IPHEL),ro_tot(IPHEL))
c      write(59,'(''#10'',e11.3,11x,12e11.3)')            ! only grain #10
c    #          rho_deb(10),(rho_s(KSY,10),KSY=1,NSLSYSX)
c      write(59,'('' GAMD0G for grain #10'', f12.5)') gamd0g(10)
c      write(59,'(12e11.3)') (crss(KSYK,10),KSY=1,NSLSYSX)   ! only grain #10

      ENDIF      ! END OF IF(IOPTION.EQ.2)
C ***************************************************************************************

      RETURN
      END

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     SUBROUTINE UPDATE_CRSS_DD_CE2_new  -->      VERSION 10/Apr/2012
C
C *** Hardening law of version 2 hardening model
c       --> evolving disloca densities associated with deformation modes.
C *** coded by k.kitayama
C
C if IOPTION=0: reads parameters, calculates elastic shear moduli.
C if IOPTION=1: initializes TAU & RHO using parameters and current temperat.
C if IOPTION=2: updates dislocation densities RHO and critical stress CRSS
C               in every system
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      SUBROUTINE UPDATE_CRSS_DD_CE2 (ioption)
      implicit double precision (a-h,o-z)

      real(8),parameter :: gamdsm=0.d0
      real(8),parameter :: rhosm =1.d0

      INCLUDE 'vpsc7.dim'

      common/DisDen_CE2/alpha_CE2(NMODMX),xMu_CE2(NMODMX),xb_CE2(NMODMX)
     1          ,tau0_CE2(NMODMX),xf_self_CE2(NMODMX),xf_lat_CE2(NMODMX)
     2          ,xL_CE2(NMODMX),xD_CE2(NMODMX)
     3          ,xK_CE2(NMODMX),xlambda_CE2(NGRMX)
     4          ,rho_f_CE2(NSYSMX,NGRMX),rho_r_CE2(2*NSYSMX,NGRMX)
     5          ,rho_prev_CE2(NSYSMX,NGRMX),xInflectionP(NMODMX)
     6          ,rho_deb(NGRMX),xp_CE2(NGRMX)

       double precision :: tmp_xlambda_CE(NGRMX),tmp_rho_f_CE(NGRMX),
     1                    tmp_rho_r_CE(NGRMX),tmp_rho_l_CE(NGRMX),
     2                    gamdot_rm(2),tmp_p

CNT --> ARRAYS BELOW RELATED TO CALCULATION OF SHEAR MODULUS

      DIMENSION AUX6(6),AUX33(3,3),AUX3333(3,3,3,3),AUX5(5),AUX55(5,5),
     #          C4CA(3,3,3,3),SCHCAX(5),SCH33(3,3)

      character(len=100) :: memo

      IPRINT=0

c-----------------------------------------------------------------------
c Reads hardening law parameters
c-----------------------------------------------------------------------

      if(ioption.eq.0) then

        open(500,file='disden.out',status='replace')
        open(501,file='debug.txt',status='replace')
!        open(502,file='GAMDOT.txt',status='replace')
!        open(503,file='rho_f.txt',status='replace')
!        open(504,file='rho_r1.txt',status='replace')
!        open(505,file='rho_r2.txt',status='replace')
!        open(506,file='TAUE.txt',status='replace')
!        open(507,file='dev_anih.txt',status='replace')
!        open(510,file='develop.txt',status='replace')
        open(511,file='p_averaged_over_all_grain.txt',status='replace')

        write(500,'(4X,''STRAIN'',18x,''FORWARD'',18x,''REVERSE1'',18X,
     #                 ''REVERSE2'')')
        write(511,'(4X,''STRAIN'',18X,''P'')')

        IPHEL=1
        IPH  =1

        NSLSYSX=NSLSYS(IPHEL)
        NSLMODX=NSLMOD(IPHEL)
        NMODESX=NMODES(IPHEL)
        NTWMODX=0
        ISECTWX=0

        NRSX=20        ! power to use in 'rate sensitive' law
        DO IS=1,NSYST(IPH)
          NRS(IS,IPH)=NRSX
        ENDDO
        rho_f_CE2(:,:)=0.d0
        rho_r_CE2(:,:)=0.d0
        rho_prev_CE2(:,:)=0.d0
        rho_deb(:)=0.d0

        DO im=1,NMODESX
          READ(1,*) memo
          READ(1,*) alpha_CE2(im)   ! alpha
          READ(1,*) xMu_CE2(im)     ! mu [MPa]
          READ(1,*) xb_CE2(im)      ! b [m]
          READ(1,*) tau0_CE2(im)    ! t0 at 20 deg.
          READ(1,*) xK_CE2(im)      ! K at 20 deg.
          READ(1,*) xD_CE2(im)      ! D [m]
          READ(1,*) xf_self_CE2(im) ! f_self
          READ(1,*) xf_lat_CE2(im)  ! f_lat
!          READ(1,*) xp_CE2(im)      ! p
          READ(1,*) xInflectionP(im)! RHO at inflection point for P
          READ(1,*) xL_CE2(im)      ! L
          if(im > NSLSYSX) then
            READ(1,*) ISECTWX       ! ISECTWX
            READ(1,*) THRES1X       ! THRES1X
            READ(1,*) THRES2X       ! THRES2X
            NTWMODX=NTWMODX+1       ! Count the twinning system number
            TWTHRES(1,NTWMODX,IPH)=THRES1X
            TWTHRES(2,NTWMODX,IPH)=THRES2X
          end if
          istart=0 ; iend=0
          do ii=1,IM
            istart=istart+NSM(IM,IPH)
            iend=iend+NSM(IM+1,IPH)
          end do
          ISECTW(1+istart:iend,iph)=ISECTWX
        ENDDO


C *** CALCULATES 4TH ORDER ELASTIC STIFFNESS TENSOR FROM 6X6 TENSOR
        CALL VOIGT(AUX6,AUX33,C2CA,C4CA,3)      ! CNT Sep 2011
        ISX=0
        DO IM=1,NMODESX

          write(10,*)
          write(10,'('' MODE'',I5,''   ELASTIC SHEAR MODULUS READ''
     #                 ,F13.5)') IM,xMu_CE2(IM)

          ISX=ISX+NSM(IM,IPHEL)
C *** CALCULATES 2nd ORDER SCHMID TENSOR FROM 5-DIM VECTOR
          DO I=1,5
            SCHCAX(I)=SCHCA(I,ISX,IPHEL)
          ENDDO
          CALL CHG_BASIS(SCHCAX,SCH33,AUX55,AUX3333,1,5)
C *** CALCULATES SHEAR MODULUS FOR MODE 'IM' BY PROJECTING ELASTIC STIFFNESS
          xMu_x=0.
          do i=1,3
           do j=1,3
            do k=1,3
             do l=1,3
               xMu_x=xMu_x+SCH33(i,j)*C4CA(i,j,k,l)*SCH33(k,l)
             enddo
            enddo
           enddo
          enddo

          write(10,*)
          write(10,'('' MODE'',I4,''  CALCULATED ELASTIC SHEAR MODULUS''
     #                 ,F13.5)') IM,xMu_x

CNT --> COMMENTED OUT UNTIL WE CLARIFY INCONSISTENCY BETWEEN READ AND
C       CALCULATED SHEAR MODULUS

CCC       xMu_CE2(IM)=xMu_x

        ENDDO

        do kmo=1,NMODESX
          xlambda_CE2(:)=xD_CE2(kmo)
        end do

      endif

c------------------------------------------------------------------------
c *** Initialization of CRSS tau for the first step
c------------------------------------------------------------------------
      if(ioption.eq.1) then

        IPHEL=1
        IPH  =1

        DO KKK=NGR(IPH-1)+1,NGR(IPH)

c assigns initial values for grain

          xp_CE2(KKK)=0.5d0-0.5d0
     1        *dtanh(-4.d0)

C   ASSIGNS INITIAL VALUES FOR SLIP

          ISM=0
          DO KMO=1,NMODES(IPH)
            DO IS=1,NSM(KMO,IPHEL)
              ISM=ISM+1

              taue(ISM,KKK)=tau0_CE2(KMO)
              CRSS(ISM,KKK)=taue(ISM,KKK)

            ENDDO            ! end of IS
          ENDDO           ! end of KMO
        ENDDO     ! end of KKK
      ENDIF      ! END OF IOPTION=1


c-------------------------------------------------------------------------
c *** Construct hardening matrix and develop the dislocation densities
c-------------------------------------------------------------------------
      IF (IOPTION.EQ.2) THEN

        IPH=1
        IPHEL=1

        NSLSYSX=NSLSYS(IPHEL)
        NSLMODX=NSLMOD(IPHEL)
        NMODESX=NMODES(IPHEL)

        ! For output dislocation densities averaged whole over the grain
        cnst1=0.d0 ; cnst2=0.d0 ; cnst3=0.d0
        ! For output P averaged over all the grain
        tmp_p=0.d0

        KGX=1
        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
          DO KKK=NGR(IPH-1)+1,NGR(IPH)

            ! For output dislocation densities at perticuler slip system
            cnstg1=0.d0 ; cnstg2=0.d0 ; cnstg3=0.d0

            GAMTOTX=GTOTGR(KGX)
            DELTGAM=0.0
            DO IS=1,NSYST(IPHEL)
              DELTGAM=DELTGAM+ABS(GAMDOT(IS,KGX))*TINCR
            ENDDO

            HARD(:,:,IPHEL)=0.d0

            ISM=0
            DO KMO=1,NSLMODX
              DO ISY=1,NSM(KMO,IPHEL)

                ISM=ISM+1
                rhotot=rho_f_CE2(ism,kgx)
     1          +rho_r_CE2(2*ism-1,kgx)+rho_r_CE2(2*ism,kgx)
                if(rhotot <= rhosm) rhotot=rhosm

                i_rm_flag=int(0)
                ! i_rm_flag : if this flag is activated (==1), suggested slip increment is too large

                do

                  if(GAMDOT(ISM,KGX) > GAMDSM) then

                    DGAM=GAMDOT(ISM,KGX)*TINCR

                    drho_f_1=0.d0    ; drho_f_2=0.d0
                    drho_r_si_1=0.d0 ; drho_r_si_2=0.d0
                    drho_r_sj_1=0.d0 ; drho_r_sj_2=0.d0

                    bl=xb_CE2(KMO)*xlambda_CE2(KGX)

                    if((rho_r_CE2(2*ISM-1,KGX) >= 0.d0 .and.
     1                 rho_r_CE2(2*ISM,KGX)==0.d0) .or.
     2                 i_rm_flag==int(1)) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(2)*TINCR
                      ! Evolution for rho_for
!                      drho_f_1=(1.d0-xp_CE2(KMO))*DGAM/bl
!     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_1=(1.d0-xp_CE2(kgx))*DGAM/bl
     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
!                      drho_r_si_1=
!     1                     xp_CE2(KMO)*DGAM/bl
!     2                     -xf_self_CE2(KMO)*rho_r_CE2(2*ISM-1,KGX)*DGAM
                      drho_r_si_1=
     1                  xp_CE2(kgx)*DGAM/bl
     2                  -xf_self_CE2(KMO)*rho_r_CE2(2*ISM-1,KGX)*DELTGAM

                      ! Evolution for rho_r_sj
                      ! In this case, rho_r_sj remains zero
                      drho_r_sj_1=0.d0

!                      rho_prev_CE2(ism,kgx)=rhotot
                      rho_prev_CE2(ism,kgx)=rho_f_CE2(ism,kgx)+drho_f_1
     1                +rho_r_CE2(2*ism-1,kgx)+drho_r_si_1
     2                +rho_r_CE2(2*ism ,kgx)+drho_r_sj_1

                    end if
                    if((rho_r_CE2(2*ISM-1,KGX) == 0.d0 .and.
     1                     rho_r_CE2(2*ISM,KGX) > 0.d0) .or.
     2                     i_rm_flag==int(1)) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(1)*TINCR
                      ! Evolution for rho_for
!                      drho_f_2=DGAM/bl
!     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_2=DGAM/bl
     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
                      ! In this case, rho_r_si remains zero
                      drho_r_si_2=0.d0

                      ! Evolution for rho_r_sj
                      drho_r_sj_2=
     1               -DGAM/bl*rho_r_CE2(2*ISM,KGX)/rho_prev_CE2(ism,kgx)
!                      drho_r_sj_2=
!     1                  -DELTGAM/bl*rho_r_CE2(2*ISM,KGX)/rhotot

                    end if

                  else if(GAMDOT(ISM,KGX) < -GAMDSM) then

                    DGAM=-GAMDOT(ISM,KGX)*TINCR
                    bl=xb_CE2(KMO)*xlambda_CE2(KGX)

                    drho_f_1=0.d0    ; drho_f_2=0.d0
                    drho_r_si_1=0.d0 ; drho_r_si_2=0.d0
                    drho_r_sj_1=0.d0 ; drho_r_sj_2=0.d0

                    if((rho_r_CE2(2*ism-1,kgx) == 0.d0 .and.
     1                rho_r_CE2(2*ism,kgx) >= 0.d0) .or.
     2                i_rm_flag==int(1)) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(2)*TINCR

                      ! Evolution for rho_for
!                      drho_f_1=(1.d0-xp_CE2(KMO))*DGAM/bl
!     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_1=(1.d0-xp_CE2(kgx))*DGAM/bl
     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
                      drho_r_si_1=0.d0

                      ! Ebolution for rho_r_sj
!                      drho_r_sj_1=xp_CE2(KMO)*DGAM/bl
!     1                      -xf_self_CE2(KMO)*rho_r_CE2(2*ISM,KGX)*DGAM
                      drho_r_sj_1=xp_CE2(kgx)*DGAM/bl
     1                    -xf_self_CE2(KMO)*rho_r_CE2(2*ISM,KGX)*DELTGAM

                      rho_prev_CE2(ism,kgx)=rho_f_CE2(ism,kgx)+drho_f_1
     1                +rho_r_CE2(2*ism-1,kgx)+drho_r_si_1
     2                +rho_r_CE2(2*ism ,kgx)+drho_r_sj_1


                    end if
                    if(rho_r_CE2(2*ism-1,kgx) > 0.d0 .and.
     1                     rho_r_CE2(2*ism,kgx) == 0.d0) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(1)*TINCR

                      ! Evolution for rho_for
!                      drho_f_2=DGAM/bl
!     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_2=DGAM/bl
     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
                      ! In this case, rho_r_si remains zero
                      drho_r_si_2=
     1             -DGAM/bl*rho_r_CE2(2*ISM-1,KGX)/rho_prev_CE2(ism,kgx)
!                      drho_r_si_2=
!     1                   -DELTGAM/bl*rho_r_CE2(2*ISM-1,KGX)/rhotot

                      ! Evolution for rho_r_sj
                      drho_r_sj_2=0.d0

                    end if
     1
                  else

                    drho_f_1   =
     1                 -xf_lat_CE2(KMO)*rho_f_CE2(ism,kgx)    *DELTGAM
                    drho_r_si_1=
     1                 -xf_lat_CE2(kmo)*rho_r_CE2(2*ism-1,kgx)*DELTGAM
                    drho_r_sj_1=
     1                 -xf_lat_CE2(kmo)*rho_r_CE2(2*ism,kgx)  *DELTGAM

                    drho_f_2=0.d0 ; drho_r_si_2=0.d0 ; drho_r_sj_2=0.d0

                  end if

                  tmp2=rho_r_CE2(2*ism-1,kgx)+drho_r_si_1+drho_r_si_2
                  tmp3=rho_r_CE2(2*ism,kgx)  +drho_r_sj_1+drho_r_sj_2

                  if(tmp2 <= rhosm) then
                    drho_r_si_1=-rho_r_CE2(2*ism-1,kgx)
                    drho_r_si_2=0.d0
                    tmp2=rho_r_CE2(2*ism-1,kgx)+drho_r_si_1+drho_r_si_2
                  end if
                  if(tmp3 <= rhosm) then
                    drho_r_sj_1=-rho_r_CE2(2*ism,kgx)
                    drho_r_sj_2=0.d0
                    tmp3=rho_r_CE2(2*ism,kgx)  +drho_r_sj_1+drho_r_sj_2
                  end if


                  if(min(tmp2,tmp3) >= 0.d0) exit

                  i_rm_flag=int(1)
                  gamdot_rm(1)=
     1            dabs((xb_CE2(KMO)*xlambda_CE2(KGX)*rhotot)/tincr)
                  gamdot_rm(2)=dabs(gamdot(ism,kgx))-dabs(gamdot_rm(1))

                end do

                rho_f_CE2(ism,kgx)
     1                  =rho_f_CE2(ism,kgx)    +drho_f_1+drho_f_2
                rho_r_CE2(2*ism-1,kgx)
     1                  =rho_r_CE2(2*ism-1,kgx)+drho_r_si_1+drho_r_si_2
                rho_r_CE2(2*ism,kgx)
     1                  =rho_r_CE2(2*ism,kgx)  +drho_r_sj_1+drho_r_sj_2


                cnst1=cnst1+rho_f_CE2(ism,kgx)     *wgt(kgx)   ! CNT Sept 2011
                cnst2=cnst2+rho_r_CE2(2*ism-1,kgx) *wgt(kgx)
                cnst3=cnst3+rho_r_CE2(2*ism  ,kgx) *wgt(kgx)


                cnstg1=cnstg1+rho_f_CE2(ism,kgx)
                cnstg2=cnstg2+rho_r_CE2(2*ism-1,kgx)
                cnstg3=cnstg3+rho_r_CE2(2*ism  ,kgx)

              end do      ! end of do isy=1,nsm
            end do        ! end of do kmo=1,nslmod


C *** TOTAL DENSITY IN THE GRAIN, SUM OF FOREST AND REVERSE DENSITIES
CNT --> I MOVED THIS LOOP BEFORE THE NEXT LOOP BECAUSE IT IS ALWAYS THE SAME
C   CALCULATION !! I STORE IT IN rho_tot

            rho_tot=0.d0
            DO JS=1,NSYST(IPHEL)
              rho_tot  =rho_tot  +rho_f_CE2(js,kgx)
     1               +rho_r_CE2(2*js-1,kgx)+rho_r_CE2(2*js,kgx)
            ENDDO

            ! Update the debris dislocation density and P
            rho_deb(kgx)=rho_deb(kgx)
     1               +rho_tot*dabs(DELTGAM)


            xp_CE2(KGX)=0.5d0-0.5d0
     1               *dtanh(4.d0*rho_deb(kgx)/xInflectionP(1)-4.d0)

            tmp_p=tmp_p+xp_CE2(KGX)*wgt(kgx)

C *** CALCULATES EFFECTIVE DENSITY THAT GOES IN THE HARDENING LAW

CNT --> I THINK THAT THE REVERSIBLE DISLOCATIONS THAT
C   MAY HELP SHEAR IN THE OPPOSITE SENSE SHOULD NOT ADD BUT SUBSTRACT TO THE
C   EFFECTIVE DISLOCATION DENSITY CONTRIBUTING TO SHEAR.
C   THIS IS WHAT THE NEW ALGORITHM BELOW DOES: IT WILL LOWER THE CRSS IN A
C   SYSTEM IF THERE ARE AVAILABLE REVERSIBLE DISLOCATIONS IN THE OPPOSITE SYST

            DO IS=1,NSYST(IPHEL)

              RHO_EFF=rho_tot*xL_CE2(1)-(xL_CE2(1)-1.d0)
     1          *(rho_f_CE2(is,kgx)+rho_r_CE2(2*is-1,kgx)
     2            +rho_r_CE2(2*is,kgx))

             if(RHO_EFF < 0.d0) RHO_EFF=0.d0    ! CNT --> avoid negative sqrt

              taue(is,kgx)=tau0_CE2(1)
     1        +alpha_CE2(1)*xMu_CE2(1)*xb_CE2(1)*dsqrt(RHO_EFF)

            ENDDO

            xlambda_CE2(kgx)=
     1      1.d0/(dsqrt(rho_tot)/xK_CE2(1)+1.d0/xD_CE2(1))   ! CNT changed

C *** UPDATES crss FOR THE SLIP SYSTEMS USING RECALCULATED DISLOC DENSITIES

            DO IS=1,NSYST(IPHEL)
              CRSS(IS,KGX)=TAUE(IS,KGX)
            ENDDO

            ngg=10
            iprx=iprint*(ngg/kkk)*(kkk/ngg)
            if(iprx.ne.0) then
              write(10,'('' CRSS for grain  '',i5,6x,3f6.0,/,(12f6.0))')
     #          kkk,(crss(is,kkk),is=1,nsyst(iphel))
c         gamdnorm=tnorm5(dbar,5,1)
c         write(10,'('' GAMD(is,kkk)'',i5,6x,3f7.2,/,(12f7.2))')
c     #          kkk,(gamdot(is,kkk)/gamdnorm,is=1,nsyst(iphel))
            endif

!            GTOTGR(KGX)=GAMTOTX+DELTGAM

            KGX=KGX+1

          ENDDO      ! END OF LOOP kkk OVER GRAINS
        END DO ! END OF LOOP IPH OVER PHASES

CNT --> this is not right when grains have different volume fractions
C        cnst1=cnst1/dble(NGR(IPHTOP))
C        cnst2=cnst2/dble(NGR(IPHTOP))
C        cnst3=cnst3/dble(NGR(IPHTOP))

!        if(IPHTOP /= 1) write(500,'(a)') 'This result is wrong. Check ou
!     1tput part'

        write(500,'(4d20.10)') epsvm,cnst1,cnst2,cnst3
        write(511,'(2d20.10)') epsvm,tmp_p
!        write(501,'(d20.10,I10)') epsvm,i_activeSlip
!        write(502,'(25d20.10)') epsvm,GAMDOT(1:24,1)
!        write(503,'(25d20.10)') epsvm,rho_f_CE2(1:24,1)
!        write(504,'(25d20.10)') epsvm,rho_r_CE2(1:48:2,1)
!        write(505,'(25d20.10)') epsvm,rho_r_CE2(2:49:2,1)
!        write(506,'(25d20.10)') epsvm,CRSS(1:24,1)

!        write(500,'(4d20.10)') GTOTGR(50),rho_f_CE(50),
!     1                          rho_r_CE(50),rho_l_CE(50)


      ENDIF      ! END OF IF(IOPTION.EQ.2)

c ______________________________________________________________________

      RETURN
      END

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     SUBROUTINE UPDATE_CRSS_DD_CE2_old      -->      VERSION 30/Nov/2011
C
C *** Hardening law of version 2 hardening model
c       --> evolving disloca densities associated with deformation modes.
C *** coded by k.kitayama
C
C if IOPTION=0: reads parameters, calculates elastic shear moduli.
C if IOPTION=1: initializes TAU & RHO using parameters and current temperat.
C if IOPTION=2: updates dislocation densities RHO and critical stress CRSS
C               in every system
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      SUBROUTINE UPDATE_CRSS_DD_CE2_old (ioption)
      implicit double precision (a-h,o-z)

      real(8),parameter :: gamdsm=0.d0
      real(8),parameter :: rhosm =1.d0

      INCLUDE 'vpsc7.dim'

      common/DisDen_CE/alpha_CE2(NMODMX),xMu_CE2(NMODMX),xb_CE2(NMODMX)
     1          ,tau0_CE2(NMODMX),xf_self_CE2(NMODMX),xf_lat_CE2(NMODMX)
     2          ,xL_CE2(NMODMX),xp_CE2(NMODMX),xD_CE2(NMODMX)
     3          ,xK_CE2(NMODMX),xlambda_CE2(NGRMX)
     4          ,rho_f_CE2(NSYSMX,NGRMX),rho_r_CE2(2*NSYSMX,NGRMX)
     5          ,rho_prev_CE2(NSYSMX,NGRMX)

       double precision :: tmp_xlambda_CE(NGRMX),tmp_rho_f_CE(NGRMX),
     1                    tmp_rho_r_CE(NGRMX),tmp_rho_l_CE(NGRMX),
     2                    gamdot_rm(2)

CNT --> ARRAYS BELOW RELATED TO CALCULATION OF SHEAR MODULUS

      DIMENSION AUX6(6),AUX33(3,3),AUX3333(3,3,3,3),AUX5(5),AUX55(5,5),
     #          C4CA(3,3,3,3),SCHCAX(5),SCH33(3,3)

      character(len=100) :: memo

!      double precision,save :: rhotot_old(nsysmx)

      IPRINT=0

c-----------------------------------------------------------------------
c Reads hardening law parameters
c-----------------------------------------------------------------------

      if(ioption.eq.0) then

        open(500,file='disden.out',status='replace')
        open(501,file='debug.txt',status='replace')
        open(502,file='GAMDOT.txt',status='replace')
        open(503,file='rho_f.txt',status='replace')
        open(504,file='rho_r1.txt',status='replace')
        open(505,file='rho_r2.txt',status='replace')
        open(506,file='TAUE.txt',status='replace')
        open(507,file='dev_anih.txt',status='replace')
        open(510,file='develop.txt',status='replace')

        write(500,'(4X,''STRAIN'',18x,''FORWARD'',18x,''REVERSE1'',18X,
     #                 ''REVERSE2'')')

        IPHEL=1
        IPH  =1

        NSLSYSX=NSLSYS(IPHEL)
        NSLMODX=NSLMOD(IPHEL)
        NMODESX=NMODES(IPHEL)
        NTWMODX=0
        ISECTWX=0

        NRSX=20        ! power to use in 'rate sensitive' law
        DO IS=1,NSYST(IPH)
          NRS(IS,IPH)=NRSX
        ENDDO
        rho_f_CE2(:,:)=0.d0
        rho_r_CE2(:,:)=0.d0
        rho_prev_CE2(:,:)=0.d0

        DO im=1,NMODESX
          READ(1,*) memo
          READ(1,*) alpha_CE2(im)   ! alpha
          READ(1,*) xMu_CE2(im)     ! mu [MPa]
          READ(1,*) xb_CE2(im)      ! b [m]
          READ(1,*) tau0_CE2(im)    ! t0 at 20 deg.
          READ(1,*) xK_CE2(im)      ! K at 20 deg.
          READ(1,*) xD_CE2(im)      ! D [m]
          READ(1,*) xf_self_CE2(im) ! f_self
          READ(1,*) xf_lat_CE2(im)  ! f_lat
          READ(1,*) xp_CE2(im)      ! p
          READ(1,*) xL_CE2(im)      ! L
          if(im > NSLSYSX) then
            READ(1,*) ISECTWX       ! ISECTWX
            READ(1,*) THRES1X       ! THRES1X
            READ(1,*) THRES2X       ! THRES2X
            NTWMODX=NTWMODX+1       ! Count the twinning system number
            TWTHRES(1,NTWMODX,IPH)=THRES1X
            TWTHRES(2,NTWMODX,IPH)=THRES2X
          end if
          istart=0 ; iend=0
          do ii=1,IM
            istart=istart+NSM(IM,IPH)
            iend=iend+NSM(IM+1,IPH)
          end do
          ISECTW(1+istart:iend,iph)=ISECTWX
        ENDDO

C *** CALCULATES 4TH ORDER ELASTIC STIFFNESS TENSOR FROM 6X6 TENSOR
        CALL VOIGT(AUX6,AUX33,C2CA,C4CA,3)      ! CNT Sep 2011
        ISX=0
        DO IM=1,NMODESX

          write(10,*)
          write(10,'('' MODE'',I5,''   ELASTIC SHEAR MODULUS READ''
     #                 ,F13.5)') IM,xMu_CE2(IM)

          ISX=ISX+NSM(IM,IPHEL)
C *** CALCULATES 2nd ORDER SCHMID TENSOR FROM 5-DIM VECTOR
          DO I=1,5
            SCHCAX(I)=SCHCA(I,ISX,IPHEL)
          ENDDO
          CALL CHG_BASIS(SCHCAX,SCH33,AUX55,AUX3333,1,5)
C *** CALCULATES SHEAR MODULUS FOR MODE 'IM' BY PROJECTING ELASTIC STIFFNESS
          xMu_x=0.
          do i=1,3
           do j=1,3
            do k=1,3
             do l=1,3
               xMu_x=xMu_x+SCH33(i,j)*C4CA(i,j,k,l)*SCH33(k,l)
             enddo
            enddo
           enddo
          enddo

          write(10,*)
          write(10,'('' MODE'',I4,''  CALCULATED ELASTIC SHEAR MODULUS''
     #                 ,F13.5)') IM,xMu_x

CNT --> COMMENTED OUT UNTIL WE CLARIFY INCONSISTENCY BETWEEN READ AND
C       CALCULATED SHEAR MODULUS

CCC       xMu_CE2(IM)=xMu_x

        ENDDO

!        do kkk=ngr(iph-1)+1,ngr(iph)
          ! initialization for mean free path
          do kmo=1,NMODESX
            xlambda_CE2(:)=xD_CE2(kmo)
          end do
!        end do

      endif

c------------------------------------------------------------------------
c *** Initialization of CRSS tau for the first step
c------------------------------------------------------------------------
      if(ioption.eq.1) then

        IPHEL=1
        IPH  =1

        DO KKK=NGR(IPH-1)+1,NGR(IPH)

C   ASSIGNS INITIAL VALUES FOR SLIP

          ISM=0
          DO KMO=1,NMODES(IPH)
            DO IS=1,NSM(KMO,IPHEL)
              ISM=ISM+1

              taue(ISM,KKK)=tau0_CE2(KMO)
              CRSS(ISM,KKK)=taue(ISM,KKK)

            ENDDO            ! end of IS
          ENDDO           ! end of KMO
        ENDDO     ! end of KKK
      ENDIF      ! END OF IOPTION=1


c-------------------------------------------------------------------------
c *** Construct hardening matrix and develop the dislocation densities
c-------------------------------------------------------------------------
      IF (IOPTION.EQ.2) THEN

!        i_activeSlip=0

        IPH=1
        IPHEL=1

        NSLSYSX=NSLSYS(IPHEL)
        NSLMODX=NSLMOD(IPHEL)
        NMODESX=NMODES(IPHEL)

        ! For output dislocation densities averaged whole over the grain
        cnst1=0.d0 ; cnst2=0.d0 ; cnst3=0.d0

        KGX=1
        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
          DO KKK=NGR(IPH-1)+1,NGR(IPH)

            ! For output dislocation densities at perticuler slip system
            cnstg1=0.d0 ; cnstg2=0.d0 ; cnstg3=0.d0

            GAMTOTX=GTOTGR(KGX)
            DELTGAM=0.0
            DO IS=1,NSYST(IPHEL)
              DELTGAM=DELTGAM+ABS(GAMDOT(IS,KGX))*TINCR
            ENDDO

!            ism=0
!            rhotot=0.d0
!            do kmo=1,nslmodx
!              do isy=1,nsm(kmo,iphel)
!                ism=ism+1
!                rhotot=rhotot+rho_f_CE2(ism,kgx)
!     1          +rho_r_CE2(2*ism-1,kgx)+rho_r_CE2(2*ism,kgx)
!              end do
!            end do
!            if(rhotot <= rhosm) rhotot=rhosm
            ! rhotot : total dislocation density of rho_f and rho_r

            HARD(:,:,IPHEL)=0.d0

            ISM=0
            DO KMO=1,NSLMODX
              DO ISY=1,NSM(KMO,IPHEL)

                ISM=ISM+1
                rhotot=rho_f_CE2(ism,kgx)
     1          +rho_r_CE2(2*ism-1,kgx)+rho_r_CE2(2*ism,kgx)
                if(rhotot <= rhosm) rhotot=rhosm

                i_rm_flag=int(0)
                ! i_rm_flag : if this flag is activated (==1), suggested slip increment is too large

                do

                  if(GAMDOT(ISM,KGX) > GAMDSM) then

                    DGAM=GAMDOT(ISM,KGX)*TINCR

                    drho_f_1=0.d0    ; drho_f_2=0.d0
                    drho_r_si_1=0.d0 ; drho_r_si_2=0.d0
                    drho_r_sj_1=0.d0 ; drho_r_sj_2=0.d0

                    bl=xb_CE2(KMO)*xlambda_CE2(KGX)

                    if((rho_r_CE2(2*ISM-1,KGX) >= 0.d0 .and.
     1                 rho_r_CE2(2*ISM,KGX)==0.d0) .or.
     2                 i_rm_flag==int(1)) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(2)*TINCR
                      ! Evolution for rho_for
!                      drho_f_1=(1.d0-xp_CE2(KMO))*DGAM/bl
!     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_1=(1.d0-xp_CE2(KMO))*DGAM/bl
     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
!                      drho_r_si_1=
!     1                     xp_CE2(KMO)*DGAM/bl
!     2                     -xf_self_CE2(KMO)*rho_r_CE2(2*ISM-1,KGX)*DGAM
                      drho_r_si_1=
     1                  xp_CE2(KMO)*DGAM/bl
     2                  -xf_self_CE2(KMO)*rho_r_CE2(2*ISM-1,KGX)*DELTGAM

                      ! Evolution for rho_r_sj
                      ! In this case, rho_r_sj remains zero
                      drho_r_sj_1=0.d0

                      rho_prev_CE2(ism,kgx)=rhotot
!                      rho_prev_CE2(ism,kgx)=rho_f_CE2(ism,kgx)+drho_r_1
!     1                +rho_r_CE2(2*ism-1,kgx)+drho_r_si_1
!     2                +rho_r_CE2(2*ism ,kgx)+drho_r_sj_1

                    end if
                    if((rho_r_CE2(2*ISM-1,KGX) == 0.d0 .and.
     1                     rho_r_CE2(2*ISM,KGX) > 0.d0) .or.
     2                     i_rm_flag==int(1)) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(1)*TINCR
                      ! Evolution for rho_for
!                      drho_f_2=DGAM/bl
!     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_2=DGAM/bl
     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
                      ! In this case, rho_r_si remains zero
                      drho_r_si_2=0.d0

                      ! Evolution for rho_r_sj
!                      drho_r_sj_2=
!     1               -DGAM/bl*rho_r_CE2(2*ISM,KGX)/rho_prev_CE2(ism,kgx)
                      drho_r_sj_2=
     1                  -DGAM/bl*rho_r_CE2(2*ISM,KGX)/rhotot
!                      drho_r_sj_2=
!     1                  -DELTGAM/bl*rho_r_CE2(2*ISM,KGX)/rhotot

                    end if

                  else if(GAMDOT(ISM,KGX) < -GAMDSM) then

                    DGAM=-GAMDOT(ISM,KGX)*TINCR
                    bl=xb_CE2(KMO)*xlambda_CE2(KGX)

                    drho_f_1=0.d0    ; drho_f_2=0.d0
                    drho_r_si_1=0.d0 ; drho_r_si_2=0.d0
                    drho_r_sj_1=0.d0 ; drho_r_sj_2=0.d0

                    if((rho_r_CE2(2*ism-1,kgx) == 0.d0 .and.
     1                rho_r_CE2(2*ism,kgx) >= 0.d0) .or.
     2                i_rm_flag==int(1)) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(2)*TINCR

                      ! Evolution for rho_for
!                      drho_f_1=(1.d0-xp_CE2(KMO))*DGAM/bl
!     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_1=(1.d0-xp_CE2(KMO))*DGAM/bl
     1                     -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
                      drho_r_si_1=0.d0

                      ! Ebolution for rho_r_sj
!                      drho_r_sj_1=xp_CE2(KMO)*DGAM/bl
!     1                      -xf_self_CE2(KMO)*rho_r_CE2(2*ISM,KGX)*DGAM
                      drho_r_sj_1=xp_CE2(KMO)*DGAM/bl
     1                    -xf_self_CE2(KMO)*rho_r_CE2(2*ISM,KGX)*DELTGAM

                      rho_prev_CE2(ism,kgx)=rhotot

                    end if
                    if(rho_r_CE2(2*ism-1,kgx) > 0.d0 .and.
     1                     rho_r_CE2(2*ism,kgx) == 0.d0) then

                      if(i_rm_flag==int(1)) DGAM=gamdot_rm(1)*TINCR

                      ! Evolution for rho_for
!                      drho_f_2=DGAM/bl
!     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DGAM
                      drho_f_2=DGAM/bl
     1                    -xf_self_CE2(KMO)*rho_f_CE2(ISM,KGX)*DELTGAM

                      ! Evolution for rho_r_si
                      ! In this case, rho_r_si remains zero
!                      drho_r_si_2=
!     1                -DGAM/bl*rho_r_CE2(2*ISM-1,KGX)/26709953611401.7d0
                      drho_r_si_2=
     1                   -DGAM/bl*rho_r_CE2(2*ISM-1,KGX)/rhotot
!                      drho_r_si_2=
!     1                   -DELTGAM/bl*rho_r_CE2(2*ISM-1,KGX)/rhotot

                      ! Evolution for rho_r_sj
                      drho_r_sj_2=0.d0

                    end if
     1
                  else

                    drho_f_1   =
     1                 -xf_lat_CE2(KMO)*rho_f_CE2(ism,kgx)    *DELTGAM
                    drho_r_si_1=
     1                 -xf_lat_CE2(kmo)*rho_r_CE2(2*ism-1,kgx)*DELTGAM
                    drho_r_sj_1=
     1                 -xf_lat_CE2(kmo)*rho_r_CE2(2*ism,kgx)  *DELTGAM

                    drho_f_2=0.d0 ; drho_r_si_2=0.d0 ; drho_r_sj_2=0.d0

                  end if

                  tmp2=rho_r_CE2(2*ism-1,kgx)+drho_r_si_1+drho_r_si_2
                  tmp3=rho_r_CE2(2*ism,kgx)  +drho_r_sj_1+drho_r_sj_2

                  if(dabs(tmp2) <= rhosm) then
                    drho_r_si_1=-rho_r_CE2(2*ism-1,kgx)
                    drho_r_si_2=0.d0
                    tmp2=rho_r_CE2(2*ism-1,kgx)+drho_r_si_1+drho_r_si_2
                  end if
                  if(dabs(tmp3) <= rhosm) then
                    drho_r_sj_1=-rho_r_CE2(2*ism,kgx)
                    drho_r_sj_2=0.d0
                    tmp3=rho_r_CE2(2*ism,kgx)  +drho_r_sj_1+drho_r_sj_2
                  end if

!                  if(ism==12) then
!                    write(501,'(10d20.10)') epsvm,rho_f_CE2(ism,kgx),
!     1d_rho_f_1,d_rho_f_2,rho_r_CE2(2*ism-1,kgx),drho_r_si_1,
!     2drho_r_si_2,rho_r_CE2(2*ism,kgx),drho_r_sj_1,drho_r_sj_2
!                  end if

                  if(min(tmp2,tmp3) >= 0.d0) exit

                  i_rm_flag=int(1)
                  gamdot_rm(1)=
     1            dabs((xb_CE2(KMO)*xlambda_CE2(KGX)*rhotot)/tincr)
!                  gamdot_rm(1)=
!     1              dabs((xb_CE2(KMO)*xlambda_CE2(KGX)*rhotot)/tincr)
                  gamdot_rm(2)=dabs(gamdot(ism,kgx))-dabs(gamdot_rm(1))

                end do

                rho_f_CE2(ism,kgx)
     1                  =rho_f_CE2(ism,kgx)    +drho_f_1+drho_f_2
                rho_r_CE2(2*ism-1,kgx)
     1                  =rho_r_CE2(2*ism-1,kgx)+drho_r_si_1+drho_r_si_2
                rho_r_CE2(2*ism,kgx)
     1                  =rho_r_CE2(2*ism,kgx)  +drho_r_sj_1+drho_r_sj_2

!                if(dabs(rho_f_CE2(ism,kgx)) <= rhosm) then
!                  rho_f_CE2(ism,kgx)=0.d0
!                end if
!                if(dabs(rho_r_CE2(2*ism-1,kgx)) <= rhosm) then
!                  rho_r_CE2(2*ism-1,kgx)=0.d0
!                end if
!                if(dabs(rho_r_CE2(2*ism,kgx)) <= rhosm) then
!                  rho_r_CE2(2*ism,kgx)=0.d0
!                end if

                cnst1=cnst1+rho_f_CE2(ism,kgx)     *wgt(kgx)   ! CNT Sept 2011
                cnst2=cnst2+rho_r_CE2(2*ism-1,kgx) *wgt(kgx)
                cnst3=cnst3+rho_r_CE2(2*ism  ,kgx) *wgt(kgx)

!                if(dabs(GAMDOT(ISM,KGX)) > 1.d-8) then
!                  i_activeSlip=i_activeSlip+1
!                end if

                cnstg1=cnstg1+rho_f_CE2(ism,kgx)
                cnstg2=cnstg2+rho_r_CE2(2*ism-1,kgx)
                cnstg3=cnstg3+rho_r_CE2(2*ism  ,kgx)

              end do      ! end of do isy=1,nsm
            end do        ! end of do kmo=1,nslmod

            if(KGX == 10) then
              write(501,'(4d20.10)') epsvm,cnstg1,cnstg2,cnstg3
!            else if(KGX==345) then
!              write(502,'(4d20.10)') epsvm,cnstg1,cnstg2,cnstg3
!            else if(KGX==800) then
!              write(503,'(4d20.10)') epsvm,cnstg1,cnstg2,cnstg3
            end if

C *** TOTAL DENSITY IN THE GRAIN, SUM OF FOREST AND REVERSE DENSITIES
CNT --> I MOVED THIS LOOP BEFORE THE NEXT LOOP BECAUSE IT IS ALWAYS THE SAME
C   CALCULATION !! I STORE IT IN rho_tot

            rho_tot=0.d0
!            rho_tot_f=0.d0
            DO JS=1,NSYST(IPHEL)
!              rho_tot_f=rho_tot_f+rho_f_CE2(js,kgx)
              rho_tot  =rho_tot  +rho_f_CE2(js,kgx)
     1               +rho_r_CE2(2*js-1,kgx)+rho_r_CE2(2*js,kgx)
            ENDDO

C *** CALCULATES EFFECTIVE DENSITY THAT GOES IN THE HARDENING LAW

CNT --> I THINK THAT THE REVERSIBLE DISLOCATIONS THAT
C   MAY HELP SHEAR IN THE OPPOSITE SENSE SHOULD NOT ADD BUT SUBSTRACT TO THE
C   EFFECTIVE DISLOCATION DENSITY CONTRIBUTING TO SHEAR.
C   THIS IS WHAT THE NEW ALGORITHM BELOW DOES: IT WILL LOWER THE CRSS IN A
C   SYSTEM IF THERE ARE AVAILABLE REVERSIBLE DISLOCATIONS IN THE OPPOSITE SYST

            DO IS=1,NSYST(IPHEL)

              RHO_EFF=rho_tot*xL_CE2(1)-(xL_CE2(1)-1.d0)
     1          *(rho_f_CE2(is,kgx)+rho_r_CE2(2*is-1,kgx)
     2            +rho_r_CE2(2*is,kgx))

             if(RHO_EFF < 0.d0) RHO_EFF=0.d0    ! CNT --> avoid negative sqrt

              taue(is,kgx)=tau0_CE2(1)
     1        +alpha_CE2(1)*xMu_CE2(1)*xb_CE2(1)*dsqrt(RHO_EFF)

            ENDDO

!            xlambda_CE2(kgx)=
!     1      1.d0/(dsqrt(rho_tot_f)/xK_CE2(1)+1.d0/xD_CE2(1))   ! CNT changed
            xlambda_CE2(kgx)=
     1      1.d0/(dsqrt(rho_tot)/xK_CE2(1)+1.d0/xD_CE2(1))   ! CNT changed

C *** UPDATES crss FOR THE SLIP SYSTEMS USING RECALCULATED DISLOC DENSITIES

            DO IS=1,NSYST(IPHEL)
              CRSS(IS,KGX)=TAUE(IS,KGX)
            ENDDO

            ngg=10
            iprx=iprint*(ngg/kkk)*(kkk/ngg)
            if(iprx.ne.0) then
              write(10,'('' CRSS for grain  '',i5,6x,3f6.0,/,(12f6.0))')
     #          kkk,(crss(is,kkk),is=1,nsyst(iphel))
c         gamdnorm=tnorm5(dbar,5,1)
c         write(10,'('' GAMD(is,kkk)'',i5,6x,3f7.2,/,(12f7.2))')
c     #          kkk,(gamdot(is,kkk)/gamdnorm,is=1,nsyst(iphel))
            endif

!            GTOTGR(KGX)=GAMTOTX+DELTGAM

            KGX=KGX+1

          ENDDO      ! END OF LOOP kkk OVER GRAINS
        END DO ! END OF LOOP IPH OVER PHASES

CNT --> this is not right when grains have different volume fractions
C        cnst1=cnst1/dble(NGR(IPHTOP))
C        cnst2=cnst2/dble(NGR(IPHTOP))
C        cnst3=cnst3/dble(NGR(IPHTOP))

!        if(IPHTOP /= 1) write(500,'(a)') 'This result is wrong. Check ou
!     1tput part'

        write(500,'(4d20.10)') epsvm,cnst1,cnst2,cnst3
!        write(501,'(d20.10,I10)') epsvm,i_activeSlip
        write(502,'(25d20.10)') epsvm,GAMDOT(1:24,1)
        write(503,'(25d20.10)') epsvm,rho_f_CE2(1:24,1)
        write(504,'(25d20.10)') epsvm,rho_r_CE2(1:48:2,1)
        write(505,'(25d20.10)') epsvm,rho_r_CE2(2:49:2,1)
        write(506,'(25d20.10)') epsvm,CRSS(1:24,1)

!        write(500,'(4d20.10)') GTOTGR(50),rho_f_CE(50),
!     1                          rho_r_CE(50),rho_l_CE(50)


      ENDIF      ! END OF IF(IOPTION.EQ.2)

c ______________________________________________________________________

      RETURN
      END



C *****************************************************************************
C     SUBROUTINE UPDATE_CRSS_IRRAD    --->      VERSION OF 02/SET/2005
C
C     IN ADDITION TO THE EXTENDED VOCE HARDENING (AS DONE INSIDE SUBROUTINE
C     UPDATE_CRSS_VOCE), WE SUPERIMPOSE HARDENING DUE TO THE PRESENCE OF
C     IRRADIATION-CREATED DEFECTS.
C     HERE WE REFORMULATE THE HARDENING MODEL PROPOSED BY ARSENLIS et al.
C     (PHIL. MAG. 2004) TO EXPRESS HARDENING OF THE INDIVIDUAL SLIP SYSTEMS
C     INSIDE EACH GRAIN.
*******************************************************************************

      SUBROUTINE UPDATE_CRSS_IRRAD (IOPTION)

      INCLUDE 'vpsc7.dim'

      DIMENSION DR(NGRMX)
      SAVE BUR,SHMOD,QPOW,DRref,DRini,DDini
      COMMON/VOCE/TAU(NSYSMX,0:1,NPHPEL),THET(NSYSMX,0:1,NPHPEL),
     #            HPFAC(NSYSMX,NPHPEL),GRSZE(NPHPEL)

      iprint=0   ! controls diagnostic print-out

C *** TEMPORARILY HARDWIRED PARAMETERS OF THE HARDENING MODEL
      BUR=0.25        !Burgers vector for Cu [nm]
      SHMOD=48.5e+03  ! elastic shear modulus for Cu [MPa]
C     QPOW=3.         ! power associated with defect-strength law
C     DRref=3.0       ! reference defect radious [nm]
C     DRini=2.5       ! initial defect radious [nm]
C     DDini=4.0e-07   ! initial defect density [1/nm^3]

      IF (IOPTION.EQ.1) THEN

        READ(UR0,*) PROSA
        READ(UR0,*) QPOW     ! power associated with defect-strength law
        READ(UR0,*) DRref    ! reference defect radious [nm]
        READ(UR0,*) DRini    ! initial defect radious [nm]
        READ(UR0,*) DDini    ! initial defect density [1/nm^3]

        write(*,*) 'enter cutting efficiency param 1<cuteff<10 --> '
        write(*,*)
        read(*,*) cuteff
        write(*,*) 'enter minimum radious param 0<drmin<1 --> '
        read(*,*) drmin
        drmin=DRini*drmin

        ALPHA=SQRT(1.-EXP(-(DRini/DRref)**QPOW))

        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
          DO KKK=NGR(IPH-1)+1,NGR(IPH)
            DO IS=1,NSYST(IPHEL)
              TAUE(IS,KKK)=ALPHA*SHMOD*BUR*SQRT(DDini*DRini)
              CRSS(IS,KKK)=TAU(IS,0,IPHEL)+TAUE(IS,KKK)
            ENDDO
            DR(KKK)=DRini     ! initialize radious of defects

            iprx=iprint*(1/kkk)*(kkk/1)
            if(iprx.ne.0) then
              write(10,'('' initial CRSS for grain # '', i4)') kkk
              write(10,'(9f7.1)') (crss(is,kkk),is=1,nsyst(iphel))
            endif
          ENDDO
        ENDDO

      ELSE IF (IOPTION.EQ.2) THEN

        DRAVE=0.
        KGX=1
        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)

          GAMTOTX=GTOTGR(KKK)
          DELTGAM=0.0
          DO IS=1,NSYST(IPHEL)
            DELTGAM=DELTGAM+ABS(GAMDOT(IS,KGX))*TINCR
          ENDDO

          DRrel=(DR(KKK)/DRref)**QPOW
          BETA =1.-EXP(-DRrel)
          ALPHA=SQRT(BETA)

CCC       DTAUirr=(0.5-QPOW*DRrel*EXP(-DRrel)/4./BETA)*DELTGAM
CCC       DTAUirr=-( (0.5-QPOW*DRrel*EXP(-DRrel)/4./BETA) +QPOW/4.)
CCC  #            *DELTGAM *20.

          DO IS=1,NSYST(IPHEL)
            DTAU=0.
            DO JS=1,NSYST(IPHEL)
              DTAU=DTAU+HARD(IS,JS,IPHEL)*ABS(GAMDOT(JS,KGX))*TINCR
            ENDDO
CCC         TAU0 =TAU (IS,0,IPHEL)  +TAUE(IS,KKK)
            TAU0 =TAU (IS,0,IPHEL)
            TAU1 =TAU (IS,1,IPHEL)
            THET0=THET(IS,0,IPHEL)
            THET1=THET(IS,1,IPHEL)
            TINY=1.E-4*TAU0

            VOCE=0.0
            IF(ABS(THET0).GT.TINY) THEN
              VOCE=THET1*DELTGAM
              IF(ABS(TAU1).GT.TINY) THEN
                FACT=ABS(THET0/TAU1)
                EXPINI=EXP(-GAMTOTX*FACT)
                EXPDEL=EXP(-DELTGAM*FACT)
                VOCE  =VOCE-(FACT*TAU1-THET1)/FACT*EXPINI*
     #            (EXPDEL-1.)-THET1/FACT*EXPINI*
     #            (EXPDEL*((GAMTOTX+DELTGAM)*FACT+1.)-(GAMTOTX*FACT+1.))
              ENDIF
            ENDIF

C           CRSS(IS,KKK)=CRSS(IS,KKK)+DTAU*VOCE/DELTGAM
C    #                               +DTAUirr*TAUE(IS,KKK)
C           TAUE(IS,KKK)=TAUE(IS,KKK)+DTAUirr*TAUE(IS,KKK)

            CRSSirr=TAUE(IS,KKK)
            TAUE(IS,KKK)=ALPHA*SHMOD*BUR*SQRT(DDini*DR(KKK))
            CRSS(IS,KKK)=CRSS(is,kkk)+DTAU*VOCE/DELTGAM+
     #                   TAUE(IS,KKK)-CRSSirr
          ENDDO       ! END OF DO IS

          iprx=iprint*(1/kkk)*(kkk/1)
          if(iprx.ne.0) then
            write(10,'('' CRSS(is,kkk)'',i5,6x,3f6.0,/,(12f6.0))')
     #            kkk,(crss(is,kkk),is=1,nsyst(iphel))
            write(10,'('' GAMD(is,kkk)'',i5,6x,3f7.4,/,(12f7.4))')
     #            kkk,(gamdot(is,kkk),is=1,nsyst(iphel))
          endif

CCC       DR(KKK)=DR(KKK)*(1.-0.5*DELTGAM)
          DR(KKK)=DRini-GTOTGR(KKK)*DDini**(-1./3.) /cuteff
          IF(DR(KKK).LT.DRmin) DR(KKK)=DRmin

          DRAVE=DRAVE+DR(KKK)
          GTOTGR(KKK)=GAMTOTX+DELTGAM
          KGX=KGX+1
        ENDDO
        ENDDO
        DRAVE=DRAVE/NGR(1)
        write(10,'(''  --> AVERAGE DEFECT RADIOUS'',f10.2)') DRAVE

      ENDIF

      RETURN
      END
CFEE
C
C *****************************************************************************
C     SUBROUTINE UPDATE_CRSS_MTS      --->      VERSION OF 16/NOV/2010
C
C     IMPLEMENTS A SIMPLE 'MECHANICAL THRESHOLD STRESS' EXPRESSION AT THE
C     SLIP SYSTEM LEVEL.
C     THE PRESENT VERSION USES THE OVERALL STRAIN RATE AS THE INTERNAL
C     PARAMETER. TEMPERATURE AND RATE EFFECTS ARE ACCOUNTED FOR BY THE
C     SAME TERM FOR ALL THE SYSTEMS.
C     THE RATE DEPENDENCE IS ACCOUNTED FOR BY 'CRSS'. THE 'GAMMA0' IN THE
C     POWER LAW IS RENORMALIZED TO MAKE IT 'RATE INSENSITIVE'
C
C     IOPTION=0: READS PARAMETERS OF THE MTS MODEL AND DEFINES SOME
C                HARDENING PARAMETERS
C     IOPTION=1: DEFINES INITIAL RATE INDEPENDENT CRSS 'TAUe' FOR EVERY GRAIN
C     IOPTION=2: RECALCULATES TERMS WHICH DEPEND ON RATE AND TEMPERATURE
C               (BUT WHICH ARE INDEPENDENT OF STRUCTURE EVOLUTION) AND
C                UDPDATES CRSS IN EVERY SYSTEM USING STORED VALUE OF THE
C                STRUCTURE DEPENDENT TERM 'TAUe'
C     IOPTION=3: RECALCULATES TERMS WHICH DEPEND ON RATE AND TEMPERATURE
C               (BUT WHICH ARE INDEPENDENT OF STRUCTURE EVOLUTION).
C                UPDATES STRUCTURE TERM THAT DEPENDS ON DISLOCATION HARDENING.
C                UDPATES THRESHOLD STRESS IN EVERY SYSTEM OF EVERY GRAIN.
*******************************************************************************

      SUBROUTINE UPDATE_CRSS_MTS (EDOT,TEMP,IOPTION)

      INCLUDE 'vpsc7.dim'

      REAL*8 KOVB3,MU0,D0,T0,TAUa,TAUi,TAUeini,TH0,KAP,MU
      REAL*8 G0i,ED0i,QQi,PPi,G0e,ED0e,QQe,PPe,G0esat,EDesat0,TAUesat0
      REAL*8 PSI,RHO,Cp1,Cp2,Cp3,Cp

      SAVE   KOVB3,MU0,D0,T0,TAUa,TAUi,TAUeini,TH0,KAP,MU
      SAVE   G0i,ED0i,QQi,PPi,G0e,ED0e,QQe,PPe,G0esat,EDesat0,TAUesat0
      SAVE   PSI,RHO,Cp1,Cp2,Cp3,Cp

      IUNIT=UR1      ! READS MTS PARAMETERS AT THE END OF SX FILE.

      IF (IOPTION.EQ.0) THEN

        READ(IUNIT,'(A)') PROSA
        READ(IUNIT,*) KOVB3,MU0,D0,T0
        READ(IUNIT,*) TAUa,TAUi,TAUeini,TH0,KAP
        READ(IUNIT,*) G0i,ED0i,QQi,PPi
        READ(IUNIT,*) G0e,ED0e,QQe,PPe
        READ(IUNIT,*) G0esat,EDesat0,TAUesat0
        READ(IUNIT,*) PSI,RHO
        READ(IUNIT,*) Cp1,Cp2,Cp3

        IPH=IPHBOT     ! for initialization IPHBOT=IPHTOP
        NRSX=20        ! power to use in 'rate sensitive' law
        DO IS=1,NSYST(IPH)
          NRS(IS,IPH)=NRSX
          DO JS=1,NSYST(IPH)
            HARD(IS,JS,IPH)=1.0
          ENDDO
        ENDDO

        RETURN
      ENDIF

      IF(IOPTION.EQ.1) THEN
        IPH=IPHBOT     ! for initialization IPHBOT=IPHTOP
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          DO IS=1,NSYST(IPH)
            TAUe(IS,KKK)=TAUeini
          ENDDO
        ENDDO

        RETURN
      ENDIF

C*** NEXT PARAMETERS REQUIRED FOR OPTION 2 AND 3

      MU=MU0*(1.-D0/(EXP(T0/TEMP)-1.))
      Cp=Cp1+Cp2*TEMP+Cp3*TEMP**(-2)

      Si=KOVB3*TEMP*LOG(ED0i/EDOT)/G0i/MU
      Si=(1.-Si**(1./QQi))**(1./PPi)
      Se=KOVB3*TEMP*LOG(ED0e/EDOT)/G0e/MU
      Se=(1.-Se**(1./QQe))**(1./PPe)

      TAUesat=TAUesat0*(EDOT/EDesat0)**(KOVB3*TEMP/G0esat/MU)
      TAUini =TAUa+MU/MU0*Si*TAUi+MU/MU0*Se*TAUeini
      HFACTOR=(KAP-1.)*TH0/(TAUesat**KAP)*(MU/MU0)

      IF (IOPTION.EQ.2) THEN
        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
          DO KKK=NGR(IPH-1)+1,NGR(IPH)
            DO IS=1,NSYST(IPHEL)
              CRSS(IS,KKK)=TAUini+MU/MU0*Se*TAUe(IS,KKK)
            ENDDO
          ENDDO
        ENDDO

C       WRITE(10,*)
C       WRITE(10,'(''        TEMP        EDOT'')')
C       WRITE(10,'(6E12.5)') TEMP,EDOT
C       WRITE(10,'(''          MU          Cp         Si         Se'')')
C       WRITE(10,'(6E12.5)') MU,Cp,Si,Se
C       WRITE(10,'(''     TAUesat      TAUini    HFACTOR    TFACTOR'')')
C       WRITE(10,'(6E12.5)') TAUesat,TAUini,HFACTOR,TFACTOR
C       WRITE(10,'(''     CRSS IN GRAIN '',i5)') NGR(IPHTOP)
C       WRITE(10,'(12F7.1)') (CRSS(IS,NGR(IPHTOP)),IS=1,NSYST(IPHEL))

      ENDIF       ! END OF IOPTION=2

      IF (IOPTION.EQ.3) THEN
        WORKINCR=0.
        KGX=1
        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
          DO KKK=NGR(IPH-1)+1,NGR(IPH)
            DO IS=1,NSYST(IPHEL)
              WORKINCR=WORKINCR+
     #                 CRSS(IS,KKK)*ABS(GAMDOT(IS,KGX))*TINCR*WGT(KKK)
              DTAU=0.
              DO JS=1,NSYST(IPHEL)
                DTAU=DTAU+HARD(IS,JS,IPHEL)*ABS(GAMDOT(JS,KGX))*TINCR
              ENDDO
              IF(TAUesat.LT.TAUe(IS,KKK)) THEN
                TAUesat=TAUe(IS,KKK)
                WRITE(*,'(''    SYST AND GRAIN'',2I10)') IS,KKK
                write(*,'("1")') 
                read(*,*)
              ENDIF
              TAUe(IS,KKK)=TAUesat-((TAUesat-TAUe(IS,KKK))**(1.-KAP)+
     #                               HFACTOR*DTAU)**(1./(1.-KAP))
              CRSS(IS,KKK)=TAUini+MU/MU0*Se*TAUe(IS,KKK)
            ENDDO
            KGX=KGX+1
          ENDDO
        ENDDO

        TFACTOR=PSI/RHO/Cp
        IF(EDOT.LT.500) TFACTOR=0
        TEMP=TEMP+TFACTOR*WORKINCR

      ENDIF      ! END OF IOPTION=3

      RETURN
      END
C
C *****************************************************************************
C     SUBROUTINE UPDATE_CRSS_VOCE     --->    VERSION OF 21/NOV/2010
C
C     A VOCE LAW, FUNCTION OF THE ACCUMULATED SHEAR IN EACH GRAIN
C     MODULATES THE LATENT (LINEAR) HARDENING.
C     THE UNITS (AND THE STRENGTH) OF THE HARDENING ARE CARRIED BY THE
C     MULTIPLICATIVE FACTOR 'VOCE'.
C     THE SELF & LATENT COUPLING COEFFICIENTS 'HARD' ARE DIMENSIONLESS
C     CONSTANTS RELATIVE TO THE FACTOR 'VOCE'.
C     THE INCREMENT OF CRSS IS GIVEN BY AN ANALYTIC INTEGRAL EXPRESSION OF
C     THE VOCE FUNCTION, RATHER THAN USING FORWARD EXTRAPOLATION, AS WAS
C     DONE BEFORE 28/SET/00.
C     THE PARAMETERS IN VOCE EXPRESSION MAY ADOPT 'NON-KOSHER' VALUES (DEC/00)
C
C     IOPTION=0: READS HARDENING PARAMETERS OF SLIP AND TWIN MODES AND
C                ASSIGNS THOSE TO THE SLIP AND TWIN SYSTEMS
C     IOPTION=1: INITIALIZES THE CRSS OF EACH SYSTEM
C     IOPTION=2: UPDATES THE CRSS OF EACH SYSTEM AS A FUNCTION OF THE SHEAR
C                INCREMENTS TAKING PLACE IN ALL SYSTEMS
*******************************************************************************

      SUBROUTINE UPDATE_CRSS_VOCE (IOPTION)

      INCLUDE 'vpsc7.dim'

      DIMENSION HSELFX(NMODMX),HLATEX(NMODMX,NMODMX)
      COMMON/VOCE/TAU(NSYSMX,0:1,NPHPEL),THET(NSYSMX,0:1,NPHPEL),
     #            HPFAC(NSYSMX,NPHPEL),GRSZE(NPHPEL)

      IPRINT=0    ! controls printing

C ***************************************************************************

      IF (IOPTION.EQ.0) THEN
        IPH=IPHBOT   ! initialization: one call for each phase
        READ(UR1,*) GRSZE(IPH)

        ISYS=1
        NTWMODX=0
        DO IM=1,NMODES(IPH)

          READ(UR1,*)        ! reminder/identifier of system
          READ(UR1,*) NRSX   ! rate sensitivity parameter

C *** READ EXTENDED VOCE PARAMETERS AND LATENT HARDENING PARAMETERS.
C *** SELF-HARDENING IS ARBITRARILY SET AS REFERENCE
          READ(UR1,*) TAU0X,TAU1X,THET0X,THET1X, HPFACX
          HSELFX(IM)=1.
          READ(UR1,*) (HLATEX(IM,JM),JM=1,NMODES(IPH))

C *** CHECKS WHETHER VOCE PARAMETERS ARE KOSHER:
C         TAU0>0 , TAU1 >= 0 , THET0 >= THET1 >= 0
C         TAU1=0   CORRESPONDS TO LINEAR HARDENING.
C         THETA0=0 FORCES NO-HARDENING.
C *** IF VOCE PARAMETERS ARE NON-KOSHER CHECKS FOR ILL-POSED HARDENING.

          CALL CHECK_VOCE (IM,IPH,TAU0X,TAU1X,THET0X,THET1X)

C *** READS PTR PARAMETERS FOR TWINNING SYSTEMS
          IF(ISYS.LE.NSLSYS(IPH)) ISECTWX=0
          IF(ISYS.GT.NSLSYS(IPH)) THEN
            READ(UR1,*) ISECTWX,THRES1X,THRES2X
            NTWMODX=NTWMODX+1
            TWTHRES(1,NTWMODX,IPH)=THRES1X
            TWTHRES(2,NTWMODX,IPH)=THRES2X
          ENDIF

          DO IS=1,NSM(IM,IPH)
            NRS(ISYS,IPH)   =NRSX
            TAU(ISYS,0,iph) =TAU0X
            TAU(ISYS,1,iph) =TAU1X
            THET(ISYS,0,iph)=THET0X
            THET(ISYS,1,iph)=THET1X

            ISECTW(ISYS,iph)=ISECTWX
            HPFAC(ISYS,iph) =HPFACX

            JSYS=1
            DO JM=1,NMODES(IPH)
            DO JS=1,NSM(JM,IPH)
              HARD(ISYS,JSYS,IPH)=HLATEX(IM,JM)
              JSYS=JSYS+1
            ENDDO
            ENDDO
            HARD(ISYS,ISYS,IPH)=HSELFX(IM)
            ISYS=ISYS+1

          ENDDO      ! end of DO IS
        ENDDO        ! end of DO IM

C     WRITE(10,*)
C     WRITE(10,'(''  HARDENING MATRIX FOR PHASE'',I3)') IPH
C     DO IS=1,NSYST(IPH)
C       WRITE(10,'(24F5.1)') (HARD(IS,JS,IPH),JS=1,NSYST(IPH))
C     ENDDO

      ENDIF   ! END OF IOPTION=0
C ***************************************************************************

      IF (IOPTION.EQ.1) THEN

        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
          DO KKK=NGR(IPH-1)+1,NGR(IPH)
            DO IS=1,NSYST(IPHEL)
              CRSS(IS,KKK)=TAU(IS,0,IPHEL)
     #                    +HPFAC(IS,IPHEL)/SQRT(GRSZE(IPH))
            ENDDO

            iprx=iprint*(1/kkk)*(kkk/1)
            if(iprx.ne.0) then
              write(10,'('' initial CRSS for grain # '', i4)') kkk
              write(10,'(9f7.1)') (crss(is,kkk),is=1,nsyst(iphel))
            endif

          ENDDO
        ENDDO

      ENDIF   ! END OF IOPTION=1
C ***************************************************************************

      IF (IOPTION.EQ.2) THEN

        KGX=1
        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)

          GAMTOTX=GTOTGR(KKK)
          DELTGAM=0.0
          DO IS=1,NSYST(IPHEL)
            DELTGAM=DELTGAM+ABS(GAMDOT(IS,KGX))*TINCR
          ENDDO

          DO IS=1,NSYST(IPHEL)
            DTAU=0.
            DO JS=1,NSYST(IPHEL)
              DTAU=DTAU+HARD(IS,JS,IPHEL)*ABS(GAMDOT(JS,KGX))*TINCR
            ENDDO
            TAU0 =TAU (IS,0,IPHEL)
            TAU1 =TAU (IS,1,IPHEL)
            THET0=THET(IS,0,IPHEL)
            THET1=THET(IS,1,IPHEL)
            TINY=1.E-4*TAU0

            VOCE=0.0
            IF(ABS(THET0).GT.TINY) THEN
              VOCE=THET1*DELTGAM
              IF(ABS(TAU1).GT.TINY) THEN
                FACT=ABS(THET0/TAU1)
                EXPINI=EXP(-GAMTOTX*FACT)
                EXPDEL=EXP(-DELTGAM*FACT)
                VOCE  =VOCE-(FACT*TAU1-THET1)/FACT*EXPINI*
     #            (EXPDEL-1.)-THET1/FACT*EXPINI*
     #            (EXPDEL*((GAMTOTX+DELTGAM)*FACT+1.)-(GAMTOTX*FACT+1.))
              ENDIF
            ENDIF
            CRSS(IS,KKK)=CRSS(IS,KKK)+DTAU*VOCE/DELTGAM
          ENDDO
CFEB
          iprx=iprint*(1/kkk)*(kkk/1)
            if(iprx.ne.0) then
            write(10,'('' CRSS(is,kkk)'',i5,6x,3f6.0,/,(12f6.0))')
     #            kkk,(crss(is,kkk),is=1,nsyst(iphel))
            write(10,'('' GAMD(is,kkk)'',i5,6x,3f7.4,/,(12f7.4))')
     #            kkk,(gamdot(is,kkk),is=1,nsyst(iphel))
            endif
CFEE
          GTOTGR(KKK)=GAMTOTX+DELTGAM
          KGX=KGX+1
        ENDDO
        ENDDO

      ENDIF   ! END OF IOPTION=2
C ***************************************************************************

      RETURN
      END
C
C *****************************************************************************
C     SUBROUTINE UPDATE_FIJ      --->      VERSION 11/JAN/2009
C
C     USES THE VELOCITY GRADIENT (AVERAGE, PHASE or GRAIN) IN THE STEP
C     TO UPDATE INCREMENTALLY THE CORRESPONDING DEFORMATION TENSOR 'FIJ'
C
C     REPLACES PREVIOUS SUBR. UPDFIJ_AVERAGE & SUBR. UPDFIJ_LOCAL  (SEP/04)
C *****************************************************************************

      SUBROUTINE UPDATE_FIJ (IPH)

      INCLUDE 'vpsc7.dim'

      DIMENSION FNEW(3,3)


C *** UPDATES THE DEFORM GRAD IN THE ELEMENT 'FIJPH(i,j,0)' USING THE
C     MACROSCOPIC VELOCITY GRADIENT 'UDOT'
C *** UPDATES THE DEFORM GRAD IN EACH PHASE 'FIJPH(i,j,IPH)' USING THE
C     AVERAGE VELOCITY GRADIENT FOR THE PHASE 'LIJPH' CALCULATED INSIDE
C     SUBROUTINE UPDATE_ORIENTATION.
C *** LIJPH ACCOUNTS FOR ROTATIONS BUT NOT FOR STRETCH WHEN IFLAT(iph)=1.
C *** FIJPH COINCIDES WITH FIJ OF ELEMENT IF NPH=1 AND IFLAT(1)=0.

      DO I=1,3
      DO J=1,3
        FNEW(I,J)=0.0
        IF(IPH.EQ.0) THEN
          DO K=1,3
            FNEW(I,J)=FNEW(I,J)+(TINCR*UDOT(I,K)+XID3(I,K))*FIJPH(K,J,0)
          ENDDO
        ELSE IF(IPH.GT.0) THEN
          DO K=1,3
            FNEW(I,J)=FNEW(I,J)+(TINCR*XLIJPH(I,K,IPH)+XID3(I,K))
     #                         *FIJPH(K,J,IPH)
          ENDDO
        ENDIF
      ENDDO
      ENDDO
      DO I=1,3
      DO J=1,3
        FIJPH(I,J,IPH)=FNEW(I,J)
      ENDDO
      ENDDO
CFEB

C *** UPDATES THE DEFORM GRAD IN EACH GRAIN 'FIJGR(i,j,KKK)' USING THE
C     VELOCITY GRADIENT FOR THE GRAIN 'LIJGR' CALCULATED INSIDE SUBROUTINE
C     UPDATE_ORIENTATION.

      IF (ISHAPE(IPH).GT.0) THEN
        DO KKK=NGR(IPH-1)+1,NGR(IPH)

          DO I=1,3
          DO J=1,3
            FNEW(I,J)=0.0
            DO K=1,3
              FNEW(I,J)=FNEW(I,J)+(TINCR*XLIJGR(I,K,KKK)+XID3(I,K))
     #                           *FIJGR(K,J,KKK)
            ENDDO
          ENDDO
          ENDDO
          DO I=1,3
          DO J=1,3
            FIJGR(I,J,KKK)=FNEW(I,J)
          ENDDO
          ENDDO

        ENDDO      ! END OF DO KKK
      ENDIF
CFEE
      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE UPDATE_SHAPE      --->      VERSION 11/JAN/2009
C
C     CALCULATES THE DIRECTION AND LENGTH (EIGENVECTORS AND EIGENVALUES OF
C     DEFORMATION TENSOR FIJ) OF THE AXES OF THE ELLIPSOID ASSOCIATED WITH
C     AVERAGE, PHASE AND/OR GRAIN ACCUMULATED DEFORMATION.
C     CALCULATES THE EULER ANGLES OF ELLIPSOID AXES WRT SAMPLE AXES.
C
C     REPLACES PREVIOUS SUBR. GRAXES_AVERAGE & SUBR. GRAXES_LOCAL  (SEP/04)
C
C     GRAIN-FRAGMENTATION SCHEME ADDED ON 12/NOV/07 (CNT)
C
C     SHAPE 'FREEZE' SCHEME MODIFIED ON 21/JUN/08 (CNT).
C     NOW IT APPLIES TO THE DEFINITION OF FIJ (INSTEAD OF LIJ). WORST GRAIN
C     OFFENDER CRITERION SUPPRESSED & REPLACED BY ASPECT RATIO OF THE PHASE.
C **************************************************************************

      SUBROUTINE UPDATE_SHAPE (IPH)

      INCLUDE 'vpsc7.dim'

      DIMENSION W(3),BX(3,3),B(3,3),BT(3,3),FIJX(3,3)


C *** IF IPH=0 ELLIPSOID REPRESENTS AVERAGE DEFORMATION IN ELEMENT
C *** IF IPH>0 ELLIPSOID REPRESENTS AVERAGE DEFORMATION IN PHASE 'IPH'
C *** CALCULATES EIGENVALUES, EIGENVECTORS & EULER ANGLES OF ELEMENT GRAIN,
C     PHASE GRAIN, OR INDIVIDUAL GRAIN
C *** 'AXISPH' TRANSFORMS FROM ELLIPSOID TO SAMPLE AXES.

C *** uses UDOT to prevent numerical instability in SO procedure
      IPHX=IPH
      IF(INTERACTION.EQ.5) IPHX=0

      DO I=1,3
      DO J=1,3
        BX(I,J)=0.
        DO K=1,3
          BX(I,J)=BX(I,J)+FIJPH(I,K,IPHX)*FIJPH(J,K,IPHX)
        ENDDO
      ENDDO
      ENDDO

      CALL JACOBI(BX,3,3,W,B,NROT,IER)
      CALL EIGSRT(W,B,3,3)
      IF (IER.EQ.1) THEN
        WRITE(*,*) 'ERROR IN UPDATE_SHAPE FOR PHASE ELLIPSOID',IPH
        STOP
      ENDIF

C *** EIGENVALUES (AND ASSOC EIGENVECTORS) ARE ORDERED FROM LARGER TO SMALLER.
C *** REDEFINE AXIS(2) TO BE THE LARGEST IN ORDER TO IMPROVE ACCURACY IN THE
C     CALCULATION OF THE ESHELBY TENSOR.
C *** IF DET(B)<0 MEANS THAT THE SYSTEM IS LEFT HANDED. IT IS MADE RIGHT
C     HANDED BY EXCHANGING 1 AND 2.

      SIGN=-1.
      IF(DET(B).LE.0.) SIGN=1.
      DO I=1,3
        EXCHANGE=B(I,1)
        B(I,1)=B(I,2)
        B(I,2)=EXCHANGE*SIGN
      ENDDO
      EXCHANGE=W(1)
      W(1)=W(2)
      W(2)=EXCHANGE

      RATMAX=SQRT(W(2)/W(3))
      RATMIN=SQRT(W(1)/W(3))

      DO I=1,3
        IF(IFLAT(IPH).EQ.0) AXISPH(0,I,IPH)=SQRT(W(I))
        IF(IFLAT(IPH).EQ.1) AXISPH(0,I,IPH)=AXISPH(0,I,IPH)   ! keep previous
        DO J=1,3
          AXISPH(I,J,IPH)=B(I,J)
          BT(I,J)        =B(J,I)
        ENDDO
      ENDDO

c *** recalculates deform grad in sample keeping ellipsoid axes invariant
      IF(IFLAT(IPH).EQ.1) then
        DO I=1,3
          DO J=1,3
            FIJX(I,J)=XID3(I,J)*AXISPH(0,I,IPH)
          ENDDO
        ENDDO
        DO I=1,3
        DO J=1,3
          FIJPH(I,J,IPH)=0.
          DO K=1,3
          DO L=1,3
            FIJPH(I,J,IPH)=FIJPH(I,J,IPH)+B(I,K)*B(J,L)*FIJX(K,L)
          ENDDO
          ENDDO
        ENDDO
        ENDDO
      ENDIF

      CALL EULER(1,ANG1,ANG2,ANG3,BT)
      EULERPH(1,IPH)=ANG1
      EULERPH(2,IPH)=ANG2
      EULERPH(3,IPH)=ANG3

      IF (IPH.NE.0) THEN

      IF (IFRAG(IPH).EQ.0) THEN
C *************************************************************************
C *** STOPS UPDATING THE ELLIPSOID SHAPE FOR A LIMIT ASPECT RATIO

        IF(RATMAX.GT.CRIT_SHP(IPH) .AND. IFLAT(IPH).EQ.0) THEN
CFEB
          write(10,*) '*********************************************'
          write(10,*) '  STOPS UPDATING GRAIN SHAPE FOR PHASE ',iph
          write(10,*) '*********************************************'
          write(*, *) '*********************************************'
          write(*, *) '  STOPS UPDATING GRAIN SHAPE FOR PHASE ',iph
          write(*, *) '*********************************************'
CFEE
          IFLAT(IPH)=1
        ENDIF
C *************************************************************************

      ELSE IF (IFRAG(IPH).EQ.1) THEN

C *************************************************************************
C *** SPLITS AVERAGE GRAIN WHEN IT EXCEEDS A CRITICAL ASPECT RATIO.
C *** REDEFINES LENGTH OF ELLIPSOID AXES 'AXISPH(0,I,IPH)' BUT NOT THE
C     ELLIPSOID ORIENTATION 'AXIS(J,I,IPH)'
C *** RECALCULATES DEFORMATION GRADIENT OF THE PHASE 'FIJPH' IN SAMPLE AXES

        IF(RATMAX.GE.CRIT_SHP(IPH)) THEN
          W(2)=W(2)/4.
          IF(RATMIN.GE.CRIT_SHP(IPH)/2.) W(1)=W(1)/4.

ccc       w(1)=1.    ! resetting to equiaxed
ccc       w(2)=1.
ccc       w(3)=1.

          DO I=1,3
            AXISPH(0,I,IPH)=SQRT(W(I))
            DO J=1,3
              FIJX(I,J)=XID3(I,J)*AXISPH(0,I,IPH)
            ENDDO
          ENDDO
          DO I=1,3
          DO J=1,3
            FIJPH(I,J,IPH)=0.
            DO K=1,3
            DO L=1,3
              FIJPH(I,J,IPH)=FIJPH(I,J,IPH)+B(I,K)*B(J,L)*FIJX(K,L)
            ENDDO
            ENDDO
          ENDDO
          ENDDO
        ENDIF      ! END OF IF RATMAX>CRIT_RAT
C ********************************************************************
      ENDIF      ! END OF IF IFRAG

      ENDIF      ! END OF IF IPH.NE.0
CFEB
      write(10,'(''IPH='',I3,''  FIJPH  '',9F9.4)')
     #           IPH,((FIJPH(I,J,IPH),J=1,3),I=1,3)
      write(10,'(9X,''EIGNVAL'',3F9.4)')  (AXISPH(0,J,IPH),J=1,3)
      write(10,'(9X,''EIGNVEC'',9F9.4)') ((AXISPH(I,J,IPH),J=1,3),I=1,3)

C ********************************************************************
C *** UPDATES ELLIPSOIDS (EIGENVALUES & EIGENVECTORS) OF INDIVIDUAL GRAINS
C     'AXISGR(I,J)' TRANSFORMS FROM ELLIPSOID TO SAMPLE AXES.

      IF(ISHAPE(IPH).GT.0) THEN
C ********************************************************************

      DO KKK=NGR(IPH-1)+1,NGR(IPH)

        DO I=1,3
        DO J=1,3
          BX(I,J)=0.
          DO K=1,3
            BX(I,J)=BX(I,J)+FIJGR(I,K,KKK)*FIJGR(J,K,KKK)
          ENDDO
        ENDDO
        ENDDO

        CALL JACOBI(BX,3,3,W,B,NROT,IER)
        CALL EIGSRT(W,B,3,3)
        IF (IER.EQ.1) THEN
          WRITE(*,'(''ERROR IN UPDATE_SHAPE FOR GRAIN'',I5,
     #            ''  IN PHASE'',I3)') KKK,IPH
          STOP
        ENDIF

C *** EIGENVALUES (AND ASSOC EIGENVECTORS) ARE ORDERED FROM LARGER TO SMALLER.
C *** REDEFINE AXIS(2) TO BE THE LARGEST IN ORDER TO IMPROVE ACCURACY IN THE
C     CALCULATION OF THE ESHELBY TENSOR.
C *** IF DET(B)<0 MEANS THAT THE SYSTEM IS LEFT HANDED. IT IS MADE RIGHT
C     HANDED BY EXCHANGING 1 AND 2.

        SIGN=-1.
        IF(DET(B).LE.0.) SIGN=1.
        DO I=1,3
          EXCHANGE=B(I,1)
          B(I,1)=B(I,2)
          B(I,2)=EXCHANGE*SIGN
        ENDDO
        EXCHANGE=W(1)
        W(1)=W(2)
        W(2)=EXCHANGE

        RATMAX=SQRT(W(2)/W(3))
        RATMIN=SQRT(W(1)/W(3))

        DO I=1,3
          IF(IFLAT(IPH).EQ.0) AXISGR(0,I,KKK)=SQRT(W(I))
          IF(IFLAT(IPH).EQ.1) AXISGR(0,I,KKK)=AXISGR(0,I,KKK)
          DO J=1,3
            AXISGR(I,J,KKK)=B(I,J)
          ENDDO
        ENDDO

C *** updates def gradient keeping ellipsoid axes invariant   !cnt june/11/08
        IF(IFLAT(IPH).EQ.1) THEN
            DO I=1,3
              DO J=1,3
                FIJX(I,J)=XID3(I,J)*AXISGR(0,I,KKK)
              ENDDO
            ENDDO
            DO I=1,3
            DO J=1,3
              FIJGR(I,J,KKK)=0.
              DO K=1,3
              DO L=1,3
                FIJGR(I,J,KKK)=FIJGR(I,J,KKK)+B(I,K)*B(J,L)*FIJX(K,L)
              ENDDO
              ENDDO
            ENDDO
            ENDDO
        ENDIF

        IF (IFRAG(IPH).EQ.1) THEN

C ********************************************************************
C *** SPLITS IN HALF AXES OF THE GRAIN WHEN LIMIT ASPECT RATIOS ARE REACHED

          IF(RATMAX.GE.CRIT_SHP(IPH)) THEN
            W(2)=W(2)/4.
            IF(RATMIN.GE.CRIT_SHP(IPH)/2.) W(1)=W(1)/4.

            DO I=1,3
              AXISGR(0,I,KKK)=SQRT(W(I))
              DO J=1,3
                FIJX(I,J)=XID3(I,J)*AXISGR(0,I,KKK)
              ENDDO
            ENDDO
            DO I=1,3
            DO J=1,3
              FIJGR(I,J,KKK)=0.
              DO K=1,3
              DO L=1,3
                FIJGR(I,J,KKK)=FIJGR(I,J,KKK)+B(I,K)*B(J,L)*FIJX(K,L)
              ENDDO
              ENDDO
            ENDDO
            ENDDO
          ENDIF     ! END OF IF RATMAX
C ********************************************************************
        ENDIF     ! END OF IF IFRAG

      ENDDO     ! END OF DO KKK

C ********************************************************************
      ENDIF      ! END OF IF ISHAPE.GT.0
C ********************************************************************
CFEE
      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE UPDATE_ORIENTATION    --->   VERSION 11/JAN/2009
C
C     USES SHEAR RATES AND GRAIN SHAPE TO CALCULATE GRAIN VELOCITY GRADIENT.
C     UPDATES GRAIN ORIENTATIONS DUE TO CRYSTALLOGRAPHIC SHEAR (SLIP &
C     TWINNING) BUT DOES NOT PERFORM TWIN REORIENTATION.
C
C     CNT: modified to use only phase-associated tensors when ISHAPE.LE.1
C     RAL: split in 3 DO loops to deal with co-rotations (17/02/00)
C     CNT: moved last loop to subroutine UPDATE_TWINNING (05/06/02)
C     CNT: fixed bug in LIJ calculation when IFLAT=1     (21/JUN/2008)
C     CNT: replaced subr REORIENT GRAIN with RODRIGUES   (OCT/2009)
C **************************************************************************

      SUBROUTINE UPDATE_ORIENTATION

      INCLUDE 'vpsc7.dim'

      DIMENSION as(3,3,3,3),east(3,3)
      dimension dnsa(3),dbsa(3),rotslip(3,3),rotloc(3,3),corot(3,3)
      dimension aux5(5),aux55(5,5),aux3333(3,3,3,3)
      dimension rot(3,3,NGRPEL),aa(3,3),arot(3,3)
      dimension XLIJGRX(3,3),XLIJGR0(3,3)

cc    ROTPLASTAV=0.
cc    ROTLOCALAV=0.
cc    ROTTOTALAV=0.

      KGX=1
      DO 2000 IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1

        DO I=1,3
        DO J=1,3
          XLIJPH(I,J,IPH)=0.
        ENDDO
        ENDDO

        IF(ISHAPE(IPH).LE.1) THEN
          DO I=1,3
          DO J=1,3
          DO K=1,3
          DO L=1,3
            AS(I,J,K,L)=ASPH(I,J,K,L,IPH)
          ENDDO
          ENDDO
          ENDDO
          ENDDO
        ENDIF

C *** THE FOLLOWING TO AVOID EMPTY 'CHILD' PHASE IN COMP GRAIN MODEL
        IF(WPH(IPH).LT.1.E-6) GO TO 2000

      DO 1000 KKK=NGR(IPH-1)+1,NGR(IPH)

C *** CALCULATES LOCAL ROTATION ROTLOC=PI*S**(-1)*(DG-DAV) FOR EVERY GRAIN.
C *** ROTLOC IS ZERO FOR TAYLOR CALCULATION.

        IF(INTERACTION.LE.0) THEN
          DO I=1,3
          DO J=1,3
            ROTLOC(I,J)=0.
          ENDDO
          ENDDO
        ELSE IF(INTERACTION.GT.0) THEN
CFEB
          IF(ISHAPE(IPH).GE.2) THEN
            DO I=1,3
            DO J=1,3
            DO K=1,3
            DO L=1,3
              AS(I,J,K,L)=ASGR(I,J,K,L,KKK)
            ENDDO
            ENDDO
            ENDDO
            ENDDO
          ENDIF
CFEE
          DO I=1,5
            AUX5(I)=DG(I,KGX)-DAV(I)
          ENDDO

          CALL CHG_BASIS(AUX5,EAST,AUX55,AUX3333,1,5)

          DO I=1,3
          DO J=1,3
          ROTLOC(I,J)=0.
            DO K=1,3
            DO L=1,3
              ROTLOC(I,J)=ROTLOC(I,J)+AS(I,J,K,L)*EAST(K,L)
            ENDDO
            ENDDO
          ENDDO
          ENDDO

        ENDIF

C *** CALCULATES VELOCITY GRADIENT IN EACH PHASE AND EACH GRAIN

        DO I=1,3
        DO J=1,3
          AA(I,J)=AG(I,J,KKK)
          XLIJGR0(I,J)=0.
        ENDDO
        ENDDO

        do is=1,nsyst(IPHEL)
          do i=1,3
            dnsa(i)=0.
            dbsa(i)=0.
            do j=1,3
              dnsa(i)=dnsa(i)+aa(i,j)*dnca(j,is,IPHEL)
              dbsa(i)=dbsa(i)+aa(i,j)*dbca(j,is,IPHEL)
            enddo
          enddo
          do i=1,3
          do j=1,3
            XLIJGR0(I,J)=XLIJGR0(I,J)+DBSA(I)*DNSA(J)*GAMDOT(IS,KGX)
          enddo
          enddo
        enddo

        DO I=1,3
        DO J=1,3
          XLIJGRX(I,J)=ROTBAR(I,J)+ROTLOC(I,J)+
     #                     (XLIJGR0(I,J)+XLIJGR0(J,I))/2.
          XLIJPH(I,J,IPH)=XLIJPH(I,J,IPH)+XLIJGRX(I,J)*WGT(KKK)/WPH(IPH)
        ENDDO
        ENDDO
CFEB
        IF(ISHAPE(IPH).GT.0) THEN
          DO I=1,3
          DO J=1,3
            XLIJGR(I,J,KKK)=XLIJGRX(I,J)
          ENDDO
          ENDDO
        ENDIF
CFEE
C *** CRYSTALLOGRAPHIC GRAIN ROTATION (RIGID minus PLASTIC)
        DO I=1,3
        DO J=1,3
          ROTSLIP(I,J)=(XLIJGR0(I,J)-XLIJGR0(J,I))/2.
        ENDDO
        ENDDO
        DO I=1,3
        DO J=1,3
          ROT(I,J,KGX)=(ROTBAR(I,J)+ROTLOC(I,J)-ROTSLIP(I,J))*TINCR
        ENDDO
        ENDDO

C *** AVERAGE PLASTIC, LOCAL & TOTAL ROTATION (FOR STATISTICAL PURPOSES ONLY)
cc      ROTPLASTAV=ROTPLASTAV+
cc   #    SQRT(ROTSLIP(3,2)**2+ROTSLIP(1,3)**2+ROTSLIP(2,1)**2)*WGT(KKK)
cc      ROTLOCALAV=ROTLOCALAV+
cc   #    SQRT(ROTLOC(3,2)**2+ROTLOC(1,3)**2+ROTLOC(2,1)**2)*WGT(KKK)
cc      ROTTOTALAV=ROTTOTALAV+SQRT(ROT(3,2,KGX)**2+
cc   #    ROT(1,3,KGX)**2+ROT(2,1,KGX)**2)*WGT(KKK)/TINCR

        KGX=KGX+1
1000  CONTINUE      ! END OF DO LOOP OVER GRAINS
2000  CONTINUE      ! END OF DO LOOP OVER PHASES

cc    WRITE( *,'('' PLA, LOC, TOT '',3F12.4)')
cc   #              ROTPLASTAV,ROTLOCALAV,ROTTOTALAV

      KGX=1
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)

        DO I=1,3
        DO J=1,3
          AA(I,J)=AG(I,J,KKK)
          COROT(I,J)=0.
          do in=0,nneigh
            corot(i,j)=corot(i,j)+rot(i,j,neigh(in,kgx))*wneigh(in,kgx)
          enddo
        ENDDO
        ENDDO

C *** CALCULATE THE NEW TRASFORMATION MATRIX AND UPDATE

        CALL RODRIGUES (COROT,AROT)

        DO I=1,3
        DO J=1,3
          AG(I,J,KKK)=0.
          DO K=1,3
            AG(I,J,KKK)=AG(I,J,KKK)+AROT(I,K)*AA(K,J)
          ENDDO
        ENDDO
        ENDDO

        KGX=KGX+1
        ENDDO      ! END OF DO LOOP OVER GRAINS
      ENDDO      ! END OF DO LOOP OVER PHASES


      RETURN
      END
C
C **************************************************************************
C     SUBROUTINE UPDATE_SCHMID
C
C     ROTATES SCHMID TENSORS OF EACH GRAIN FROM CRYSTAL TO SAMPLE AXES
C **************************************************************************
      SUBROUTINE UPDATE_SCHMID

      INCLUDE 'vpsc7.dim'

      DIMENSION aux5(5),aux33(3,3),aux55(5,5),aux3333(3,3,3,3)
      DIMENSION aux33r(3,3)

      KGX=1
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        DO IS=1,NSYST(IPHEL)

          DO J=1,5
            AUX5(J)=SCHCA(J,IS,IPHEL)
          ENDDO

          CALL CHG_BASIS(AUX5,AUX33,AUX55,AUX3333,1,5)

          DO I=1,3
          DO J=1,3
            AUX33R(I,J)=0.
            DO I1=1,3
            DO J1=1,3
              AUX33R(I,J)=AUX33R(I,J)+AG(I,I1,KKK)*AG(J,J1,KKK)*
     #                                AUX33(I1,J1)
            ENDDO
            ENDDO
          ENDDO
          ENDDO

          CALL CHG_BASIS(AUX5,AUX33R,AUX55,AUX3333,2,5)

          DO J=1,5
            SCH(J,IS,KGX)=AUX5(J)
          ENDDO
        ENDDO

      KGX=KGX+1
      ENDDO
      ENDDO

      RETURN
      END
C
C ************************************************************************
C    SUBROUTINE UPDATE_TWINNING   --->   VERSION OF 23/NOV/2010
C
C --> CNT MODIFIED ON SEPT 2005: NOW THE STATS ON TWINNING ARE DONE INSIDE
C     1st DO LOOP. THE TAGGING FOR REORIENTATION IS DONE INSIDE 2nd LOOP.
C --> OPTION FOR TYPE I or TYPE II TWIN REORIENTATION ADDED 14/NOV/2010
C ************************************************************************
C
C    IPTSGR(KGX):    INDEX OF PREDOMINANT TWIN SYSTEM IN THE GRAIN.
C    IPTMGR(KGX):    INDEX OF PREDOMINANT TWIN MODE IN THE GRAIN.
C    TWFRGR(TWM):    ACCUMULATED TWIN FRACT IN EACH MODE IN GRAIN KKK
C                    IN THE STEP (relative to grain).
C
C    TWFRSY(TWS,KKK):ACCUMMULATED TWIN VOLUME FRACTION IN SYSTEM TWS
C                    IN GRAIN KKK (relative to grain).
C    TWFRPH(TWM,IPH):ACCUMULATED TWIN FRACT IN EACH MODE OF EACH PHASE
C                    (relative to phase volume).
C    EFTWFR(TWM,IPH):ACCUM TWIN FRACTION GIVEN BY THE REORIENTED GRAINS
C                    IN EACH MODE OF EACH PHASE (relative to phase volume).
C    KTWSMX(KKK):INDEX OF THE PREDOMINANT TWIN SYSTEM (MAX TWIN VOLUME)
C                IN THE GRAIN. USED FOR REORIENTING GRAIN.
C                   =0 IF THE GRAIN IS NOT TAGGED FOR REORIENTATION.
C                   >0 IF THE GRAIN IS TAGGED FOR REORIENTATION.
C                   <0 IF THE GRAIN HAS BEEN REORIENTED AND IS NOT TO BE
C                      RETAGGED FOR SECONDARY TWINNING
C
C    PRITW(IPH) :ACCUMMULATED TWIN FRACT IN EACH PHASE ASSOCIATED WITH
C                GRAINS THAT WERE TWIN REORIENTED ONCE.
C    SECTW(IPH) :ACCUMMULATED TWIN FRACT IN EACH PHASE ASSOCIATED WITH
C                GRAINS THAT WERE TWIN REORIENTED MORE THAN ONCE.
C    NTWEVENTS(KKK) :NUMBER OF TIMES THAT GRAIN 'KKK' HAS BEEN REORIENTED.
C                    0: NONE, 1: PRIMARY, 2:SECONDARY, 3:TERTIARY
C ************************************************************************

      SUBROUTINE UPDATE_TWINNING (IPH)

      INCLUDE 'vpsc7.dim'

      DIMENSION IMARK(NGRPEL)
      DIMENSION TWFRGR(NTWMMX,NGRPEL),IPTSGR(NGRPEL),IPTMGR(NGRPEL)
      DIMENSION TWB(3),TWN(3),ACRYS(3,3),ATWIN(3,3)

      IF(WPH(IPH).EQ.0.) RETURN

      IPHEL=IPH-IPHBOT+1
      KGX=1
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        IPTSGR(KGX)=0
        IPTMGR(KGX)=0
        TWFMAX=0.
        ITS=NSLSYS(IPHEL)
        KTS=0
        DO ITM=1,NTWMOD(IPHEL)
          KK=ITM+NMODES(IPHEL)-NTWMOD(IPHEL)
          GMODE=0.
          TWFRGR(ITM,KGX)=0.
          TWSHX=TWSH(ITM,IPHEL)

          DO NSMX=1,NSM(KK,IPHEL)
            KTS=KTS+1             ! shifted counter for twin systems
            ITS=ITS+1             ! absolute counter over all systems
            IF(GAMDOT(ITS,KGX).GT.0.) THEN
              GABS=ABS(GAMDOT(ITS,KGX))*TINCR
              GMODE=GMODE+GABS
              TWFRSY(KTS,KKK)=TWFRSY(KTS,KKK)+GABS/TWSHX
            ENDIF
            TWFRGR(ITM,KGX)=TWFRGR(ITM,KGX)+TWFRSY(KTS,KKK)
            rand=1.0
ccc         rand=0.8+0.2*ran2(jran)   ! adds stochasticity to selection
            IF (TWFRSY(KTS,KKK)*rand.GT.TWFMAX) THEN
              IPTSGR(KGX)=ITS
              IPTMGR(KGX)=ITM
              TWFMAX=TWFRSY(KTS,KKK)
            ENDIF
          ENDDO

          TWFRPH(ITM,IPH)=TWFRPH(ITM,IPH)+
     #                     (GMODE/TWSHX)*(WGT(KKK)/WPH(IPH))
        ENDDO      ! END OF LOOP OVER TWIN MODES IN THE PHASE
        KGX=KGX+1
      ENDDO      ! END OF DO KKK OVER GRAINS IN THE PHASE

c     do kkk=ngr(iph-1)+1,ngr(iph)
c       write(10,'(''shear rates in grain'',i5,/,(6f10.4) )')
c    #    kkk,(gamdot(is,kkk),is=1,nsyst(iphel))
c       write(10,'(''twin fractions in grain'',i5,2x,12f10.4)')
c    #    kkk,(twfrsy(its,kkk),its=1,ntwsys(iphel))
c     enddo

C *********************************************************************
C    THIS LOOP SCANS ALL GRAINS IN THE PHASE/ELEM IN A RANDOM WAY AND
C    TAGS THEM FOR CHECKING AGAINST THE TWIN-REORIENTATION CRITERION.
C    IMARK(1:NGPHASE) TAGS WITH '1' THE GRAINS AS THEY ARE PICKED.
C    IN EACH LOOP ITERAT A GRAIN 'KKK' IS RANDOMLY PICKED AND REORIENTED
C    IN THE PTS IF THE 'REAL' TWIN FRACTION IS NOT EXCEEDED.
C *********************************************************************

      NGPHASE=NGR(IPH)-NGR(IPH-1)
      KLEFT  =NGPHASE
      DO I=1,NGPHASE
        IMARK(I)=0
      ENDDO

      DO INDEX=1,NGPHASE    ! tags one of the yet unchecked grains
        RAND=RAN2(JRAN)
        KPOINT=INT(RAND*KLEFT)+1
        KLEFT=KLEFT-1
        KACUM=0
        IGR=0
        DO WHILE(IGR.LT.NGPHASE .AND. KPOINT.NE.0)  ! identifies tagged grain
          IGR=IGR+1
          IF(IMARK(IGR).EQ.0) THEN
            KACUM=KACUM+1
            IF(KACUM.EQ.KPOINT) THEN
              KKK=IGR+NGR(IPH-1)     ! absolute index of grain
              KGX=IGR                ! index of grain relative to element
              IMARK(IGR)=1
              IPTS=IPTSGR(KGX)
              IPTM=IPTMGR(KGX)

c     nslsyx=nslsys(iphel)
c     if(igr.le.10) then
c     write(10,'(''grain/twmod/twsys/twfrsy'',
c    #          3i10,f12.5)') kkk,iptm,ipts,twfrsy(ipts-nslsyx,kkk)
c     write(10,'(''all shear rates'',3e12.4,/,(6e12.4))')
c    #          (gamdot(isx,kgx),isx=1,27)
c     endif
c     write(10,'(''  flipping  --> '',3i10,4f10.5)') kkk,iptm,ipts
c    #      ,eftwfr(iptm,1),twfrph(iptm,1),twflim,twfrgr(iptm,kgx)

C     LABELS THE GRAIN IF THE ACCUMULATED TWIN VOLUME IN THE PREDOMINANT
C     TWINNING SYSTEM (PTS) HAS EXCEEDED A THRESHOLD VALUE.
C     THIS GRAIN WILL BE COMPLETELY REORIENTED BY TWINNING.
C     REORIENTATION IS STOPPED WHEN THE EFFECTIVE REORIENTED FRACTION
C     REACHES THE 'REAL' TWIN FRACTION CALCULATED FROM THE SHEARS.
C     THRES1: MIN ACCUM TWIN FRACTION IN GRAIN BEFORE TWIN REOR IS SWITCHED ON.
C     THRES1+THRES2: EVENTUAL ACCUM TWIN FR IN GR REQUIRED TO TWIN REORIENT IT.

              IF(KTWSMX(KKK).EQ.0 .AND. IPTS.NE.0) THEN
                IF (EFTWFR(IPTM,IPH).LT.TWFRPH(IPTM,IPH)) THEN
                  THRES1=TWTHRES(1,IPTM,IPHEL)
                  THRES2=TWTHRES(2,IPTM,IPHEL)
                  TWFLIM=THRES1+THRES2*EFTWFR(IPTM,IPH)/
     #                                (TWFRPH(IPTM,IPH)+1.E-6)
                  IF (TWFRGR(IPTM,KGX).GT.TWFLIM) THEN
                    EFTWFR(IPTM,IPH)=EFTWFR(IPTM,IPH)+WGT(KKK)/WPH(IPH)
                    KTWSMX(KKK)=IPTS

c       write(10,'(''twins grain'',i5,3x,''twfrph/eftwfr/twflim'',
c    #       3f10.4)') kkk,twfrph(iptm,iph),eftwfr(iptm,iph),twflim

                  ENDIF
                ENDIF

C               KTWSMX(KKK)=0   ! activate to suppress twin reorient always

C *** REORIENTS BY TWINNING GRAINS TAGGED WITH KTWSMX>0 AND UPDATES THE
C *** ORIENTATION MATRIX. THIS IS DONE AFTER HAVING CALLED UPDATE_ORIENTATION
C *** WHICH REORIENTS THE GRAIN BECAUSE OF SHEAR (INCLUDING TWIN SHEARS)

                IF (KTWSMX(KKK).GT.0) THEN

                  KTW=KTWSMX(KKK)
                  ITWTYPEX=ITWTYPE(KTW,IPHEL)
                  DO I=1,3
                    DO J=1,3
                      ACRYS(I,J)=AG(I,J,KKK)
                    ENDDO
                    TWN(I)=DNCA(I,KTW,IPHEL)
                    TWB(I)=DBCA(I,KTW,IPHEL)
                  ENDDO
                  CALL TWIN_ORIENTATION (ITWTYPEX,TWB,TWN,ATWIN)

                  DO I=1,3
                  DO J=1,3
                    AG(I,J,KKK)=0.
                    DO K=1,3
                      AG(I,J,KKK)=AG(I,J,KKK)+ACRYS(I,K)*ATWIN(K,J)
                    ENDDO
                  ENDDO
                  ENDDO

C *** RESET ACCUMULATED TWINNED FRACTIONS IN THE GRAIN
                  DO IS=1,NTWSYS(IPHEL)
                    TWFRSY(IS,KKK)=0.
                  ENDDO
CFEB
C *** ACCUMULATES TWINNED VOLUME FRACTION IN EACH PHASE.
                  IF(NTWEVENTS(KKK).EQ.0) THEN
                    PRITW(IPH)=PRITW(IPH)+WGT(KKK)/WPH(IPH)
                  ELSE IF(NTWEVENTS(KKK).GT.0) THEN
                    SECTW(IPH)=SECTW(IPH)+WGT(KKK)/WPH(IPH)
                  ENDIF
CFEE
                  NTWEVENTS(KKK)=NTWEVENTS(KKK)+1
                  IF(ISECTW(KTW,IPHEL).EQ.0 .OR. NTWEVENTS(KKK).GT.1)
     #                   KTWSMX(KKK)=-KTWSMX(KKK)         ! SUPPRESES SECTW
                  IF(ISECTW(KTW,IPHEL).EQ.1 .AND.NTWEVENTS(KKK).LE.1)
     #                   KTWSMX(KKK)= 0                   ! ALLOWS SECTW

C *** RESET CRSS IN SL & TW SYSTEMS TO INITIAL (OR OTHER) VALUES
C                 GTOTGR(KKK)=0
C                 DO IS=1,NSLSYS(IPHEL)
C                   CRSS(IS,KKK)=TAU(IS,0,IPHEL)
C                 ENDDO
C                 DO IS=NSLSYS(IPHEL)+1,NSYST(IPHEL)
C                   CRSS(IS,KKK)=5.0*CRSS(IS,KKK)
C                 ENDDO

                ENDIF      ! END OF IF KTWSMX(KKK)>0
              ENDIF      ! END OF IF KTWSMX(KKK)=0
            ENDIF      ! END OF IF(KACUM.EQ.KPOINT)
          ENDIF      ! END OF IF(IMARK(IGR).EQ.0)
        ENDDO      ! END OF DO WHILE(IGR.LT.NGPHASE)
      ENDDO      ! END OF DO INDEX=1,NGPHASE

      RETURN
      END
CFEB
C *******************************************************************
C     SUBROUTINE VAR_VEL_GRAD      --->      VERSION 03/jan/2009
C
C     IMPOSES A NON-UNIFORM DEFORMATION HISTORY TO THE AGGREGATE.
C     THE VELOCITY GRADIENT IS FULLY IMPOSED AND READ FROM 'FILEHIST'.
C *******************************************************************
      SUBROUTINE VAR_VEL_GRAD (IOPTION)

      INCLUDE 'vpsc7.dim'

      DIMENSION AUX55(5,5),AUX3333(3,3,3,3)


C ***********************************************************************
      IF(IOPTION.EQ.0) THEN

C *** WRITES LOAD CONDITIONS FILE INTO 'RUN_LOG.OUT' FILE
      WRITE(10,*)
      WRITE(10,'(''*** LOAD HISTORY FOR THIS RUN'')')
      DO IDUM=1,200
        READ(UR6,END=100,FMT='(A)') PROSA
        WRITE(10,'(A)') PROSA
      ENDDO
  100 REWIND UR6

      READ(UR6,*) NSTEPS,ICTRL,CTRLINCR,TEMPERAT
      READ(UR6,*)
      CTRLINCR=CTRLINCR   ! to fool compiler
      IF(ICTRL.NE.7) THEN
        WRITE(*,'('' VARIABLE VELOCITY GRADIENT OPTION ASSUMES THAT'')')
        WRITE(*,'('' THE VELOCITY GRADIENT AND A TIME INCREMENT ARE'')')
        WRITE(*,'('' IMPOSED AT EACH STEP --> SET ICTRL=7 !!'')')
      STOP
      ENDIF

C *** GENERAL SETTINGS FOR FULLY IMPOSED VARIABLE VELOCITY GRADIENT
        DO I=1,3
        DO J=1,3
          IUDOT(I,J)=1
          SCAUCHY(I,J)=0.
        ENDDO
        ENDDO
        DO I=1,6
          IDSIM(I)=1
          ISCAU(I)=0
        ENDDO
        STRAIN_CONTROL=1

      ENDIF
C ***********************************************************************
      IF(IOPTION.EQ.1) THEN

C *** READS COMPONENTS OF VELOCITY GRADIENT AND TIME INCRMENT FOR THE STEP

      READ(UR6,*) IDUMMY,((UDOT(I,J),J=1,3),I=1,3),TINCR

      IDUMMY=IDUMMY      ! to fool the compiler
      DO I=1,3
      DO J=1,3
        DSIM(I,J)=(UDOT(I,J)+UDOT(J,I))/2.
      ENDDO
      ENDDO
      CALL CHG_BASIS (DBAR,DSIM,AUX55,AUX3333,2,5)

      ENDIF
C ***********************************************************************

      RETURN
      END
CFEE
C
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C     SUBROUTINE VOIGT   ---->   VERSION OF 09/02/98
C
C     TRANSFORMS 6X1 MATRIX T1 INTO SECOND ORDER TENSOR T2 IF IOPT=1
C     AND VICEVERSA IF IOPT=2.
C     TRANSFORMS 6X6 MATRIX C2 INTO FOURTH ORDER TENSOR C4 IF IOPT=3
C     AND VICEVERSA IF IOPT=4.
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      SUBROUTINE VOIGT(T1,T2,C2,C4,IOPT)

      DIMENSION T1(6),T2(3,3),C2(6,6),C4(3,3,3,3)
      DIMENSION IJV(6,2)
      DATA ((IJV(N,M),M=1,2),N=1,6)/1,1,2,2,3,3,2,3,1,3,1,2/

      IF(IOPT.EQ.1) THEN
      DO 30 I=1,6
      I1=IJV(I,1)
      I2=IJV(I,2)
      T2(I1,I2)=T1(I)
   30 T2(I2,I1)=T1(I)
      ENDIF
C
      IF(IOPT.EQ.2) THEN
      DO 40 I=1,6
      I1=IJV(I,1)
      I2=IJV(I,2)
   40 T1(I)=T2(I1,I2)
      ENDIF
C
      IF (IOPT.EQ.3) THEN
      DO 10 I=1,6
      I1=IJV(I,1)
      I2=IJV(I,2)
      DO 10 J=1,6
      J1=IJV(J,1)
      J2=IJV(J,2)
      C4(I1,I2,J1,J2)=C2(I,J)
      C4(I2,I1,J1,J2)=C2(I,J)
      C4(I1,I2,J2,J1)=C2(I,J)
   10 C4(I2,I1,J2,J1)=C2(I,J)
      ENDIF
C
      IF(IOPT.EQ.4) THEN
      DO 20 I=1,6
      I1=IJV(I,1)
      I2=IJV(I,2)
      DO 20 J=1,6
      J1=IJV(J,1)
      J2=IJV(J,2)
   20 C2(I,J)=C4(I1,I2,J1,J2)
      ENDIF
C
      RETURN
      END

C********************************************************************
C     SUBROUTINE VPSC     --->      VERSION 12/DEC/2011
C********************************************************************

      SUBROUTINE VPSC (ISTEP)

      INCLUDE 'vpsc7.dim'

      DIMENSION EGA(3,3,3,3),RGA(3,3,3,3),
     #          C4SA(3,3,3,3),ESA(3,3,3,3),RSA(3,3,3,3),
     #          EINVSA(3,3,3,3)
      DIMENSION PGA(3,3),PSA(3,3),P5(5)
      DIMENSION E5(5,5),E5INV(5,5)
      DIMENSION XMTNEW(5,5)
      DIMENSION XIMSINV(5,5),FS(5,5),XMAST(5,5)
      DIMENSION XMCBCTG(5,5),XMTBAVE(5,5)
      DIMENSION BC1(5,5),BC2(5,5),BCINV(5,5),BCAVE(5,5)
      DIMENSION AUX5(5),AUX33(3,3),AUX55(5,5),AUX3333(3,3,3,3)
      DIMENSION DBAUX(5)
      DIMENSION EIGB(3,3),AXB(3)

      DIMENSION IDLEQ(5),ISLEQ(5)
cw      DIMENSION DAUX(6),SAUX(6),AUX66(6,6)

      dimension xmcphc(5),xmtphave(5),dsimaux(3,3)
      dimension phave(5),dzero1(5),dznew(5)

C *** FOR A TAYLOR CASE (INTERACTION=0) SOLVES VP EQUATION FOR GRAIN STRESS.
C *** CALCULATE STRAIN-RATE 'DG' AND MODULI 'XMCTG' FOR EVERY GRAIN.

      IF(INTERACTION.EQ.0) THEN
        KGX=1
        DO IPH=IPHBOT,IPHTOP
          IPHEL=IPH-IPHBOT+1
          DO KKK=NGR(IPH-1)+1,NGR(IPH)
            DO I=1,5
              STRY(I,KGX)=SG(I,KKK)
            ENDDO
              CALL GRAIN_STRESS (INTERACTION,KGX,KKK,IPHEL,IPH)
              CALL GRAIN_RATE_AND_MODULI (0,0,KGX,KKK,IPHEL,IPH)
           KGX=KGX+1
          ENDDO
        ENDDO

C *** CALCULATE AVERAGE STRESS AND STRAIN-RATE

        DO I=1,5
          SAV(I)=0.
          DAV(I)=0.
          KGX=1
          DO IPH=IPHBOT,IPHTOP
            DO KKK=NGR(IPH-1)+1,NGR(IPH)
              SAV(I)=SAV(I)+SG(I,KKK)*WGT(KGX)
              DAV(I)=DAV(I)+DG(I,KGX)*WGT(KGX)
              KGX=KGX+1
            ENDDO
          ENDDO
          SBAR(I)=SAV(I)      ! ONLY REQUIRED TO CALCULATE DVM & SVM
        ENDDO
        CALL CHG_BASIS(SBAR,SDEVIAT,AUX55,AUX3333,1,5)

        RETURN
      ENDIF

C *** CASE OF SELF-CONSISTENT CALCULATION (INTERACTION>0)
c
      if(irsvar.eq.0) then
        jxrsini=nrs(1,1)
        jxrsfin=nrs(1,1)
        jxrstep=nrs(1,1)
      endif
cwx
cwx   comment next line to perform
cwx   rs loop at every step
cwx
      if(istep.gt.1) jxrsini=jxrsfin
cwx
      IRS=0
      DO JXRS=JXRSINI,JXRSFIN,JXRSTEP
      IRS=IRS+1
CFEB
C *** QUADRATIC EXTRAPOLATION GUESS FOR ASO and ESO
      IF(INTERACTION.EQ.5 .AND. IRS.GE.4) THEN
        CALL EXTRAPOLSO(1./JXRS,IRS,2)
      ENDIF
CFEE
      if(jxrsini.ne.jxrsfin) then
        write(*,*)
        write(*,*) 'NRS ITERATION', IRS
        write(*,*)
      endif
c
      ITSO=0
      ERRESO=2.*ERRSO
      ERRASO=2.*ERRSO
      KSO=1

      DO WHILE( KSO.EQ.1. AND.
     #  (ERRESO.GT.ERRSO.OR.ERRASO.GT.ERRSO) .AND. ITSO.LT.ITMAXSO )

      IF(INTERACTION.NE.5) KSO=0
      ITSO=ITSO+1
      IF(INTERACTION.EQ.5) then
       write(*,*)
       write(*,'(a,i4)') ' SECOND-ORDER ITERATION ',itso
       write(*,*)
      ENDIF

      RELSGR=2*ERRS
      RELS=2*ERRS
      RELD=2*ERRD

C *** OUTER LOOP: VARIES STRESS AND COMPLIANCE IN THE GRAINS

      IT2=0
c
      DO WHILE( (RELSGR.GT.ERRS.OR.RELD.GT.ERRD.OR.RELS.GT.ERRS)
     # .AND. IT2.LT.ITMAXEXT)
c
      IT2=IT2+1

C *** INNER LOOP: VARIES OVERALL TANGENT COMPLIANCE

      IT1TG=0
      RER1TG=2*ERRM

      DO WHILE(RER1TG.GT.ERRM.AND.IT1TG.LT.ITMAXINT)

        IT1TG=IT1TG+1

        DO I=1,5
          XMTPHAVE(I)=0.
          PHAVE(I)=0.
          DO J=1,5
            BCAVE(I,J)=0.
            XMTBAVE(I,J)=0.
          ENDDO
        ENDDO

C *************************************************************************
C     CALCULATE ESHELBY TENSOR S=S(Mtg) AND FS=[1/(I-S)]S.
C     S(Mtg) WILL BE THE SAME FOR EVERY GRAIN IN A GIVEN PHASE WHEN
C     ISHAPE.LE.1.
C     IT WILL BE DIFFERENT FOR EVERY GRAIN WHEN ISHAPE.GE.2 BECAUSE Mtg OR
C     Msec HAVE TO BE ROTATED TO ELLIPSOID AXES AND, IN ADDITION, THE
C     SIZE OF THE ELLIPSOID AXES IS DIFFERENT FOR EVERY GRAIN.
C     WHEN Mtg=n*MseC THEN S(Mtg)=S(Msec), INDEPENDENT OF ISHAPE VALUE.
C *************************************************************************

C *** SKIP EVERY OTHER CALCULATION OF MSTAR
      ISKIP=1
      IF(ISKIP.EQ.1) THEN

      CALL CHG_BASIS(AUX5,AUX33,XLTG,C4SA,3,5)

C **************************************************************************
C *** LOOP #1 OVER PHASES AND GRAINS
C **************************************************************************

      KGX=1
      DO IPH=IPHBOT,IPHTOP

        IF(ISHAPE(IPH).LE.1) THEN
          DO I=1,3
            AXB(I)=AXISPH(0,I,IPH)
            DO J=1,3
              EIGB(I,J)=AXISPH(I,J,IPH)
            ENDDO
          ENDDO
        ENDIF

      DO KKK=NGR(IPH-1)+1,NGR(IPH)
CFEB
        if(ishape(iph).ge.2) then      ! INDIVIDUAL GRAIN SHAPE
          do i=1,3
            axb(i)=AXISGR(0,I,KKK)
            do j=1,3
              eigb(i,j)=AXISGR(i,j,kkk)
            enddo
          enddo
        endif
CFEE
C *** ESHELBY CALCULATION FOR EVERY PHASE OR FOR EVERY GRAIN

      IF(ISHAPE(IPH).GE.2 .OR. KKK.EQ.NGR(IPH-1)+1) THEN

C     ROTATION OF STIFFNESS 'C4SA' TO ELLIPSOID PRINCIPAL AXES
      DO 95 I=1,3
      DO 95 J=1,3
      DO 95 M=1,3
      DO 95 N=1,3
        DUMMY=0.
        DO 90 I1=1,3
        DO 90 J1=1,3
        DO 90 M1=1,3
        DO 90 N1=1,3
          DUMMY=DUMMY+EIGB(I1,I)*EIGB(J1,J)*EIGB(M1,M)
     #           *EIGB(N1,N)*C4SA(I1,J1,M1,N1)
   90   CONTINUE
        C4GA(I,J,M,N)=DUMMY
   95 CONTINUE

      IOPTION=2
      CALL ESHELBY(AXB,C4GA,0.,EGA,RGA,AUX33,PGA,PDIL,
     #             AUX3333,AUX3333,IOPTION)

c     write(10,'(''  distortion Eshelby tensor'')')
c     write(10,'(9f9.5)') ((((ega(i,j,k,l),l=1,3),k=1,3),j=1,3),i=1,3)
c     write(10,'(''  rotation Eshelby tensor'')')
c     write(10,'(9f9.5)') ((((rga(i,j,k,l),l=1,3),k=1,3),j=1,3),i=1,3)
c     write(10,'(''  hydrostatic Eshelby tensor'')')
c     write(10,'(3f9.5)') ((pga(i,j),j=1,3),i=1,3)
c     write(10,'(''  hydrostatic Eshelby factor'')')
c     write(10,'(1f9.5)') pdil

C     ROTATES THE DISTORTION, ROTATION AND PRESSURE ESHELBY TENSORS
C     FOR THE PHASE OR FOR EACH GRAIN BACK INTO SAMPLE AXES.

      IF(IOPTION.EQ.3) THEN
        DO I=1,3
        DO J=1,3
          DUMMYP=0.
          DO I1=1,3
          DO J1=1,3
            DUMMYP=DUMMYP+EIGB(I,I1)*EIGB(J,J1)*PGA(I1,J1)
          ENDDO
          ENDDO
          PSA(I,J)=DUMMYP
        ENDDO
        ENDDO
      ENDIF

      DO 130 I=1,3
      DO 130 J=1,3
      DO 130 M=1,3
      DO 130 N=1,3
        DUMMYE=0.
        DUMMYR=0.
        DO 120 I1=1,3
        DO 120 J1=1,3
        DO 120 M1=1,3
        DO 120 N1=1,3
          DUMMYE=DUMMYE+EIGB(I,I1)*EIGB(J,J1)*EIGB(M,M1)
     #           *EIGB(N,N1)*EGA(I1,J1,M1,N1)
          DUMMYR=DUMMYR+EIGB(I,I1)*EIGB(J,J1)*EIGB(M,M1)
     #           *EIGB(N,N1)*RGA(I1,J1,M1,N1)
  120   CONTINUE
        ESA(I,J,M,N)=DUMMYE
        RSA(I,J,M,N)=DUMMYR
  130 CONTINUE

      CALL CHG_BASIS(AUX5,AUX33,E5,ESA,4,5)
cw      CALL CHG_BASIS(P5,PSA,AUX55,AUX3333,2,5)

      DO I=1,5
      DO J=1,5
        E5INV(I,J)=E5(I,J)
        XIMSINV(I,J) =XID5(I,J)-E5(I,J)
      ENDDO
      ENDDO

      CALL LU_INVERSE(XIMSINV,5)
      CALL LU_INVERSE(E5INV,5)

      CALL CHG_BASIS(AUX5,AUX33,E5INV,EINVSA,3,5)

      DO I=1,5
      DO J=1,5
        FS(I,J)=0.
        DO K1=1,5
          FS(I,J)=FS(I,J)+XIMSINV(I,K1)*E5(K1,J)
        ENDDO
      ENDDO
      ENDDO

      DO I=1,5
      DO J=1,5
      XIMSINVPH(I,J,IPH)=XIMSINV(I,J)
      FSPH(I,J,IPH)=FS(I,J)
      ENDDO
      ENDDO
c
c
c     CALCULATE M* = inv(I-S) * S * Mtg
c
      DO I=1,5
      DO J=1,5
cw
        DUMMY=0.
        DO K=1,5
        DUMMY=DUMMY+FS(I,K)*XMTG(K,J)
        ENDDO
c
        if(interaction.eq.3) then      ! neff=10 case
c
        XMAST(I,J)=10*DUMMY
c
        else if(interaction.eq.4) then      ! tangent case
cw
cw        XMAST(I,J)=NRS(1,1)*DUMMY
cw
          if(irsvar.eq.1) then
            XMAST(I,J)=jxrs*DUMMY
          else
            XMAST(I,J)=NRS(1,1)*DUMMY
          endif
c
        else
c
          XMAST(I,J)=DUMMY
c
        endif
cw
      ENDDO
      ENDDO
C
C *** COPIES TENSORS INTO PHASE ARRAYS OR INTO GRAIN ARRAYS.
C *** 'ASPH' OR 'ASGR' ARE USED IN SUBR. UPDATE_ORIENTATION TO CALCULATE
C     SPIN-RATE DEVIATIONS.
C *** 'D5PH' OR 'D5GR' ARE USED IN SUBR. CALC_CAUCHY TO CALCULATE
C     PRESSURE DEVIATIONS.

      IF(ISHAPE(IPH).LE.1) THEN
        DO 140 I=1,3
        DO 140 J=1,3
        DO 140 K=1,3
        DO 140 L=1,3
          DUMMY=0.
          DO K1=1,3
          DO L1=1,3
            DUMMY=DUMMY+RSA(I,J,K1,L1)*EINVSA(K1,L1,K,L)
          ENDDO
          ENDDO
          ASPH(I,J,K,L,IPH)=DUMMY
  140   CONTINUE
      ENDIF
CFEB
      IF(ISHAPE(IPH).GE.2) THEN
        DO 150 I=1,3
        DO 150 J=1,3
        DO 150 K=1,3
        DO 150 L=1,3
          DUMMY=0.
          DO K1=1,3
          DO L1=1,3
            DUMMY=DUMMY+RSA(I,J,K1,L1)*EINVSA(K1,L1,K,L)
          ENDDO
          ENDDO
          ASGR(I,J,K,L,KKK)=DUMMY
  150   CONTINUE
      ENDIF

cw      IF(ICAUCHY.EQ.1) THEN
cw        DO I=1,5
cw          DUMMY=0.
cw          DO J=1,5
cw            DUMMY=DUMMY+P5(J)*E5INV(J,I)
cw          ENDDO
cw          IF(ISHAPE(IPH).LE.1) D5PH(I,IPH)=DUMMY
cw          IF(ISHAPE(IPH).GE.2) D5GR(I,KKK)=DUMMY
cw        ENDDO
cw      ENDIF
CFEE
      IF(ISHAPE(IPH).LE.1) THEN
        DO I=1,5
        DO J=1,5
          XMASTPH(I,J,IPH)=XMAST(I,J)
        ENDDO
        ENDDO
      ENDIF
CFEB
      IF(ISHAPE(IPH).GE.2) THEN
        DO I=1,5
        DO J=1,5
          XMASTGR(I,J,KKK)=XMAST(I,J)
        ENDDO
        ENDDO
      ENDIF
CFEE
      ENDIF           !  END OF IF(ISHAPE(IPH.GE.2 .OR. KKK.EQ.NGR(IPH-1)+1)

      KGX=KGX+1
      ENDDO           !  END OF DO OVER GRAINS   (LOOP #1)
      ENDDO           !  END OF DO OVER PHASES   (LOOP #1)

      ENDIF           !  END OF ESHELBY CALCULATION BIG IF

C **************************************************************************
C *** LOOP #2 OVER PHASES AND GRAINS
C **************************************************************************

C *** SOLVES ITERATIVELY SC EQUATION FOR GENERAL CASE OF DIFFERENT SHAPES.
C *** REQUIRED FOR MULTI-PHASE WHEN GRAINS OF EACH PHASE HAVE DIFFERENT SHAPE,
C     OR FOR ISHAPE>1, WHEN EVERY GRAIN HAS DIFFERENT SHAPE, OR BOTH.

      KGX=1
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        IF(ISHAPE(IPH).LE.1) THEN    ! shouldn't this be done outside DO KKK ?
          DO I=1,5
          DO J=1,5
            XMAST(I,J)=XMASTPH(I,J,IPH)
            BC2(I,J)  =XMAST(I,J)+XMTG(I,J)
          ENDDO
          ENDDO
        ENDIF
CFEB
        IF(ISHAPE(IPH).GE.2) THEN
          DO I=1,5
          DO J=1,5
            XMAST(I,J)=XMASTGR(I,J,KKK)
            BC2(I,J)  =XMAST(I,J)+XMTG(I,J)
          ENDDO
          ENDDO
        ENDIF
CFEE
        DO I=1,5
        DO J=1,5
          BC1(I,J)=XMAST(I,J)+XMCTG(I,J,KGX)
        ENDDO
        ENDDO

        CALL LU_INVERSE(BC1,5)
cc
        DO I=1,5
        DO J=1,5
CFEB
          CHIFLU(I,J,KGX)=BC1(I,J)
          DUM2=0.
CFEE
          DUMMY=0.
          DO K1=1,5
            DUMMY=DUMMY+BC1(I,K1)*BC2(K1,J)
CFEB
            DUM2=DUM2+XMCTG(I,K1,KGX)*BC1(K1,J)
CFEE
          ENDDO
          BC(I,J,KGX)=DUMMY
CFEB
          BETFLU(I,J,KGX)=DUM2
CFEE
        ENDDO
        ENDDO
cc
        DO I=1,5
          DUMMY=0.
          DO J=1,5
            DUMMY=DUMMY-
     #            BC1(I,J)*(DCZERO(J,KGX)-DZERO(J))
          ENDDO
          PHIC(I,KGX)=DUMMY
        ENDDO
cc
        DO I=1,5
        DO J=1,5
          XMCBCTG(I,J) =0.
          DO K1=1,5
            XMCBCTG(I,J)=XMCBCTG(I,J)+XMCTG(I,K1,KGX)*BC(K1,J,KGX)
          ENDDO
        ENDDO
        ENDDO
cc
        DO I=1,5
        XMCPHC(I)=DCZERO(I,KGX)
        DO J=1,5
        XMCPHC(I)=XMCPHC(I)+XMCTG(I,J,KGX)*PHIC(J,KGX)
        ENDDO
        ENDDO
cc
        DO I=1,5
cc
          XMTPHAVE(I)=XMTPHAVE(I)+XMCPHC(I)*WGT(KKK)
          IF(IBCINV.EQ.1) THEN
            PHAVE(I)=PHAVE(I)+PHIC(I,KGX)*WGT(KKK)
          ELSE
            PHAVE(I)=0.
          ENDIF
cc
        DO J=1,5
          BCAVE(I,J)  =BCAVE(I,J)  +BC(I,J,KGX)  *WGT(KGX)
          XMTBAVE(I,J)=XMTBAVE(I,J)+XMCBCTG(I,J) *WGT(KGX)
        ENDDO
        ENDDO
        KGX=KGX+1

      ENDDO
      ENDDO

C ****************************************************************
C *** END OF LOOP #2 OVER GRAINS AND PHASES
C ****************************************************************

      DO I=1,5
      DO J=1,5
c
        IF(IBCINV.EQ.1) THEN
          BCINV(I,J)=BCAVE(I,J)
        ELSE
          BCINV(I,J)=XID5(I,J)
         ENDIF
c
      ENDDO
      ENDDO

      CALL LU_INVERSE(BCINV,5)

      DO I=1,5
      DO J=1,5
        XMTNEW(I,J)=0.
        DO K1=1,5
          XMTNEW(I,J)=XMTNEW(I,J)+XMTBAVE(I,K1)*BCINV(K1,J)
        ENDDO
      ENDDO
      ENDDO


C *************************************************************************
C     Mold-Mnew (tangent) COMPARISON

        RER1TG=TMISMATCH5x5(XMTG,XMTNEW)
CFEB
c       WRITE(*,'(1H+,5X,''IT1TAN='',I3,'' --> TAN MOD REL ERROR'',
c    #          2E12.3)') IT1TG,RER1TG
c       WRITE(*,'(1H+,I5,3E11.3,I7,E11.3,I7,E11.3)')
c    #        IT2,RELSGR,RELS,RELD, IT1TG,RER1TG
CFEE
      DO I=1,5
      DO J=1,5
        XMTG(I,J)=XMTNEW(I,J)
        XLTG(I,J)=XMTNEW(I,J)
      ENDDO
      ENDDO

      CALL LU_INVERSE(XLTG,5)

      if(interaction.eq.1.or.interaction.eq.5) then       ! affine or SO
        DO I=1,5
          DZERO1(I)=0.
          DO K1=1,5
            DZERO1(I)=DZERO1(I)+XMTNEW(I,K1)*PHAVE(K1)
          ENDDO
        ENDDO
        DO I=1,5
          DZNEW(I)=XMTPHAVE(I)-DZERO1(I)
        ENDDO
        RERDZERO=VMISMATCH(DZERO,DZNEW,5)
        DZERO=DZNEW
cc      write(*,*)
cc      write(*,*) 'DZERO=',dzero
      else
        DO I=1,5
          DZERO(I)=0.
        ENDDO
        RERDZERO=0.
      endif
      RERDZERO=RERDZERO    ! to fool the compiler
c
cw       WRITE(*,'(1H+,5X,''IT1TAN='',I3,'' --> TG,D0 REL ERRORS'',
cw     #          2E12.3)') IT1TG,RER1TG,RERDZERO
c
      ENDDO         !  END OF (DO..WHILE) FOR INNER ITERATION (IT1TG)

C *************************************************************************
C     BOUNDARY CONDITIONS:
C     * IF DIAGONAL IMPOSED CALLS SUBROUTINE 'STATE_5x5' (RL: 26/1/00)
C       AND SOLVES STRESS-STRAIN COMPONENTS IN DEVIATORIC SPACE
C     * ELSE, CALLS SUBROUT 'STATE_6x6' WITH DSIM(3,3) & SCAUCHY(3,3)
C       PLUS INDICES OF THE KNOWN COMPONENTS. SOLVES FOR UNKNOWN COMPONENTS
C       IN 6-DIM CAUCHY SPACE.
c
      DO I=1,5
        DBAUX(I)=DBAR(I)-DZERO(I)
      ENDDO
c
      IF(IDSIM(1)*IDSIM(2)*IDSIM(3).EQ.1) THEN

        idleq(1)=1
        idleq(2)=1
        idleq(3)=idsim(4)
        idleq(4)=idsim(5)
        idleq(5)=idsim(6)

        isleq(1)=0
        isleq(2)=0
        isleq(3)=iscau(4)
        isleq(4)=iscau(5)
        isleq(5)=iscau(6)

        CALL STATE_5x5 (IDLEQ,DBAUX,ISLEQ,SBAR,XMTG)
c
        DO I=1,5
          DBAR(I)=DBAUX(I)+DZERO(I)
        ENDDO
c
        CALL CHG_BASIS (DBAR,DSIM   ,AUX55,AUX3333,1,5)
        CALL CHG_BASIS (SBAR,SDEVIAT,AUX55,AUX3333,1,5)
c
cw      write(*,*) dzero
cw      write(*,*) dbar
cw      write(*,*) sbar
cw      pause

      ELSE

        CALL CHG_BASIS (DBAUX,DSIMAUX,AUX55,AUX3333,1,5)
        CALL STATE_6x6 (IDSIM,DSIMAUX,ISCAU,SCAUCHY,XMTG)
c
        PREMAC=1./3.*(SCAUCHY(1,1)+SCAUCHY(2,2)+SCAUCHY(3,3))
c
        CALL CHG_BASIS (DBAUX,DSIMAUX,AUX55,AUX3333,2,5)
c
        DO I=1,5
          DBAR(I)=DBAUX(I)+DZERO(I)
        ENDDO
c
        CALL CHG_BASIS (DBAR,DSIM,AUX55,AUX3333,1,5)
c
        CALL CHG_BASIS (SBAR,SCAUCHY,AUX55,AUX3333,2,5)
        CALL CHG_BASIS (SBAR,SDEVIAT,AUX55,AUX3333,1,5)
c
      ENDIF
c
        SVM=SQRT(3./2.)*VNORM(SBAR,5)

C *************************************************************************
C     S* & D* REQUIRED FOR DIFFERENT GRAIN SHAPES
C     SASTAV(I) IS USED INSIDE GRAIN_STRESS
C     SASTBAR(I) IS USED BELOW TO CALCULATE DAST(I)

      SASTMIX=0.
      if(interaction.ne.3.and.interaction.ne.4) SASTMIX=0.75
      DO I=1,5
        SASTAV(I) =0.
        SASTBAR(I)=0.
        DO J=1,5
          SASTAV(I) =SASTAV(I) +BCINV(I,J)*(SAV(J) -PHAVE(J))
          SASTBAR(I)=SASTBAR(I)+BCINV(I,J)*(SBAR(J)-PHAVE(J))
        ENDDO
        SAVEX=SASTAV(I)
        SBARX=SASTBAR(I)
        SASTAV(I) =(1.-SASTMIX)*SAVEX+SASTMIX*SBARX
        SASTBAR(I)=SASTMIX*SAVEX+(1.-SASTMIX)*SBARX
      ENDDO

      DO I=1,5
        DAST(I)=0.
        DO J=1,5
         DAST(I)=DAST(I)+XMTG(I,J)*SASTBAR(J)
        ENDDO
      ENDDO

C *** SAVE CURRENT STRESS IN GRAIN.
C *** STARTING FROM CONVERGED 'XMTG' AND 'STRY' RECALCULATES 'SG' USING THE
C     INTERACTION EQUATION.
C *** USES NEW 'SG' TO CALCULATE STRAIN-RATE 'DG', SHEAR RATES 'GAMDOT' AND
C     MODULI 'XMCTG' FOR EVERY GRAIN.

      KGX=1
      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
        DO I=1,5
          STRY(I,KGX)=SG(I,KKK)
        ENDDO
CFEB
        if((irs.eq.1.and.itso.le.2.and.istep.eq.1)
     #                       .or.interaction.ne.5) then
cwx        if((irs.eq.1.and.itso.eq.1.and.istep.eq.1)
cwx     #                       .or.interaction.ne.5) then
CFEE
          CALL GRAIN_STRESS (1,KGX,KKK,IPHEL,IPH)
          CALL GRAIN_RATE_AND_MODULI (1,1,KGX,KKK,IPHEL,IPH)
CFEB
        else
          CALL GRAIN_STRESS_ALT (KGX,KKK,IPHEL,IPH)
        endif
CFEE
c
      KGX=KGX+1
      ENDDO
      ENDDO

C *** UPDATE AVERAGE STRESS AND AVERAGE STRAIN-RATE.
C *** CALCULATES STRESS CONVERGENCE IN GRAINS.

      SDEV=0.
      DO I=1,5
        SAV(I)=0.
        DAV(I)=0.
        KGX=1
        DO IPH=IPHBOT,IPHTOP
          DO KKK=NGR(IPH-1)+1,NGR(IPH)
            SAV(I)=SAV(I)+SG(I,KKK)*WGT(KGX)
            DAV(I)=DAV(I)+DG(I,KGX)*WGT(KGX)
            SDEV=SDEV+(SG(I,KKK)-STRY(I,KGX))**2*WGT(KGX)
            KGX=KGX+1
          ENDDO
        ENDDO
      ENDDO

C *** CHECK CONSISTENCY OF LOCAL, MACROSCOPIC AND AVERAGE MAGNITUDES.
C      a) <SG-STRY> .LT.ERR
C      b) /DBAR-DAV/.LT.ERR
C      c) /SBAR-SAV/.LT.ERR

      RELSGR=SQRT(SDEV)/VNORM(SBAR,5)
      RELD  =VMISMATCH(DBAR,DAV,5)
      RELS  =VMISMATCH(SBAR,SAV,5)

C *** DEFINES EMPIRICAL MIX COEF FOR SASTAV & SASTBAR BASED ON CONVERGENCE
C     CONVNEW=RELSGR+RELD+RELS
C     CONVDIF=CONVNEW-CONVOLD
C     SASTMIX=0.
C     IF(IT2.GT.10 .AND. CONVDIF.GT.0.) SASTMIX=0.25
C     IF(IT2.GT.20 .AND. CONVDIF.GT.0.) SASTMIX=0.50
C     IF(IT2.GT.30 .AND. CONVDIF.GT.0.) SASTMIX=0.75
C     CONVOLD=CONVNEW
CFEB
      WRITE(*,'(1H+,I5,3E11.3,I7,E11.3,I7,E11.3)')
     #      IT2,RELSGR,RELS,RELD
      WRITE(UW1,'(  I5,3E12.3,I7,E12.3,I7,E12.3)')
     #      IT2,RELSGR,RELS,RELD
CFEE

      ENDDO     ! END OF (DO..WHILE) FOR OUTER ITERATION (IT2) ON 'SG'
c
      SVM=0.
      DVM=0.
      DO I=1,5
        SVM=SVM+SBAR(I)*SBAR(I)
        DVM=DVM+SBAR(I)*DBAR(I)
      ENDDO
      SVM=SQRT(SVM*3./2.)
      DVM=DVM/SVM
CFEB
      if(iflu.eq.1) call fluctuations(erreso,erraso)
c
      if(interaction.eq.5.and.itso.ge.2) then
      write(97,'(2i5,2x,3e12.3)') irs,itso,erraso,erreso
      call somod
      endif
CFEE
      ENDDO     ! END OF (DO..WHILE) FOR SO ITERATION (ITSO)
CFEB
      if(iflu.eq.1) then
       write(83,'(a,i7)') ' NRS = ',jxrs
       if(icubcom.eq.1) write(84,'(a,i7)') ' NRS = ',jxrs
       call sdpx
       if(interaction.eq.5) then
        write(97,'(a,i7,4e11.4)')
     #   ' NRS,SVM,SDS,SDD,UTILDE = '
     #   ,jxrs,svm,sdseqintra,sddeqintra,utilde
        write(97,*)
       endif
      endif

C *** UPDATES VALUES FOR PERFORMING EXTRAPOLATION ON ESO and ASO
      IF(INTERACTION.EQ.5) THEN
        CALL EXTRAPOLSO(1./JXRS,IRS,1)
      ENDIF
CFEE

      ENDDO     ! END OF DO JXRS FOR NRS ITERATION
CFEB
      IF(INTERACTION.EQ.5) CALL GET_GAMDOT
CFEE
      RETURN
      END
C
C ********************************************************************
C     SUBROUTINE VPSC_INPUT      --->      VERSION 01/DEC/2011
C
C     READS CHARACTERISTICS OF THE RUN: # OF PHASES, NAMES OF INPUT FILES,
C     DEFORMATION TO BE IMPOSED, CONVERGENCE PARAMETERS, ETC.
C     READS SINGLE CRYSTAL PROPERTIES: DEFORMATION MODES, CRSS, HARDENING
C     READS CRYSTAL AND MORPHOLOGIC TEXTURES.
C     INITIALIZES ARRAYS REQUIRED TO RUN VPSC.
C     OPENS AND CLOSES INPUT FILES.   OPENS OUTPUT FILES.
C
C     MODIFIED 21/07/98 by CNT:
C     INITIALIZATION RELATED TO 'ELEMENTS' IS DONE INSIDE A SINGLE BLOCK.
C *****************************************************************************
C
      SUBROUTINE VPSC_INPUT

      INCLUDE 'vpsc7.dim'

      DIMENSION AUX5(5),AUX55(5,5),AUX3(3),AUX33(3,3),AUX3333(3,3,3,3)

C *********   INITIALIZATION BLOCK   ***************************

      PI=4.*ATAN(1.)

      DO I=1,5
      DO J=1,5
        XID5(I,J)=0.
        IF(I.EQ.J) XID5(I,J)=1.
      ENDDO
      ENDDO

      DO I=1,3
      DO J=1,3
        ZERO33(I,J)=0.
        XID3(I,J)=0.
        IF(I.EQ.J) XID3(I,J)=1.
      ENDDO
      ENDDO

C     CALCULATES TENSORS OF THE SYMMETRIC BASIS 'B(3,3,6)'
      CALL CHG_BASIS(AUX5,AUX33,AUX55,AUX3333,0,5)

C     SEED FOR RANDOM NUMBER GENERATOR (RAN2) (USED FOR TWINNING AND RX)
      JRAN=-1

CFEB
C     WRITES 'VPSC.IN' FILE INTO 'RUN_LOG.OUT' FILE
      WRITE(10,*)
      WRITE(10,'('' **** INPUT FILE VPSC.IN FOR THIS RUN ****'')')
      DO IDUM=1,1000
        READ(UNIT=UR0,END=10,FMT='(A)') PROSA
        WRITE(10,'(A)') PROSA
      ENDDO
   10 REWIND UR0
      WRITE(10,*)
CFEE

C     READS # OF ELEMENTS, # OF PHASES AND RELATIVE VOLUME OF PHASE IN ELEM.
C     PHASES ARE LABELED SEQUENTIALLY FOR A MULTIELEMENT RUN (i.e. IF ELEMENT
C     #1 CONSISTS OF phase1=fcc AND phase2=bcc, THEN phase3 AND phase4 ARE
C     THE fcc AND bcc PHASES IN ELEMENT #2...AND SO ON)

      nelem=1
CFEB
      READ(UR0,*) NELEM
CFEE
      READ(UR0,*) NPH
      READ(UR0,*) (WPH(I),I=1,NPH)

CFEB
      write(*,*) '***************************************************'
      if(nelem.eq.1) write(*,'('' SINGLE ELEMENT CALCULATION'')')
      if(nelem.gt.1) write(*,'('' MULTIELEMENT CALCULATION'')')
      if(nph.eq.1)   write(*,'('' SINGLE PHASE CALCULATION'')')
      if(nph.gt.1)   write(*,'('' MULTIPHASE CALCULATION'')')
      write(*,*) '***************************************************'

      if(nelem.gt.1) then
        write(*,'('' VPSC7 cannot run multiple elements !!'')')
        write(*,'('' --> use VPSC7FE for multiple elements'')')
        stop
      endif
CFEE

      if(nph*nelem .gt. nphmx) then
        write(*,'('' number of phases exceeds multiphase dimens !!'')')
        write(*,'('' --> increase parameter NPHMX to'',i5)') nph*nelem
        stop
      endif

      if(nelem.gt.nelmx) then
        write(*,'('' number of elements exceeds multielement dim !!'')')
        write(*,'('' --> increase parameter NELMX to'',i5)') nelem
        stop
      endif

C     CHECKS PHASE FRACTIONS AND NORMALIZES

      wphtot=0.
      do iph=1,nph
        wphtot=wphtot+wph(iph)
      enddo
      if(abs(wphtot-1.) .gt. 1.e-5) then
        write(*,*) ' --> vol fraction of phases should add to 1 !!'
        write(*,*) ' --> will normalize phase fractions to 1 !!'
        write(*,'("1")') 
        read(*,*)
        do iph=1,nph
          wph(iph)=wph(iph)/wphtot
        enddo
      endif

C ***************************************************************************
C     LOOP OVER PHASES.
C     FOR EACH PHASE READS CRYSTAL SYSTEMS, TEXTURE AND GRAIN SHAPES.
C ***************************************************************************

C *** INITIALIZE DEFORMATION GRADIENT (AND ELLIPSOID) OF THE ELEMENT
      NGR(0)=0
      ISHAPE(0)=0
      DO I=1,3
      DO J=1,3
        FIJPH(I,J,0)=XID3(I,J)
      ENDDO
      ENDDO
      CALL UPDATE_SHAPE (0)

      DO IPH=1,NPH
        IPHBOT=IPH
        IPHTOP=IPH

        READ(UR0,'(a)') PROSA
        ISHAPE(IPH)=0
        IFRAG(IPH) =0
        CRIT_SHP(IPH)=25
CFEB
        READ(UR0,*)     ISHAPE(IPH),IFRAG(IPH),CRIT_SHP(IPH)
CFEE
        READ(UR0,*)     (AXISPH(0,I,IPH),I=1,3)
        READ(UR0,*)     (EULERPH(I,IPH) ,I=1,3)

        READ(UR0,'(a)') PROSA
        READ(UR0,'(a)') FILETEXT
        READ(UR0,'(a)') PROSA
        READ(UR0,'(a)') FILECRYS
CFEB
        READ(UR0,'(a)') PROSA
        READ(UR0,'(a)') FILEAXES
CFEE

C *** READS SLIP AND TWINNING MODES FOR THE PHASE

        OPEN (UNIT=UR1,FILE=FILECRYS,STATUS='OLD')

        CALL DATA_CRYSTAL (IPH)

C *** READS HARDENING PARAMETERS OF THE HARDENING LAW FOR THIS PHASE
C       IHARDLAW=0 --> EXTENDED VOCE & PREDOMINANT TWIN REORIENTATION
C       IHARDLAW=1 --> MTS MODEL
C       IHARDLAW=2 --> DISLOCATION DENSITY HARDENING

        READ(UR1,*)
        READ(UR1,*) IHARDLAW
        READ(UR1,*) IRATESENS
        IF(IHARDLAW.EQ.1 .AND. IRATESENS.EQ.1) THEN
          WRITE(*,*) ' FOR MTS MODEL RESETS IRATESENS=0 IN CONST LAW'
          IRATESENS=0
          write(*,'("1")') 
          read(*,*)
        ENDIF
        IF(IHARDLAW.EQ.20 .AND. IRATESENS.EQ.1) THEN
          WRITE(*,*) ' FOR DD MODEL RESETS IRATESENS=0 IN CONST LAW'
          IRATESENS=0
          write(*,'("1")') 
          read(*,*)
        ENDIF

        IF(IHARDLAW.EQ.0)  CALL UPDATE_CRSS_VOCE (0)
        IF(IHARDLAW.EQ.1)  CALL UPDATE_CRSS_MTS (EDOTX,TEMPX,0)
        IF(IHARDLAW.EQ.20) CALL UPDATE_CRSS_DD (0)
        IF(IHARDLAW.EQ.22) CALL UPDATE_CRSS_DD_CE2 (0)

        CLOSE(UNIT=UR1)

C *** READS INITIAL TEXTURE (BUNGE.ROE,KOCKS CONVENTIONS) FROM 'FILETEXT'
C *** INITIALIZES DEFORMATION GRADIENT AND ELLIPSOID FOR EACH PHASE.
C *** IF ISHAPE>2 READS INITIAL GRAIN AXES AND ORIENTATION FROM FILEAXES
C     AND INITIALIZES DEF GRADIENT & ELLIPSOID FOR INDIVIDUAL GRAINS.

        OPEN(UNIT=UR2,FILE=FILETEXT,STATUS='OLD')
        IF(ISHAPE(IPH).GE.3) OPEN(UNIT=UR3,FILE=FILEAXES,STATUS='OLD')
          CALL DATA_GRAIN(IPH)
        CLOSE(UNIT=UR2)
        IF(ISHAPE(IPH).GE.3) CLOSE(UNIT=UR3)

        IFLAT(IPH)=0    ! INITIAL SETTING TO UPDATE THE SHAPE OF THE PHASE

        CALL UPDATE_SHAPE (IPH)

      ENDDO     ! END OF DATA INPUT LOOP OVER ALL PHASES

C ***************************************************************************

cq      WRITE(*,*)
cq      WRITE(*,'('' --> NUMBER OF GRAINS PER ELEMENT IS'',I6)') NGR(NPH)
      IF(NGR(NPH).GT.NGRPEL) THEN
        WRITE(*,'('' --> INCREASE PARAMETER NGRPEL IN VPSC7.DIM'')')
        STOP
      ENDIF

      NGTOT=NELEM*NGR(NPH)
      WRITE(*,'('' --> TOTAL NUMBER OF GRAINS IS'',I6)') NGTOT
      IF(NGTOT.GT.NGRMX) THEN
        WRITE(*,'('' --> INCREASE PARAMETER NGRMX IN VPSC7.DIM'')')
        STOP
      ENDIF

C ****************************************************************************
C *** READS SETTINGS FOR CONVERGENCE PROCEDURES.

      READ(UR0,'(A)') PROSA
      READ(UR0,*) ERRS,ERRD,ERRM,ERRSO
      READ(UR0,*) ITMAXEXT,ITMAXINT,ITMAXSO
      irsvar=0
CFEB
      READ(UR0,*) IRSVAR,JXRSINI,JXRSFIN,JXRSTEP
CFEE
      READ(UR0,*) IBCINV

C *** INITIALIZE GAUSS-LEGENDRE OR GAUSS-LOBATO COORDINATES AND ARRAYS USED
C *** IN THE DOUBLE INTEGRALS GIVING THE ESHELBY TENSORS

      CALL ESHELBY(AUX3,AUX3333,0.,AUX3333,AUX3333,AUX33,AUX33,PDIL,
     #                  AUX3333,AUX3333,0)

C ****************************************************************************
C *** READS INPUT/OUTPUT SETTINGS FOR THE RUN.

      irecover=0
      isave=0
CFEB
      READ(UR0,'(A)') PROSA
      READ(UR0,*) IRECOVER
      READ(UR0,*) ISAVE
C      READ(UR0,*) ICAUCHY
CFEE
      icauchy=0.
      icubcom=0
      nwrite=0
CFEB
      READ(UR0,*) ICUBCOM
      READ(UR0,*) NWRITE
CFEE

C ****************************************************************************
C *** READS MODELING CONDITIONS.

      READ(UR0,'(A)') PROSA
      READ(UR0,*) INTERACTION
      READ(UR0,*) IUPDORI,IUPDSHP,IUPDHAR
      READ(UR0,*) NNEIGH
      IFLU=0
CFEB
      READ(UR0,*) IFLU
CFEE
C *** CHECKS PRECISION CONTROL FOR SO CALCULATIONS
      IF(INTERACTION.EQ.5) THEN
        IF(ERRS.GT.1.E-7 .OR. ERRD.GT.1.E-7 .OR.ERRM.GT.1.E-7) THEN
          WRITE(*,'('' SO CALCULATIONS MAY NOT CONVERGE IF TOLERANCES'',
     #              '' ERRS,ERRD,ERRM ARE LARGER THAN 1.E-7'')')
          write(*,'("1")') 
          read(*,*)
        ENDIF
        IF(ERRSO.LT.1.E-2) THEN
          WRITE(*,'('' SO CALCULATIONS MAY NOT CONVERGE IF TOLERANCE'',
     #              '' ERRSO IS SMALLER THAN 1.E-2'')')
          write(*,'("1")') 
          read(*,*)
        ENDIF
      ENDIF

C *** CHECKS IF RATE SENSITIVITY IS THE SAME FOR ALL SYSTEMS.
C *** SEARCH FOR NRSMIN (NEEDED TO GET TAUMAX INSIDE NR SUBROUTINE)

      NUNIQUE=1
      NCOMPA=NRS(1,1)
      NRSMIN=NRS(1,1)
      DO IPH=1,NPH
        DO IS=1,NSYST(IPH)
          IF(NRS(IS,IPH).NE.NCOMPA) NUNIQUE=0
          IF(NRS(IS,IPH).LT.NRSMIN) NRSMIN=NRS(IS,IPH)
        ENDDO
      ENDDO
      IF(NUNIQUE.EQ.0) THEN
        WRITE(*,'('' --> THIS RUN CONTAINS MIXED nrs EXPONENTS !!'')')
        IF(INTERACTION.NE.1) THEN
          WRITE(*,'('' --> WILL FORCE AFFINE (INTERACTION=1)'')')
          INTERACTION=1
          write(*,'("1")') 
          read(*,*)
        ENDIF
      ENDIF

CFEB
      if(interaction.eq.5.and.iflu.eq.0) then
        write(*,*) 'FLUCTUATIONS ARE NEEDED FOR 2nd-ORDER CALCULATION'
        write(*,*) 'IFLU IS RESET TO 1'
        iflu=1
      endif

      if(interaction.eq.0.and.iflu.eq.1) then
        write(*,*)
     #  'INTRAGRANULAR FLUCTS CANNOT BE OBTAINED IN FC CALCULATION'
        write(*,*) 'IFLU IS RESET TO 0'
        iflu=0
      endif

      if(iflu.eq.1) then
        open(83,file='FLUCT.OUT',status='unknown')
        if(icubcom.eq.1) open(84,file='FLCUB.OUT',status='unknown')
      endif

      if(interaction.eq.5) then
        open(97,file='SO.OUT',status='unknown')
      endif
CFEE
      IF(IUPDORI.EQ.0 .AND. IUPDSHP.EQ.1) THEN
        WRITE(*,'('' --> IUPDSHP=1 AND IUPDORI=0'')')
        WRITE(*,'('' --> CANNOT UPDATE SHAPE WITHOUT ALSO UPDATING'',
     #            '' ORIENTATION'')')
        STOP
      ENDIF

      ICOMPGRAIN=0
CFEB
C --> NEED TO REVISE CG MODEL ALGORITHMS
C     IF(IHARDLAW.EQ.2) THEN
C       WRITE(*,*) ' ENTER COMPOSITE GRAIN MODEL TO BE USED:'
C       WRITE(*,*) '   0: FOR UNCOUPLED PARENT AND CHILD'
C       WRITE(*,*) '   1: FOR MIX STRESS/STRAIN CONTINUITY --> '
C       WRITE(*,*) '   2: FOR CONTINUOUS STRESS ACROSS INTERFACE --> '
C       READ(*,*) ICOMPGRAIN
C     ENDIF
CFEE

C ****************************************************************************
C *** INITIALIZE NEIGHBOURS TABLE IF NNEIGH IS NOT ZERO.
C     IOPTION=0 --> RANDOM PAIRING / IOPTION=1 --> SEQUENTIAL PAIRING

      IOPTION=0
C --> NEED TO REVISE CG MODEL ALGORITHMS
C     IF(IHARDLAW.EQ.2) IOPTION=1
      CALL NEIGHBOURS (IOPTION)

C *******************************************************************
C *** INITIALIZE ARRAYS ASSOCIATED WITH GRAINS:
C     HARDENING, ACCUMULATED SHEAR, POWER, TWINNING PARAMETERS, etc

      DO IPH=1,NPH
CFEB
        PRITW(IPH)=0.
        SECTW(IPH)=0.
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          EGVM(KKK)=0.
          WORK(KKK)=0.
          ICOMPGR(KKK)=0   ! starts treating parent & child independently
        ENDDO
CFEE
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          GTOTGR(KKK)=0.
          GAMD0G(KKK)=1.0
          KTWSMX(KKK)=0
          NTWEVENTS(KKK)=0
          DO ITS=1,NTWSYS(IPH)
            TWFRSY(ITS,KKK)=0.
          ENDDO
        ENDDO

        DO ITM=1,NTWMOD(IPH)
          EFTWFR(ITM,IPH)=0.
          TWFRPH(ITM,IPH)=0.
        ENDDO

      ENDDO

C *** INITIALIZE CRSS IN EACH SYSTEM OF EACH GRAIN USING PARAMETERS
C     READ FROM SX FILE.
C     FOR 'MTS' INITIALIZE STRUCTURE, TEMP & RATE INDEPENDENT ARRAY 'TAUE'.

      IPHBOT=1
      IPHTOP=NPH

      IF(IHARDLAW.EQ.0)  CALL UPDATE_CRSS_VOCE (1)
      IF(IHARDLAW.EQ.1)  CALL UPDATE_CRSS_MTS (EDOTX,TEMPX,1)
CFEB
C --> NEED TO REVISE CG MODEL ALGORITHMS
C     IF(IHARDLAW.EQ.2)  CALL UPDATE_CRSS_CG (1,0)
C     IF(IHARDLAW.EQ.-1) CALL UPDATE_CRSS_IRRAD (1)
CFEE

CFEB

C ***************************************************************************
C *** WHEN THERE IS MORE THAN ONE ELEMENT COPIES CRYSTAL, GRAINS & TEXTURE
C     PARAMETERS FROM ELEMENT #1 INTO THE OTHER ELEMENTS.
C *** THE NUMERICAL STRATEGY IS TO USE THE 'PHASE' DIMENSION TO ASSIGN ARRAYS
C     TO THE ELEMENTS:
C     * FOR SINGLE PHASE: GRAINS IN PHASE(N) ARE ASSIGNED TO ELEMENT(N)
C     * FOR 2-PHASE: GRAINS IN PHASES (2N-1) & (2N) ARE ASSIGNED TO ELEMEN(N)
C     * FOR 3-PHASE: GRAINS IN PHASES (3N-2),(3N-1) & (3N) ARE ASSIGNED TO
C       ELEMENT(N)
C ***************************************************************************

      IF(NELEM.GE.2) THEN

      DO IELEM=2,NELEM
        DO IPH=1,NPH
          IPHAC=(IELEM-1)*NPH+IPH

C *** PARAMETERS OF EACH PHASE IN THE ELEMENT

          WPH(IPHAC)=WPH(IPH)
          ISHAPE(IPHAC)=ISHAPE(IPH)
          IFLAT (IPHAC)=IFLAT (IPH)
          IFRAG (IPHAC)=IFRAG (IPH)          ! REDUNDANT DIMENSIONING
          CRIT_SHP(IPHAC)=CRIT_SHP(IPH)      ! REDUNDANT DIMENSIONING
          DO I=1,3
            AXISPH(0,I,IPHAC)=AXISPH(0,I,IPH)
            EULERPH(I,IPHAC) =EULERPH(I,IPH)
            DO J=1,3
              FIJPH(I,J,IPHAC) =FIJPH(I,J,IPH)
              AXISPH(I,J,IPHAC)=AXISPH(I,J,IPH)
            ENDDO
          ENDDO
          NGR(IPHAC)=NGR(IPHAC-1)+(NGR(IPH)-NGR(IPH-1))
cCFEB
          PRITW(IPHAC)=0.
          SECTW(IPHAC)=0.
cCFEE
          DO ITM=1,NTWMOD(IPH)
            EFTWFR(ITM,IPHAC)=0.
            TWFRPH(ITM,IPHAC)=0.
          ENDDO

C *** PARAMETERS OF EACH GRAIN IN THE PHASE

          DO KGX=NGR(IPH-1)+1,NGR(IPH)

            KKK=NGR(NPH)*(IELEM-1)+KGX
            WGT(KKK)   =WGT(KGX)
            GTOTGR(KKK)=0.
            KTWSMX(KKK)=0
            NTWEVENTS(KKK)=0

            DO I=1,3
            DO J=1,3
              AG(I,J,KKK)=AG(I,J,KGX)
            ENDDO
            ENDDO

            DO IS=1,NSYST(IPH)
              CRSS(IS,KKK)=CRSS(IS,KGX)
              TAUE(IS,KKK)=TAUE(IS,KGX)
            ENDDO
            DO ITS=1,NTWSYS(IPH)
              TWFRSY(ITS,KKK)=0.
            ENDDO
cCFEB
            EGVM(KKK)=0.
            WORK(KKK)=0.

            IF(ISHAPE(IPH).NE.0) THEN
              DO I=1,3
                AXISGR(0,I,KKK)=AXISGR(0,I,KGX)
                DO J=1,3
                  FIJGR(I,J,KKK) =FIJGR(I,J,KGX)
                  AXISGR(I,J,KKK)=AXISGR(I,J,KGX)
                ENDDO
              ENDDO
            ENDIF
cCFEE
          ENDDO      ! END OF LOOP OVER KGX
        ENDDO      ! END OF LOOP OVER IPH
      ENDDO      ! END OF LOOP OVER IELEM
      ENDIF      ! END OF CONDITION OVER NELEM.GE.2

CFEE

      RETURN
      END
CFEB
C
C **********************************************************************
C     SUBROUTINE WRITE_ACTIV       --->      VERSION 24/jul/02
C
C     WRITES ACTIVITY STATISTICS OVER DEFORMATION MODES IN 'ACT_PHn.OUT'
C **********************************************************************

      SUBROUTINE WRITE_ACTIV (istep)

      INCLUDE 'vpsc7.dim'

      CHARACTER*8 MODE(NMODMX),TWFR(NMODMX),EFFR(NMODMX)

      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        IUNIT=50+IPHEL

        DO I=1,NMODES(IPHEL)
          MODE(I)='   MODE'//CHAR(48+I)
          TWFR(I)='   TWFR'//CHAR(48+I)
          EFFR(I)='   EFFR'//CHAR(48+I)
        ENDDO

C *** for a PCYS or LANKFORD calculation

        IF(IVGVAR.GE.2) THEN
          if(istep.eq.1) write(IUNIT,'(''    STEP   AVACS'',
     #                    10A8)') (MODE(I),I=1,NMODES(IPHEL))
          write(IUNIT,'(i8,12f8.3)') istep,activ(iph),
     #                   (gavmod(kmo,iph),kmo=1,nmodes(IPHEL))
        ENDIF

C *** for loading histories

        IF(IVGVAR.LE.1) THEN

          IF (NTWMOD(IPHEL).EQ.0) THEN
            if(istep.eq.1) write(IUNIT,'(''  STRAIN   AVACS'',10a8)')
     #                     (MODE(I),I=1,NMODES(IPHEL))
            write(IUNIT,'(12f8.3)') epsacu,activ(iph),
     #                   (gavmod(kmo,iph),kmo=1,nmodes(iphel))

          ELSEIF (NTWMOD(IPHEL).NE.0) THEN

            itm1=nmodes(iphel)-ntwmod(iphel)+1
            itm2=nmodes(iphel)

            IF(IHARDLAW.EQ.0) THEN
            if(istep.eq.1)
     #      write(IUNIT,'(''  STRAIN   AVACS   PRITW   SECTW'',30a8)')
     #                   (MODE(I),I=1,NMODES(IPHEL)),
     #                   (TWFR(J),EFFR(J),j=itm1,itm2)
            write(IUNIT,'(34f8.3)') epsacu,activ(iph),
     #                               pritw(iph),sectw(iph),
     #                   (gavmod(kmo,iph),kmo=1,nmodes(iphel)),
     #         (twfrph(jmo,iph),eftwfr(jmo,iph),jmo=1,ntwmod(iphel))
            ENDIF

            IF(IHARDLAW.EQ.2) THEN
            if(istep.eq.1)
     #      write(IUNIT,'(''  STRAIN  PHFRAC   AVACS'',30a8)')
     #                   (MODE(I),I=1,NMODES(IPHEL)),
     #                   (TWFR(J),j=itm1,itm2)
            write(IUNIT,'(34f8.3)') epsacu,wph(iph),activ(iph),
     #                   (gavmod(kmo,iph),kmo=1,nmodes(iphel)),
     #                   (twfrph(jmo,iph),jmo=1,ntwmod(iphel))
            ENDIF
          ENDIF
        ENDIF

      ENDDO

      RETURN
      END
C
C *******************************************************************
C     SUBROUTINE WRITE_STAT      --->      VERSION 05/OCT/99
C
C     WRITES IN STAT.OUT GENERAL INFORMATION AT SELECTED STEPS
C *******************************************************************

      SUBROUTINE WRITE_STAT(istep)

      INCLUDE 'vpsc7.dim'

      IU=11      ! OUTPUT UNIT

      if(istep.eq.1) write(IU,'(''    epsacu'',
     #   ''     sdev1     sdev2     sdev3     sdev4     sdev5'',
     #   ''     ddev1     ddev2     ddev3     ddev4     ddev5'')')
      write(IU,'(11f10.3)') epsacu,(stdevs(i),i=1,5),(stdevd(i),i=1,5)

c     write(IU,*)
c     if(nelem.gt.1)  write(IU,*) 'Statistics for element',iphbot
c     if(ivgvar.le.1) write(IU,*) 'Statistics for % deformation',epsacu
c     if(ivgvar.eq.2) write(IU,*) 'Statistics for step',istep
c     write(IU,*)
c     write(IU,*) 'Av. strain-rate (d22-d11,2*d33-d11-d22,d23,d13,d12)'
c     write(IU,*) (dav(i),i=1,5)
c     write(IU,*) 'Standard deviation strain-rate'
c     write(IU,'(5f10.3)') (stdevd(i),i=1,5)
c     write(IU,*) 'Average stress  (s22-s11,2*s33-s11-s22,s23,s13,s12)'
c     write(IU,*) (sav(i),i=1,5)
c     write(IU,*) 'Standard deviation stress'
c     write(IU,'(5f10.3)') (stdevs(i),i=1,5)
c     write(IU,*) 'Macro rotation-rate (23,31,12)'
c     write(IU,*) ROTBAR(2,3),ROTBAR(3,1),ROTBAR(1,2)
c     write(IU,*) '% activity of each mode (input order)'
c
c     write(IU,*) 'Av slip rotation    Av local rotation'
c     write(IU,'(2e15.3)') rslbar,rlcbar

   20 format(a,t58,i1)
   30 format(3(f10.6,2x),2x,3(f10.6,2x))

      return
      end
C
C *******************************************************************

      SUBROUTINE WRITE_STRESS_STRAIN (ISTEP)

      INCLUDE 'vpsc7.dim'

      IU=13      ! OUTPUT UNIT

      IF(IDSIM(1)*IDSIM(2)*IDSIM(3) .EQ. 1) THEN
        if(istep.eq.1)
     #  write(IU,'(10x,''Evm'',10x,''Svm'',12x,''E11'',10x,''E22'',
     #    10x,''E33'',10x,''E23'',10x,''E13'',10x,''E12'',
     #     9x,''SDEV11'',7x,''SDEV22'',7x,''SDEV33'',7x,''SDEV23'',
     #     7x,''SDEV13'',7x,''SDEV12'',6x,''TEMP'')')

        write(IU,'(2e13.5,2x,6e13.5,2x,6e13.5,2x,f10.2)')
     #  epsvm,svm,epstot(1,1),epstot(2,2),epstot(3,3),
     #  epstot(2,3),epstot(3,1),epstot(1,2),sdeviat(1,1),sdeviat(2,2),
     #  sdeviat(3,3),sdeviat(2,3),sdeviat(3,1),sdeviat(1,2),temperat
C    #           ,dsim(1,1),dsim(2,2),dsim(3,3)

      ELSE IF (STRAIN_CONTROL.EQ.1) THEN
        if(istep.eq.1)
     #  write(IU,'(10x,''Evm'',10x,''Svm'',12x,''E11'',10x,''E22'',
     #    10x,''E33'',10x,''E23'',10x,''E13'',10x,''E12'',
     #     9x,''SCAU11'',7x,''SCAU22'',7x,''SCAU33'',7x,''SCAU23'',
     #     7x,''SCAU13'',7x,''SCAU12'',6x,''TEMP'')')

        write(IU,'(2e13.5,2x,6e13.5,2x,6e13.5,2x,f10.2)')
     #  epsvm,svm,epstot(1,1),epstot(2,2),epstot(3,3),
     #  epstot(2,3),epstot(3,1),epstot(1,2),scauchy(1,1),scauchy(2,2),
     #  scauchy(3,3),scauchy(2,3),scauchy(3,1),scauchy(1,2)
C    #           ,dsim(1,1),dsim(2,2),dsim(3,3)
      ELSE
        if(istep.eq.1)
     #  write(IU,'(10x,''Evm'',10x,''Dvm'',10x,''Svm'',
     #    12x,''E11'',10x,''E22'',
     #    10x,''E33'',10x,''E23'',
     #    10x,''E13'',10x,''E12'',
     #    12x,''D11'',10x,''D22'',
     #    10x,''D33'',10x,''D23'',
     #    10x,''D13'',10x,''D12'',
     #     9x,''SCAU11'',7x,''SCAU22'',7x,''SCAU33'',7x,''SCAU23'',
     #     7x,''SCAU13'',7x,''SCAU12'',6x,''TEMP'')')

        write(IU,'(3e13.5,2x,6e13.5,2x,6e13.5,2x,6e13.5,2x,f10.2)')
     #  epsvm,dvm,svm,
     #  epstot(1,1),epstot(2,2),epstot(3,3),
     #  epstot(2,3),epstot(3,1),epstot(1,2),
     #  dsim(1,1),dsim(2,2),dsim(3,3),
     #  dsim(2,3),dsim(3,1),dsim(1,2),
     #  scauchy(1,1),scauchy(2,2),
     #  scauchy(3,3),scauchy(2,3),scauchy(3,1),scauchy(1,2)
C    #           ,dsim(1,1),dsim(2,2),dsim(3,3)
      ENDIF

      RETURN
      END

CFEE

C **************************************************************************
C     SUBROUTINE WRITE_TEXTURE      --->     VERSION 10/JAN/2009
C
C     WRITES CRYSTALLOGRAPHIC TEXTURE FOR EACH PHASE.
C     IF ISHAPE(IPH) >0 ALSO WRITES MORPHOLOGIC TEXTURE FOR THE PHASE.
C **************************************************************************

      SUBROUTINE WRITE_TEXTURE

      INCLUDE 'vpsc7.dim'

      DIMENSION AAT(3,3),ATWIN(3,3),TWB(3),TWN(3)
      DIMENSION EULX(3,2*NGRPEL),WGTX(2*NGRPEL)


      DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        NGRX=1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          WGT1=WGT(KKK)

          ISKIP=1
          IF(ISKIP.EQ.0) THEN
C **********************************************************************
C     THIS BLOCK ACCOUNTS FOR THE VOLUME FRACTION OF THE MOST ACTIVE
C     TWIN SYSTEM IN EACH GRAIN WHEN WRITING THE TEXTURE.
C     --> 'TWFRSY' IS FRACTION RELATIVE TO THE GRAIN VOL IF IHARDLAW<2
C     --> 'TWFRSY' IS RELATIVE TO COMPOSITE GRAIN VOLUME IF IHARDLAW=2
C     --> 'AG'    TRANSFORMS FROM CA to SA
C     --> 'ATWIN' TRANSFORMS FROM TA to CA
C **********************************************************************
          WGT2=0.
          IF(IHARDLAW.LE.2) WGTCG=WGT(KKK)
C --> NEED TO REVISE CG MODEL ALGORITHMS
C         IF(IHARDLAW.EQ.2) THEN
C           IF(IPHEL.EQ.1)  WGTCG=WGT(KKK)+WGT(KKK+NGR(IPHBOT))
C           IF(IPHEL.EQ.2)  WGTCG=WGT(KKK)+WGT(KKK-NGR(IPHBOT))
C         ENDIF
          TWFRMX=0.
          IF(NTWMOD(IPHEL).NE.0) THEN

C --> NEED TO REVISE CG MODEL ALGORITHMS
            IF(IHARDLAW.LE.2) THEN
              KTSMX =KTWSMX(KKK)
              TWFRMX=TWFRSY(KTWSMX(KKK),KKK)
            ELSE
              DO KTS=1,NTWSYS(IPHEL)
              IF(TWFRSY(KTS,KKK).GT.TWFRMX.AND.KTS.NE.KTWSMX(KKK)) THEN
                KTSMX =KTS+NSLSYS(IPHEL)
                TWFRMX=TWFRSY(KTS,KKK)
              ENDIF
              ENDDO
            ENDIF

            IF(TWFRMX.GE.0.01) THEN     ! account for if it exceeds 1% of CG
              IF(TWFRMX.GT.1.0) TWFRMX=1.0
              WGT2= TWFRMX*WGTCG       ! absolute fraction
              WGT1= WGT(KKK)-WGT2      ! absolute fraction
              ITWTYPEX=ITWTYPE(KTSMX,IPHEL)
              DO I=1,3
                TWB(I)=DBCA(I,KTSMX,IPHEL)
                TWN(I)=DNCA(I,KTSMX,IPHEL)
              ENDDO
              CALL TWIN_ORIENTATION (ITWTYPEX,TWB,TWN,ATWIN)
              DO I=1,3
              DO J=1,3
                AAT(I,J)=0.
                DO K=1,3
                  AAT(I,J)=AAT(I,J)+AG(J,K,KKK)*ATWIN(K,I)
                ENDDO
              ENDDO
              ENDDO
              CALL EULER(1,GDA,GDB,GDC,AAT)
              EULX(1,NGRX)=GDA
              EULX(2,NGRX)=GDB
              EULX(3,NGRX)=GDC
              WGTX(NGRX)  =WGT2
              NGRX=NGRX+1
            ENDIF

          ENDIF      ! ENF OF IF(NTWMOD.NE.0)
C *******************************************************************
          ENDIF      ! END OF IF(ISKIP.EQ.0)

          DO I=1,3
          DO J=1,3
            AAT(I,J)=AG(J,I,KKK)
          ENDDO
          ENDDO
          CALL EULER(1,GDA,GDB,GDC,AAT)
          EULX(1,NGRX)=GDA
          EULX(2,NGRX)=GDB
          EULX(3,NGRX)=GDC
          WGTX(NGRX)  =WGT1
          NGRX=NGRX+1
        ENDDO      ! END OF DO KKK
        NGRX=NGRX-1

C **********************************************************************
C     WRITE CRYSTALLOGRAPHIC TEXTURE (CRYSTAL ORIENTATION AND WEIGHT)
C **********************************************************************

C --> NEED TO REVISE CG MODEL ALGORITHMS
        IF(IHARDLAW.NE.3) THEN
          IUNIT=30+IPHEL   ! WRITES ONE TEXTURE FILE PER PHASE
          IPHX =IPHEL      ! ELLIPSOID OF THE PHASE
          NGRXX=NGRX
        ELSE IF(IHARDLAW.EQ.3) THEN
          IUNIT=31         ! WRITES ALL TEXTURES IN ONE FILE
          IPHX =0          ! MACROSCOPIC ELLIPSOID
          NGRXX=2*NGRX
        ENDIF

        IF(IHARDLAW.NE.3 .OR. (IHARDLAW.EQ.3 .AND. IPH.EQ.IPHBOT)) THEN
          WRITE(IUNIT,'(A,F10.4)') 'TEXTURE AT STRAIN =',EPSACU
          WRITE(IUNIT,'(3f8.3,A)') (AXISPH(0,I,IPHX),I=1,3) ,
     #         '  <-- length of phase ellipsoid axes'
          WRITE(IUNIT,'(3f8.2,A)') (EULERPH(I,IPHX),I=1,3),
     #         '  <-- Euler angles (deg) of phase ellipsoid axes'
          WRITE(IUNIT,'(''B'',I10)') NGRXX
        ENDIF

        WRITE(IUNIT,'(3F8.2,F12.7)')
     #              ((EULX(I,KG),I=1,3),WGTX(KG),KG=1,NGRX)

C       WRITE(IUNIT,'(3F8.2,F12.7,4E12.4)') GDA,GDB,GDC
C    #              ,ACT(KKK),GTOT(1,KKK),GTOT(2,KKK)            !optional
C    #              ,NEFFC(KKK),WORK(KKK),TAYLORG(KKK)           !optional
C    #              ,EGVM(KKK),SGVM(KKK),WORK(KKK),TAYLORG(KKK)  !optional

      ENDDO      ! END OF DO IPH

CFEB
C ************************************************************************
C     WRITE MORPHOLOGICAL TEXTURE (ELLIPSOID ORIENTATION AND AXES)
C     --> EIG TRANSFORMS FROM GRAIN TO SAMPLE
C     --> gda,gdb,gdc: (ELLIPSOID AXES) WRT (SAMPLE AXES)
C *******************************************************************

      DO IPH=IPHBOT,IPHTOP
        IF(ISHAPE(IPH).NE.0) THEN
          IUNIT=40+IPH

          write(iunit,'(a,f10.4)') 'MORPHOLOGY AT STRAIN =',epsacu
          write(iunit,'(3f8.3,a)') (AXISPH(0,I,IPH),I=1,3) ,
     #           '  <-- AXES LENGTH OF PHASE ELLIPSOID'
          write(iunit,'(3f8.2,a)') (eulerph(i,iph),i=1,3),
     #           '  <-- EULER ANGLES OF PHASE ELLIPSOID (deg)'
          write(iunit,'(''B'',2i10)') (ngr(iph)-ngr(iph-1))

            DO KKK=NGR(IPH-1)+1,NGR(IPH)
              do i=1,3
              do j=1,3
                aat(i,j)=AXISGR(J,I,KKK)
              enddo
              enddo
              call euler(1,gda,gdb,gdc,aat)
              write(iunit,'(3f8.2,3x,3f10.4)') gda,gdb,gdc,
     #                                      (AXISGR(0,I,KKK),I=1,3)
            ENDDO      ! END OF DO LOOP OVER GRAINS

        ENDIF       ! END OF IF(ISHAPE(IPH).NE.0)
      ENDDO      ! END OF DO LOOP OVER PHASES
CFEE

      RETURN
      END

C **************************************************************************
C     SUBROUTINE WRITE_TEXTURE_FE      --->     VERSION 23/MAR/07
C
C     WRITE CRYSTALLOGRAPHIC TEXTURE (CRYSTAL ORIENTATION AND WEIGHT) FOR
C     EACH PHASE ASSOCIATE WITH ELEMENT 'IELEM'
C **************************************************************************

      SUBROUTINE WRITE_TEXTURE_FE (IELEM,EVMX)

      INCLUDE 'vpsc7.dim'

      DIMENSION AAT(3,3)

      DO IPH=1,NPH
        IPHAC=NPH*(IELEM-1)+IPH
        IUNIT=30+IPHAC
        WRITE(IUNIT,'('' TEXTURE FOR PHASE'',I3,'' IN ELEMENT'',I8,
     #     ''  AT VM STRAIN'',F10.3)') IPH,IELEM,EVMX
        WRITE(IUNIT,'(3F8.3,A)') (AXISPH(0,I,IPHAC),I=1,3) ,
     #          '  <-- axes of phase ellipsoid'
        WRITE(IUNIT,'(3F8.2,A)') (EULERPH(I,IPHAC),I=1,3),
     #          '  <-- Euler angles of phase ellipsoid (deg)'
        WRITE(IUNIT,'(''B'',I10)') (ngr(IPHAC)-ngr(IPHAC-1))

        do KKK=ngr(IPHAC-1)+1,ngr(IPHAC)
          do i=1,3
          do j=1,3
            aat(i,j)=ag(j,i,KKK)
          enddo
          enddo
          call euler(1,gda,gdb,gdc,aat)
          write(IUNIT,'(3F8.2,3X,F14.7)') gda,gdb,gdc,wgt(KKK)
        enddo
      ENDDO

      RETURN
      END

CFEB
C ----------------------------------------------------------------
C   SUBROUTINES INCORPORATED BY R.L. FOR DOING FLUCTUATIONS AND SO
C ----------------------------------------------------------------
C
C
C *****************************************************************
C     SUBROUTINE FLUCTUATIONS      --->     VERSION 4/JAN/07
C
C     CALCULATES DERIVATIVES OF EFFECTIVE MODULI WRT LOCAL COMPLIANCES
C     TO OBATAIN STRESS AND STRAIN-RATE SECOND-ORDER MOMENT TENSORS
C     AND CALLS SOP (SECOND-ORDER PROCEDURE) TO OBTAIN IMPROVED
C     LINEARIZED LOCAL MODULI
C ******************************************************************

      subroutine fluctuations(erreso,erraso)
c
      INCLUDE 'vpsc7.dim'
c
      DIMENSION ALFFLU(5,5,5,5),OMEFLU(5,5,5,5)
      DIMENSION THEFLU(5,5,5,5,NPHPEL)
      DIMENSION GAMFLU1A(5),GAMFLU1B(5),GAMFLU3(5)
      DIMENSION XIAUX1(5),XIAUX2(5),XIAUX3(5)
      DIMENSION PIFLU(5,5),DELAUX(5),DELFLU(5,5,5),XKAPFLU(5)
      DIMENSION DMAUX(5,5)
      DIMENSION DMDMR(5,5,5,5),DEAUX(5),DEDMR(5,5,5)
      DIMENSION DMTILDE(5,5,NPHPEL),DGDMR(5,5)
c
      dimension asonew(nsysmx),esonew(nsysmx)
c
      write(*,*)
      WRITE(*,*) 'SUBROUTINE FLUCTUATIONS'
      write(*,*)
c
c     INITIALIZE OMEFLU, DELFLU & XKAPFLU
c
      DO I=1,5
      XKAPFLU(I)=0.
      DO J=1,5
      DO K=1,5
      DELFLU(I,J,K)=0.
      DO L=1,5
c!      OMEFLU(I,J,K,L)=XID5(I,K)*XID5(J,L)
      OMEFLU(I,J,K,L)=0.5*(XID5(I,K)*XID5(J,L)+XID5(I,L)*XID5(J,K))
      ENDDO
      ENDDO
      ENDDO
      ENDDO
c
      KGX=1
      DO IPH=IPHBOT,IPHTOP
c!
      CALL GET_THEFLU(THEFLU,IPH)
c!
c
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
c
c     ALFFLU
c
      DO I=1,5
      DO J=1,5
      DO K=1,5
      DO L=1,5
c
c!      DUMMY=XID5(I,K)*XID5(J,L)
      DUMMY=0.5*(XID5(I,K)*XID5(J,L)+XID5(I,L)*XID5(J,K))
c
      DO M=1,5
      DUMMY=DUMMY+THEFLU(I,M,K,L,IPH)*(XID5(M,J)-BC(M,J,KGX))
      ENDDO
c
      ALFFLU(I,J,K,L)=DUMMY
c
      ENDDO
      ENDDO
      ENDDO
      ENDDO
c
c     OMEFLU
c
      DO I=1,5
      DO J=1,5
      DO K=1,5
      DO L=1,5
c
      DUMMY=0.
c
      DO M=1,5
      DUMMY=DUMMY+BETFLU(I,M,KGX)*ALFFLU(M,J,K,L)
      ENDDO
c
      OMEFLU(I,J,K,L)=OMEFLU(I,J,K,L)-DUMMY*WGT(KKK)
c
      ENDDO
      ENDDO
      ENDDO
      ENDDO
c
c     DELFLU & XKAPFLU
c
      DO I=1,5
      DUMMY=0.
      DO J=1,5
      DUMMY=DUMMY+DCZERO(J,KGX)*CHIFLU(J,I,KGX)
      ENDDO
      DELAUX(I)=DUMMY
      XKAPFLU(I)=XKAPFLU(I)+DUMMY*WGT(KKK)
      ENDDO
c
      DO I=1,5
      DO J=1,5
      DO K=1,5
c
      DUMMY=0.
c
      DO M=1,5
      DUMMY=DUMMY+DELAUX(M)*ALFFLU(M,I,J,K)
      ENDDO
c
      DELFLU(I,J,K)=DELFLU(I,J,K)+DUMMY*WGT(KKK)
c
      ENDDO
      ENDDO
      ENDDO
c
      KGX=KGX+1
      ENDDO
      ENDDO
c
      erreso=0.
      erraso=0.
c
      utilde=0.
cd      do i=1,5
cd      davso(i)=0.
cd      enddo
c
      KGX=1
      DO IPH=IPHBOT,IPHTOP
      IPHEL=IPH-IPHBOT+1
c
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
c
cw      write(*,'(1H+,a,i5)') 'GRAIN ',kgx
cw      write(*,*) 'GRAIN ',kgx
c
      DO IU=1,5
      DO IV=1,5
c
c     dM/dMr(kgx)(iu,iv)
c
c     PIFLU
c
      DO I=1,5
      DO J=1,5
cw      PIFLU(I,J)=WGT(KKK)*(XID5(I,IU)-BETFLU(I,IU,KGX))*
cw     #          BC(IV,J,KGX)+XLAMFLU(I,J)
c
cww      PIFLU(I,J)=WGT(KKK)*(1-(iu/iv)*(iv/iu)/2.)*
      PIFLU(I,J)=WGT(KKK)/2.*
     #           ((XID5(I,IU)-BETFLU(I,IU,KGX))*BC(IV,J,KGX)
     #           +(XID5(I,IV)-BETFLU(I,IV,KGX))*BC(IU,J,KGX))
c!     #           +XLAMFLU(I,J)
c
cx      IF(KVOID.EQ.1) PIFLU(I,J)=PIFLU(I,J)+POR*PHIFLU(I,J,IPH)
      ENDDO
      ENDDO
c
c!      CALL LINSOLVER25(OMEFLU,PIFLU,DMNEW)
      CALL LINSOLVER25(OMEFLU,PIFLU,DMAUX)
c
      DO I=1,5
      DO J=1,5
      DMDMR(I,J,IU,IV)=DMAUX(I,J)
      ENDDO
      ENDDO
c
c     dM~/dMr TO BE USED BELOW FOR dg~/dMr
c
      do iph2=iphbot,iphtop
c
      DO I=1,5
      DO J=1,5
      DUMMY=0.
      DO K=1,5
      DO L=1,5
      DUMMY=DUMMY+THEFLU(I,J,K,L,IPH2)*DMAUX(K,L)
      ENDDO
      ENDDO
      DMTILDE(I,J,IPH2)=DUMMY
      ENDDO
      ENDDO
c
      enddo  ! (iph2)
c
c     dE~/dMr(kgx)(iu,iv)
c
c     GAMFLU1A
c
      GFACT=0.
      DO I=1,5
      GFACT=GFACT+DCZERO(I,KGX)*CHIFLU(I,IU,KGX)
      ENDDO
c
cww      GFACT=-WGT(KKK)*(1-(iu/iv)*(iv/iu)/2.)*GFACT
      GFACT=-WGT(KKK)/2.*GFACT
c
      DO J=1,5
      GAMFLU1A(J)=GFACT*BC(IV,J,KGX)
      ENDDO
c
c     GAMFLU1B
c
      GFACT=0.
      DO I=1,5
      GFACT=GFACT+DCZERO(I,KGX)*CHIFLU(I,IV,KGX)
      ENDDO
c
cww      GFACT=-WGT(KKK)*(1-(iu/iv)*(iv/iu)/2.)*GFACT
      GFACT=-WGT(KKK)/2.*GFACT
c
      DO J=1,5
      GAMFLU1B(J)=GFACT*BC(IU,J,KGX)
      ENDDO
c
c     GAMFLU3(i)= DELFLU(ijk) DMAUX(jk)
c
      DO I=1,5
      DUMMY=0.
      DO J=1,5
      DO K=1,5
      DUMMY=DUMMY+DELFLU(I,J,K)*DMAUX(J,K)
      ENDDO
      ENDDO
      GAMFLU3(I)=DUMMY
      ENDDO
c
c     dE~/dMr(kgx)(iu,iv)
c
      DO I=1,5
c!      DEAUX(I)=GAMFLU1A(I)+GAMFLU1B(I)+GAMFLU2(I)+GAMFLU3(I)
      DEAUX(I)=GAMFLU1A(I)+GAMFLU1B(I)+GAMFLU3(I)
      DEDMR(I,IU,IV)=DEAUX(I)
      ENDDO
c
c     dg~/dMr(kgx)(iu,iv)
c
c     XIFLU1A
c
      XFACT1=0.
      DO L=1,5
      XFACT1=XFACT1+CHIFLU(IV,L,KGX)*(DZERO(L)-DCZERO(L,KGX))
      ENDDO
c
      XFACT2=0.
      DO I=1,5
      XFACT2=XFACT2+DCZERO(I,KGX)*CHIFLU(I,IU,KGX)
      ENDDO
c
cww      XIFLU1=-WGT(KKK)*(1-(iu/iv)*(iv/iu)/2.)*XFACT1*XFACT2
      XIFLU1A=-WGT(KKK)/2*XFACT1*XFACT2
c!
c     XIFLU1B
c
      XFACT1=0.
      DO L=1,5
      XFACT1=XFACT1+CHIFLU(IU,L,KGX)*(DZERO(L)-DCZERO(L,KGX))
      ENDDO
c
      XFACT2=0.
      DO I=1,5
      XFACT2=XFACT2+DCZERO(I,KGX)*CHIFLU(I,IV,KGX)
      ENDDO
c
      XIFLU1B=-WGT(KKK)/2*XFACT1*XFACT2
c
c     XIFLU2
c
      XIFLU2=0.
c
      KGX2=1
      DO IPH2=IPHBOT,IPHTOP
      DO KKK2=NGR(IPH2-1)+1,NGR(IPH2)
c
      DO I=1,5
      DUMMY=0.
      DO J=1,5
      DUMMY=DUMMY+CHIFLU(I,J,KGX2)*(DZERO(J)-DCZERO(J,KGX2))
      ENDDO
      XIAUX1(I)=DUMMY
      ENDDO
c
      DO I=1,5
      DUMMY=0.
      DO J=1,5
      DUMMY=DUMMY+DMTILDE(I,J,IPH2)*XIAUX1(J)
      ENDDO
      XIAUX2(I)=DUMMY
      ENDDO
c
      DO I=1,5
      DUMMY=0.
      DO J=1,5
      DUMMY=DUMMY+CHIFLU(I,J,KGX2)*XIAUX2(J)
      ENDDO
      XIAUX3(I)=DUMMY
      ENDDO
c
      DUMMY=0.
      DO I=1,5
      DUMMY=DUMMY+DCZERO(I,KGX2)*XIAUX3(I)
      ENDDO
      XIFLU2=XIFLU2-DUMMY*WGT(KKK2)
c
      KGX2=KGX2+1
      ENDDO
      ENDDO
c
c     XIFLU3
c
      XIFLU3=0.
      DO I=1,5
      XIFLU3=XIFLU3+XKAPFLU(I)*DEAUX(I)
      ENDDO
c
c!      DGAUX=XIFLU1+XIFLU2+XIFLU3
      DGAUX=XIFLU1A+XIFLU1B+XIFLU2+XIFLU3
      DGDMR(IU,IV)=DGAUX
c
      ENDDO      ! IU ENDDO
      ENDDO      ! IV ENDDO
c
c     SECOND MOMENT STRESS TENSOR (kgx)
c
      DO K=1,5
      DO L=1,5
      DERIVM=0.
      DERIVE=0.
      DO I=1,5
      DERIVE=DERIVE+DEDMR(I,K,L)*SBAR(I)
      DO J=1,5
      DERIVM=DERIVM+DMDMR(I,J,K,L)*SBAR(I)*SBAR(J)
      ENDDO
      ENDDO
      SECMOM5(K,L,KGX)=(DERIVM+2*DERIVE+DGDMR(K,L))/WGT(KKK)
cww      smaux(k,l)=(derivm+2*derive+dgdmr(k,l))/wgt(kkk)
      ENDDO
      ENDDO
c
cww      do k=1,5
cww      do l=1,5
cww      secmom5(k,l,kgx)=(smaux(k,l)+smaux(l,k))/2.
cww      enddo
cww      enddo
c
cw      write(*,*)'GRAIN',kgx
cw      write(*,*)
c
cw      write(*,*) 'SECMOM='
cw      do i=1,5
cw      write(*,'(5E12.3)')(secmom5(i,j,kgx),j=1,5)
cw      enddo
cw      pause
c
      if(interaction.eq.5) then
c
      call sop(iphel,kgx,kkk,asonew,esonew)
c
      esonorm=0.
      asonorm=0.
      erreso1=0.
      erraso1=0.
c
      do is=1,nsyst(iphel)
cc
cc      write(94,'(2i5,4e12.3)')
cc     # kgx,is,aso(is,kgx),asonew(is),eso(is,kgx),esonew(is)
cc
cx      if(kgx.eq.1.and.is.eq.1) write(94,'(2e12.3)')
cx     # asonew(is),esonew(is)
c
      esonorm=esonorm+((eso(is,kgx)+esonew(is))/2)**2
      asonorm=asonorm+((aso(is,kgx)+asonew(is))/2)**2
      erreso1=erreso1+(eso(is,kgx)-esonew(is))**2
      erraso1=erraso1+(aso(is,kgx)-asonew(is))**2
c
c      eso(is,kgx)=esonew(is)
c      aso(is,kgx)=asonew(is)
c
cc      eso(is,kgx)=eso(is,kgx)/2.+esonew(is)/2.
cc      aso(is,kgx)=aso(is,kgx)/2.+asonew(is)/2.
c
      eso(is,kgx)=2./3.*eso(is,kgx)+esonew(is)/3.
      aso(is,kgx)=2./3.*aso(is,kgx)+asonew(is)/3.
c
      enddo
c
      if(jxrs.ne.1) then
      erreso=erreso+sqrt(erreso1/esonorm)*wgt(kkk)
      endif
      erraso=erraso+sqrt(erraso1/asonorm)*wgt(kkk)
c
      endif
c
c     SECOND MOMENT STRAIN-RATE TENSOR (kgx)
c
      DO I=1,5
      DO J=1,5
      DUMMY=0.
      DO K=1,5
      DO L=1,5
      DUMMY=DUMMY+XMCTG(I,K,KGX)*XMCTG(J,L,KGX)*SECMOM5(K,L,KGX)
      ENDDO
      ENDDO
c
      if(interaction.eq.3) then
c
      factn1=10**2
      factn2=2*(1-10)-(1-10)**2
      SECMOM5D(I,J,KGX)=factn1*DUMMY+factn2*DG(I,KGX)*DG(J,KGX)
c
      else if(interaction.eq.4) then
cw
cw      else if(interaction.eq.1.or.interaction.eq.4) then
cw
cwc      factn1=nrs(1,1)**2
cwc      factn2=2*(1-nrs(1,1))-(1-nrs(1,1))**2
cw
cw      factn1=1.
cw      if(interaction.eq.4) factn1=jxrs**2
cw
      factn1=jxrs**2
      factn2=2*(1-jxrs)-(1-jxrs)**2
c
      SECMOM5D(I,J,KGX)=factn1*DUMMY+factn2*DG(I,KGX)*DG(J,KGX)
c
      else
c
      SECMOM5D(I,J,KGX)=DUMMY+DG(I,KGX)*DCZERO(J,KGX)+
     #   DG(J,KGX)*DCZERO(I,KGX)-DCZERO(I,KGX)*DCZERO(J,KGX)
c
      endif
c
      ENDDO
      ENDDO
c
      KGX=KGX+1
      ENDDO
      ENDDO
c
cd      DVMSO=0.
cd      DO I=1,5
cd        DVMSO=DVMSO+DAVSO(I)*SBAR(I)
cd      ENDDO
cd      DVMSO=DVMSO/SVM
c
      if(interaction.eq.5) then
      write(*,*)
      write(*,*) 'ERRESO  = ',erreso
      write(*,*) 'ERRASO  = ',erraso
cx      write(*,*) 'UTILDE  = ',utilde
cx      write(*,*) 'DVM     = ',dvm
cx      write(*,*) 'DVMSO   = ',dvmso
c
c      write(83,*) 'ERRESO = ',erreso
c      write(83,*) 'ERRASO = ',erraso
      endif
c
      return
c
      end
c
C *****************************************************************
C     SUBROUTINE LINSOLVER25      --->     VERSION 4/JAN/07
C
C     SOLVER OF A 25X25 LINEAR SYSTEM, FOR FLUCTUATION CALCULATION
C ******************************************************************

      SUBROUTINE LINSOLVER25(A,B,X)
c
      DIMENSION A(5,5,5,5),B(5,5),X(5,5)
      DIMENSION A1(25,25),B1(25)
      DIMENSION IC(5,5)
c
c      DIMENSION B1AUX(25),B1AUX2(25),A1AUX(25,25)
c
      K=0
      DO I=1,5
      DO J=1,5
      K=K+1
      IC(I,J)=K
      ENDDO
      ENDDO
c
      DO I=1,5
      DO J=1,5
c
      I1=IC(I,J)
      B1(I1)=B(I,J)
c      B1AUX(I1)=B(I,J)
c
      DO K=1,5
      DO L=1,5
c
      J1=IC(K,L)
      A1(I1,J1)=A(I,J,K,L)
c      A1AUX(I1,J1)=A(I,J,K,L)
c
      ENDDO
      ENDDO
      ENDDO
      ENDDO
c
c      open(78,file='trace.out',status='unknown')
c
c      write(78,*) 'A1='
c      do i=1,25
c      write(78,'(25E10.2)') (a1(i,j),j=1,25)
c      enddo
c
c      write(78,*) 'B1='
c      write(78,'(25E10.2)') (b1(j),j=1,25)
c
      CALL LU_EQSYS25(A1,B1,25,ISINGULAR)
c      CALL SIMQ(0.,A1,B1,25,ISINGULAR)
c
c      write(78,*) 'B1='
c      write(78,'(25E10.2)') (b1(j),j=1,25)
c
      if(isingular.eq.1) then
       write(*,*) 'SINGULAR SYSTEM IN LINSOLVER25'
       stop
      endif
c
c      DO I=1,25
c      B1AUX2(I)=0.
c      DO J=1,25
c      B1AUX2(I)=B1AUX2(I)+A1AUX(I,J)*B1(J)
c      ENDDO
c      ENDDO
c
c      do i=1,25
c      write(*,*) b1aux(i),b1aux2(i)
c      enddo
c      pause
c
      K=0
      DO I=1,5
      DO J=1,5
      K=K+1
      X(I,J)=B1(K)
      ENDDO
      ENDDO
c
      RETURN
      END
C
C *****************************************************************
C     SUBROUTINE GET_THEFLU     --->     VERSION 4/JAN/07
C
C     GETS THETA (i.e. THE TERM INVOLVING ESHELBY TENSOR DERIVATIVES)
c     NEEDED FOR FLUCTUATION CALCULATION
C ******************************************************************

      SUBROUTINE GET_THEFLU(THEFLU,IPH)
c
      INCLUDE 'vpsc7.dim'
c
      DIMENSION THEFLU(5,5,5,5,NPHPEL)
c
c
      DIMENSION DLDM5(5,5)
      DIMENSION DLDMSA(3,3,3,3),DLDMGA(3,3,3,3)
c
      DIMENSION EIGB(3,3),AXB(3)
      DIMENSION DS(3,3,3,3),DS5(5,5)
      DIMENSION AUX5(5),AUX33(3,3),AUX3333(3,3,3,3)
      DIMENSION THE1(5,5,5,5),THE2(5,5)
      DIMENSION DSDDM1(3,3,3,3),DSDDM2(3,3,3,3)
c
cw      DIMENSION SSKEW(3,3)
c!
      DO IR=1,5
      DO IS=1,5
c
      DO I=1,5
      DO J=1,5
      DLDM5(I,J)=-0.5*(XLTG(I,IR)*XLTG(IS,J)+XLTG(I,IS)*XLTG(IR,J))
      ENDDO
      ENDDO
c!
c!      CALL CHG_BASIS(AUX5,AUX33,DL5,DLSA,3,5)
      CALL CHG_BASIS(AUX5,AUX33,DLDM5,DLDMSA,3,5)
C
C     ROTATION OF DLSA TO ELLIPSOID (GRAIN) PRINCIPAL AXES
C
cc        if(ishape(iph).le.1) then
          do j=1,3
            axb(j)=axisph(0,j,iph)
            do i=1,3
              eigb(i,j)=axisph(i,j,iph)
            enddo
          enddo
cc        endif
c
      DO 95 I=1,3
      DO 95 J=1,3
      DO 95 M=1,3
      DO 95 N=1,3
        DUMMYB=0.
        DO 90 I1=1,3
        DO 90 J1=1,3
        DO 90 M1=1,3
        DO 90 N1=1,3
c!
          DUMMYB=DUMMYB+EIGB(I1,I)*EIGB(J1,J)*EIGB(M1,M)
     #           *EIGB(N1,N)*DLDMSA(I1,J1,M1,N1)
c!
   90   CONTINUE
c!
        DLDMGA(I,J,M,N)=DUMMYB
c!
   95 CONTINUE

      CALL ESHELBY(AXB,C4GA,0.,AUX3333,AUX3333,AUX33,AUX33,PDIL,
     #             DLDMGA,DSDDM1,4)
c
      CALL ESHELBY(AXB,C4GA,0.,AUX3333,AUX3333,AUX33,AUX33,PDIL,
     #             DLDMGA,DSDDM2,5)
cw
      DO 130 I=1,3
      DO 130 J=1,3
      DO 130 M=1,3
      DO 130 N=1,3
        DUMMYE=0.
        DO 120 I1=1,3
        DO 120 J1=1,3
        DO 120 M1=1,3
        DO 120 N1=1,3
          DUMMYE=DUMMYE+EIGB(I,I1)*EIGB(J,J1)*EIGB(M,M1)
     #        *EIGB(N,N1)*(DSDDM1(I1,J1,M1,N1)+DSDDM2(I1,J1,M1,N1))
  120   CONTINUE
        DS(I,J,M,N)=DUMMYE
  130 CONTINUE
c
      CALL CHG_BASIS(AUX5,AUX33,DS5,DS,4,5)
c
c     THEFLU
c
      DO I=1,5
      DO L=1,5
      DUMMY=0.
      DO K=1,5
      DUMMY=DUMMY+XIMSINVPH(I,K,IPH)*DS5(K,L)
      ENDDO
      THE1(I,L,IR,IS)=DUMMY
      ENDDO
      ENDDO
c
      DO I=1,5
      DO J=1,5
      DUMMY=0.
      DO K=1,5
      DUMMY=DUMMY+(FSPH(I,K,IPH)+XID5(I,K))*XMTG(K,J)
      ENDDO
      THE2(I,J)=DUMMY
      ENDDO
      ENDDO
c
      DO I=1,5
      DO J=1,5
      DUMMY=FSPH(I,IR,IPH)*XID5(J,IS)
      DO L=1,5
      DUMMY=DUMMY+THE1(I,L,IR,IS)*THE2(L,J)
      ENDDO
      THEFLU(I,J,IR,IS,iph)=DUMMY
      ENDDO
      ENDDO
c
      ENDDO     ! IS ENDDO
      ENDDO     ! IR ENDDO
c
      RETURN
      END
c
C *****************************************************************
C     SUBROUTINE SOP
C
C     BUG RELATED TO TWINNING UNIDIRECTIONALITY
C     CORRECTED --> RL, DEC 24, 2008
C
C     USING THE STRESS SECOND-ORDER MOMENT TENSOR OF GRAIN KKK,
C     CALCULATES THE ALPHA'S AND E'S FOR EACH SYSTEM, NEEDED
C     TO DEFINE THE SECOND-ORDER LINEARIZATION, ACCORDING TO
C     THE 'CONSTITUTIVE RELATION' VERSION OF PONTE CASTANEDA'S
C     SECOND-ORDER FORMULATION
C ******************************************************************
c
      subroutine sop(iph1,kgx,kkk,asonew,esonew)
c
      INCLUDE 'vpsc7.dim'
c
cx      real*8 nrsx

      dimension asonew(nsysmx),esonew(nsysmx)
      dimension csigma(5,5),schc1(5)
      dimension sc(5,nsysmx),taux(nsysmx),nrsx(nsysmx)
      dimension isensex(nsysmx)
c
      DO IS=1,NSYST(IPH1)
       ISENSEX(IS)=ISENSE(IS,IPH1)
c
cw        NRSX(IS)=XRS
c
        if(irsvar.eq.1) then
        NRSX(IS)=JXRS
        else
        NRSX(IS)=NRS(IS,IPH1)
        endif
c
        TAUX(IS)=   CRSS(IS,KKK)
        DO J=1,5
          SC(J,IS)=SCH(J,IS,KGX)
        ENDDO
      ENDDO
c
      do i=1,5
      do j=1,5
      csigma(i,j)=secmom5(i,j,kgx)-sg(i,kgx)*sg(j,kgx)
      enddo
      enddo
c
      DO IS=1,NSYST(IPH1)
c
      do j=1,5
      schc1(j)=0.
      do i=1,5
cc      schc1(j)=schc1(j)+sch(i,is,kgx)*csigma(i,j)
      schc1(j)=schc1(j)+sc(i,is)*csigma(i,j)
      enddo
      enddo
c
      schc=0.
      do i=1,5
cc      schc=schc+schc1(i)*sch(i,is,kgx)
      schc=schc+schc1(i)*sc(i,is)
      enddo
c
      if(schc.lt.0) then
c      write(*,*)
      write(*,*) ' *** WARNING ***  m:C:m < 0 ',kgx,is,schc
      write(*,*)
cc
      schc=abs(schc)
      endif
cc
ccc      asonew(is)=aso(is,kgx)
ccc      esonew(is)=eso(is,kgx)
ccc      else
c
      schc=sqrt(schc)
      taubar=0.
      do i=1,5
cc      taubar=taubar+sch(i,is,kgx)*sg(i,kgx)
      taubar=taubar+sc(i,is)*sg(i,kgx)
      enddo
      tauhat=taubar+sign(1.,taubar)*schc
cc
      phipbar=sign(1.,taubar)*(abs(taubar)/taux(is))**nrsx(is)
      phiphat=sign(1.,tauhat)*(abs(tauhat)/taux(is))**nrsx(is)
c
      phihat=taux(is)/(nrsx(is)+1)*(abs(tauhat)/taux(is))**(nrsx(is)+1)
cv
      if(isensex(is).eq.0.and.taubar.lt.0) then
      asonew(is)=0.
      esonew(is)=0.
      else
      asonew(is)=(phiphat-phipbar)/(tauhat-taubar)
      esonew(is)=phipbar-asonew(is)*taubar
      endif
cv
c      write(*,'(5e12.3)') taubar,tauhat,phipbar,phiphat,asonew(is)
c
ccc      endif
cv
      if(.not.(isensex(is).eq.0.and.taubar.lt.0)) then
      utilde=utilde+wgt(kkk)*(phihat+phipbar*(taubar-tauhat))
      endif
cv
      ENDDO
c
      return
      end

C *****************************************************************
C     SUBROUTINE SOMOD     --->     VERSION 4/JAN/07
C
C     WITH THE ALPHA'S AND E'S FOR EACH SYSTEM AND EACH GRAIN
C     CALCULATES THE LOCAL LINEARIZED MODULI, ACCORDING TO
C     THE 'CONSTITUTIVE RELATION' VERSION OF PONTE CASTANEDA'S
C     SECOND-ORDER FORMULATION
C ******************************************************************

      SUBROUTINE SOMOD
c
      INCLUDE 'vpsc7.dim'
c
      DIMENSION AUXTG(5,5)
c
      KGX=1
      DO IPH=IPHBOT,IPHTOP
      IPHEL=IPH-IPHBOT+1
c
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
c
      DO I=1,5
      DO J=1,5
      AUXTG(I,J)=0.
      DO IS=1,NSYST(IPHEL)
      AUXTG(I,J)=AUXTG(I,J)+SCH(I,IS,KGX)*SCH(J,IS,KGX)*ASO(IS,KGX)
      ENDDO
      ENDDO
      ENDDO
c
      DO I=1,5
      DCZERO(I,KGX)=0.
      DO IS=1,NSYST(IPHEL)
      DCZERO(I,KGX)=DCZERO(I,KGX)+SCH(I,IS,KGX)*ESO(IS,KGX)
      ENDDO
      ENDDO
c
      do i=1,5
      do j=1,5
      xmctg(i,j,kgx)=auxtg(i,j)
      enddo
      enddo
c
cw      call lu_inverse(auxtg,5)
cwc
cw      do i=1,5
cw      do j=1,5
cw      xlctg(i,j,kgx)=auxtg(i,j)
cw      enddo
cw      enddo
C
      KGX=KGX+1
      ENDDO
c
      ENDDO
c
      return
      end

C *****************************************************************
C     SUBROUTINE SDPX     --->     VERSION 4/JAN/07
C
C     CALCULATES THE STANDARD DEVIATIONS OF THE EQUIVALENT STRESS
C     AND THE STRAIN-RATE IN THE PX, PER GRAIN, AND PER ROLLING FCC
C     TEXTURE COMPONENT, IF APPROPRIATE
C ******************************************************************

      SUBROUTINE SDPX
c
      INCLUDE 'vpsc7.dim'
c
      dimension seq1cub(0:6),seq2cub(0:6),deq1cub(0:6),deq2cub(0:6)

      CHARACTER*3 IDLABEL
      COMMON/CUCO/widmod(0:6),igrtype(NGRMX),idlabel(0:6)
c
      SEQ1PX=0.
      SEQ2PX=0.
c
      DEQ1PX=0.
      DEQ2PX=0.
c
      if(icubcom.eq.1) then
      do i=0,6
      seq1cub(i)=0.
      seq2cub(i)=0.
      deq1cub(i)=0.
      deq2cub(i)=0.
      enddo
      endif
c
      write(83,'(a)')
     #'   GR#       SEQ1      SEQ2      SDSEQ        DEQ1      DEQ2
     # SDDEQ'
c
      KGX=1
      DO IPH=IPHBOT,IPHTOP
      DO KKK=NGR(IPH-1)+1,NGR(IPH)
c
c     double bar equivalent
c
      DUMMY=0.
      DUMMYD=0.
      DO K=1,5
      DUMMY=DUMMY+SECMOM5(K,K,KGX)
      DUMMYD=DUMMYD+SECMOM5D(K,K,KGX)
      ENDDO
      SEQ2(KGX)=SQRT(3./2.*DUMMY)
      DEQ2(KGX)=SQRT(2./3.*DUMMYD)
c
      SEQ2PX=SEQ2PX+3./2.*DUMMY*WGT(KKK)
      DEQ2PX=DEQ2PX+2./3.*DUMMYD*WGT(KKK)
c
      if(icubcom.eq.1) then
      SEQ2CUB(IGRTYPE(KKK))=SEQ2CUB(IGRTYPE(KKK))+
     #        3./2.*DUMMY*WGT(KKK)/WIDMOD(IGRTYPE(KKK))
      DEQ2CUB(IGRTYPE(KKK))=DEQ2CUB(IGRTYPE(KKK))+
     #        2./3.*DUMMYD*WGT(KKK)/WIDMOD(IGRTYPE(KKK))
      endif
c
c     single bar equivalent
c
      DUMMY=0.
      DUMMYD=0.
      DO K=1,5
      DUMMY=DUMMY+SG(K,KKK)**2
      DUMMYD=DUMMYD+DG(K,KGX)**2
      ENDDO
c
      SEQ1=SQRT(3./2.*DUMMY)
      DEQ1=SQRT(2./3.*DUMMYD)
c
      SEQ1PX=SEQ1PX+3./2.*DUMMY*WGT(KKK)
      DEQ1PX=DEQ1PX+2./3.*DUMMYD*WGT(KKK)
c
      if(icubcom.eq.1) then
      SEQ1CUB(IGRTYPE(KKK))=SEQ1CUB(IGRTYPE(KKK))+
     #        3./2.*DUMMY*WGT(KKK)/WIDMOD(IGRTYPE(KKK))
      DEQ1CUB(IGRTYPE(KKK))=DEQ1CUB(IGRTYPE(KKK))+
     #        2./3.*DUMMYD*WGT(KKK)/WIDMOD(IGRTYPE(KKK))
      endif
c
      if(seq2(kgx).gt.seq1) then
      SDSEQ=SQRT(SEQ2(KGX)**2-SEQ1**2)/SVM
      else
      SDSEQ=0.
      endif
c
      if(deq2(kgx).gt.deq1) then
      SDDEQ=SQRT(DEQ2(KGX)**2-DEQ1**2)/DVM
      else
      SDDEQ=0.
      endif
c
cc      WRITE(*,'(a,i5,a,3f10.3)')
cc     # ' GRAIN = ',KGX,' - SEQ1,SEQ2,SD = ',SEQ1,SEQ2(KGX),SDSEQ
c
cc      WRITE(*,'(a,i5,a,3f10.3)')
cc    # ' GRAIN = ',KGX,' - DEQ1,DEQ2,SD = ',DEQ1,DEQ2(KGX),SDDEQ
c
ccc      WRITE(*,'(1H+,i5,3x,3f10.3,3x,3f10.3)')
ccc     #      KGX,SEQ1,SEQ2(KGX),SDSEQ,DEQ1,DEQ2(KGX),SDDEQ
c
cc      WRITE(83,'(a,i5,a,3f10.3)')
cc     # ' GRAIN = ',KGX,' - SEQ1,SEQ2,SD = ',SEQ1,SEQ2(KGX),SDSEQ
c
      WRITE(83,'(i5,3x,2e10.3,f10.3,3x,2e10.3,f10.3)')
     #      KGX,SEQ1,SEQ2(KGX),SDSEQ,DEQ1,DEQ2(KGX),SDDEQ
c
      KGX=KGX+1
      ENDDO
      ENDDO
c
      SDSEQINTRA=SQRT(SEQ2PX-SVM**2)/SVM
      SDSEQINTER=SQRT(SEQ1PX-SVM**2)/SVM
c
      SDDEQINTRA=SQRT(DEQ2PX-DVM**2)/DVM
      SDDEQINTER=SQRT(DEQ1PX-DVM**2)/DVM
c
      write(*,*)
      write(*,*) 'S SDPX (inter+intra) =',SQRT(SEQ2PX-SVM**2)/SVM
      write(*,*) 'S SDPX (inter)       =',SQRT(SEQ1PX-SVM**2)/SVM
c
      write(*,*) 'D SDPX (inter+intra) =',SQRT(DEQ2PX-DVM**2)/DVM
      write(*,*) 'D SDPX (inter)       =',SQRT(DEQ1PX-DVM**2)/DVM
c
      write(83,'(a,f10.3)')
     * 'S SDPX (inter+intra) = ',SQRT(SEQ2PX-SVM**2)/SVM
      write(83,'(a,f10.3)')
     * 'S SDPX (inter)       = ',SQRT(SEQ1PX-SVM**2)/SVM
c
      write(83,'(a,f10.3)')
     * 'D SDPX (inter+intra) = ',SQRT(DEQ2PX-DVM**2)/DVM
      write(83,'(a,f10.3)')
     * 'D SDPX (inter)       = ',SQRT(DEQ1PX-DVM**2)/DVM
c
      if(icubcom.eq.1) then
c
      write(84,'(a,f10.3)')
     * 'S SDPX (inter+intra) = ',SQRT(SEQ2PX-SVM**2)
c
      write(84,'(a,f10.3)')
     * 'D SDPX (inter+intra) = ',SQRT(DEQ2PX-DVM**2)
c
      write(84,'(a)')
     #'  CMP        SEQ1      SEQ2      SDSEQ        DEQ1      DEQ2
     # SDDEQ'
c
      do i=0,6
cw      SDSEQCUB=SQRT(SEQ2CUB(I)-SEQ1CUB(I))/SVM
cw      SDDEQCUB=SQRT(DEQ2CUB(I)-DEQ1CUB(I))/DVM
      SDSEQCUB=SQRT(SEQ2CUB(I)-SEQ1CUB(I))
      SDDEQCUB=SQRT(DEQ2CUB(I)-DEQ1CUB(I))
      write(84,'(2x,a3,3x,3f10.3,3x,3f10.3)')
     #      idlabel(i),sqrt(seq1cub(i)),sqrt(seq2cub(i)),sdseqcub,
     #        sqrt(deq1cub(i)),sqrt(deq2cub(i)),sddeqcub
      enddo
      endif
c
      return
      end

C *****************************************************************
C     SUBROUTINE GRAIN_STRESS_ALT     --->     VERSION 4/JAN/07
C
C     IN THE SO CASE, CALCULATES THE GRAIN STRESSES
c     AND STRAIN-RATES USING THE LOCALIZATION EQUATION
C ******************************************************************

      SUBROUTINE GRAIN_STRESS_ALT (KGX,KKK,IPHEL,IPH)

      INCLUDE 'vpsc7.dim'

cw      KGX=1
cw      DO 2000 IPH=IPHBOT,IPHTOP
cw      DO 1000 KKK=ngr(iph-1)+1,ngr(iph)
c
      do i=1,5
      sg(i,kgx)=phic(i,kgx)
      do j=1,5
      sg(i,kgx)=sg(i,kgx)+bc(i,j,kgx)*sastbar(j)
      enddo
      enddo
c
      do i=1,5
      dg(i,kgx)=dczero(i,kgx)
      do j=1,5
      dg(i,kgx)=dg(i,kgx)+xmctg(i,j,kgx)*sg(j,kgx)
      enddo
      enddo
c
cw      KGX=KGX+1
cw
cw1000  CONTINUE
cw2000  CONTINUE

      RETURN
      END

C *****************************************************************
C     SUBROUTINE EXTRAPOLSO     --->     VERSION 4/JAN/07
C
C     CALCULATES THE ALPHA'S AND E'S FOR A GIVEN RATE-SENSITIVITY
C     EXPONENT USING THE VALUES OF THE THREE PREVIOUS RS EXPONENTS
c     (QUADRATIC EXTRAPOLATION)
C *****************************************************************

      SUBROUTINE EXTRAPOLSO (X,IRS,IOPTION)

      INCLUDE 'vpsc7.dim'

      COMMON/EXTRAPSO/ASOOLD(NSYSMX,NGRPEL,3),ESOOLD(NSYSMX,NGRPEL,3),
     #                XMRSOLD(3)


      IF(IOPTION.EQ.1) THEN

        IF(IRS.LE.3) THEN
          XMRSOLD(IRS)=X
        ELSE
          XMRSOLD(1)=XMRSOLD(2)
          XMRSOLD(2)=XMRSOLD(3)
          XMRSOLD(3)=X
        ENDIF

        KGX=1
        DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          DO IS=1,NSYST(IPHEL)
            IF(IRS.LE.3) THEN
              ESOOLD(IS,KGX,IRS)=ESO(IS,KGX)
              ASOOLD(IS,KGX,IRS)=ASO(IS,KGX)
            ELSE
              ESOOLD(IS,KGX,1)=ESOOLD(IS,KGX,2)
              ASOOLD(IS,KGX,1)=ASOOLD(IS,KGX,2)
              ESOOLD(IS,KGX,2)=ESOOLD(IS,KGX,3)
              ASOOLD(IS,KGX,2)=ASOOLD(IS,KGX,3)
              ESOOLD(IS,KGX,3)=ESO(IS,KGX)
              ASOOLD(IS,KGX,3)=ASO(IS,KGX)
            ENDIF
          ENDDO
          KGX=KGX+1
        ENDDO
        ENDDO

      ENDIF      ! END OF IF(IOPTION.EQ.1)

      IF(IOPTION.EQ.2) THEN

        KGX=1
        DO IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
        DO KKK=NGR(IPH-1)+1,NGR(IPH)
          DO IS=1,NSYST(IPHEL)

          ASOTRY=
     # (X-XMRSOLD(2))*(X-XMRSOLD(3))/
     # (XMRSOLD(1)-XMRSOLD(2))/(XMRSOLD(1)-XMRSOLD(3))*ASOOLD(IS,KGX,1)+
     # (X-XMRSOLD(1))*(X-XMRSOLD(3))/
     # (XMRSOLD(2)-XMRSOLD(1))/(XMRSOLD(2)-XMRSOLD(3))*ASOOLD(IS,KGX,2)+
     # (X-XMRSOLD(1))*(X-XMRSOLD(2))/
     # (XMRSOLD(3)-XMRSOLD(1))/(XMRSOLD(3)-XMRSOLD(2))*ASOOLD(IS,KGX,3)

          IF(ASOTRY.GT.0) THEN
            ASO(IS,KGX)=ASOTRY
            ESO(IS,KGX)=
     # (X-XMRSOLD(2))*(X-XMRSOLD(3))/
     # (XMRSOLD(1)-XMRSOLD(2))/(XMRSOLD(1)-XMRSOLD(3))*ESOOLD(IS,KGX,1)+
     # (X-XMRSOLD(1))*(X-XMRSOLD(3))/
     # (XMRSOLD(2)-XMRSOLD(1))/(XMRSOLD(2)-XMRSOLD(3))*ESOOLD(IS,KGX,2)+
     # (X-XMRSOLD(1))*(X-XMRSOLD(2))/
     # (XMRSOLD(3)-XMRSOLD(1))/(XMRSOLD(3)-XMRSOLD(2))*ESOOLD(IS,KGX,3)
          ELSE
            ASO(IS,KGX)=ASOOLD(IS,KGX,3)
            ESO(IS,KGX)=ESOOLD(IS,KGX,3)
          ENDIF

          IF(ASO(IS,KGX).LT.0.) THEN
            WRITE(*,*) '  ASO(IS,KGX) NEGATIVE IN EXTRAPOLSO'
            WRITE(*,*) KGX,IS,ASO(IS,KGX)
            write(*,'("1")') 
            read(*,*)
          ENDIF

          ENDDO
          KGX=KGX+1
        ENDDO
        ENDDO

      ENDIF      ! END OF IF(IOPTION.EQ.2)

      RETURN
      END

C ************************************************************
C     SUBROUTINE VOIGT10     --->     VERSION 4/JAN/07
C ************************************************************

      SUBROUTINE VOIGT10(T1,T2,IOPT)

      DIMENSION T1(10),T2(4,4)
      DIMENSION IJV(10,2)
      DATA ((IJV(N,M),M=1,2),N=1,10)
     #  /1,1,2,2,3,3,2,3,1,3,1,2,1,4,2,4,3,4,4,4/

      IF(IOPT.EQ.1) THEN
      DO 30 I=1,10
      I1=IJV(I,1)
      I2=IJV(I,2)
      T2(I1,I2)=T1(I)
   30 T2(I2,I1)=T1(I)
      ENDIF
C
      IF(IOPT.EQ.2) THEN
      DO 40 I=1,10
      I1=IJV(I,1)
      I2=IJV(I,2)
   40 T1(I)=T2(I1,I2)
      ENDIF
C
      RETURN
      END

C *****************************************************************
C     SUBROUTINE GET_GAMDOT     --->     VERSION 4/JAN/07
C
C     CALCULATES GAMDOT's FOR GIVEN VALUES OF SG. THE CALL
C     TO GET_GAMDOT IS RELATED TO THE USE OF GRAIN_STRESS_ALT, AND
C     IT IS CARRIED OUT AT THE END OF EACH DEFORMATION STEP *ONLY*
C     IF INTERACTION.EQ.5 (SO CALCULATION). OTHERWISE, THE GAMDOT'S
C     ARE CALCULATED IN GRAIN_STRESS
C *****************************************************************

      SUBROUTINE GET_GAMDOT
c
      INCLUDE 'vpsc7.dim'
c
      DIMENSION SX(5),GAMD0X(NSYSMX)
      DIMENSION SCX(5,NSYSMX),TAUX(NSYSMX),NRSX(NSYSMX),ISENSEX(NSYSMX)
c
      KGX=1
      DO 2000 IPH=IPHBOT,IPHTOP
        IPHEL=IPH-IPHBOT+1
      DO 1000 KKK=ngr(iph-1)+1,ngr(iph)
c
      DO IS=1,NSYST(IPHEL)
        GAMD0X(IS)=GAMD0G(KGX)
        ISENSEX(IS)=ISENSE(IS,IPHEL)
        NRSX(IS)=   NRS(IS,IPHEL)
        TAUX(IS)=   CRSS(IS,KKK)
        DO J=1,5
          SCX(J,IS)=SCH(J,IS,KGX)
        ENDDO
      ENDDO
c
      DO I=1,5
       SX(I)=SG(I,KKK)
      ENDDO

C     GETS RESOLVED SHEAR STRESSES 'rssx' AND SHEAR RATES 'gamdot'.
C       SIGN(GAMDOT)=SIGN(RSSX).
C       NRS CAN BE EVEN OR ODD.
C       RSS IS ALWAYS > 0 AND IS USED TO CALCULATE VISCOUS COMPLIANCE.

      DO IS=1,NSYST(IPHEL)
        RSSX=SCX(1,IS)*SX(1)+SCX(2,IS)*SX(2)+SCX(3,IS)*SX(3)+
     #       SCX(4,IS)*SX(4)+SCX(5,IS)*SX(5)
        IF(.NOT.(RSSX.GT.0 .OR. ISENSEX(IS).EQ.1)) RSSX=0.
        RSSX=RSSX/TAUX(IS)
        GAMDOT(IS,KGX)=GAMD0X(IS)*ABS(RSSX)**NRSX(IS)*SIGN(1.,RSSX)
c
      ENDDO
c
      KGX=KGX+1

1000  CONTINUE
2000  CONTINUE

      RETURN
      END
CFEE
